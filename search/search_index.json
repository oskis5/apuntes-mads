{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pr\u00e1cticas de la asignatura Metodolog\u00edas \u00c1giles de Desarrollo de Software de la Universidad de Alicante.","title":"Home"},{"location":"01-introduccion-play/comandos-git/","text":"Resumen de comandos Git Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi). Comandos b\u00e1sicos Inicializar git en un directorio: 1 2 3 4 5 6 $ cd /ruta/a/mi/directorio $ git config --global user.name nombre-usuario $ git config --global user.email email $ git init $ git add . $ git commit -m Versi\u00f3n inicial Publicar por primera vez el repositorio local en el remoto (en GitHub): 1 2 $ git remote add origin https://github.com/ usuario / nombre-repo .git $ git push -u origin master El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama master (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: 1 $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: 1 $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): 1 $ git add fichero o directorio El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : 1 $ git commit -m Mensaje Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): 1 $ git reset HEAD fichero Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: 1 $ git commit -a -m Mensaje Se puede abreviar como 1 $ git commit -am Mensaje ` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: 1 2 $ git reset --hard HEAD $ git clean -fd (si se ha a\u00f1adido alg\u00fan fichero) Publicar los cambios en el repositorio remoto: 1 $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). 1 $ git log [--oneline] [--graph] [--all] Comprobar las diferencias entre dos commits: 1 $ git diff hash-previo hash-nuevo Devuelve las cambios que se han introducido desde el commit identificado por y hasta el . Ramas Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: 1 2 3 $ git checkout -b nueva-rama M hola.txt (si hay cambios en el espacio de trabajo se llevan a la nueva rama) Switched to a new branch nueva-rama Listar las ramas de un repositorio: 1 2 3 4 $ git branch master * nueva-rama $ git commit -a -m Confirmamos los cambios en la nueva rama Moverse a otra rama: 1 2 $ git checkout master Switched to branch master Mostrar un fichero de una rama (o commit) dado: 1 $ git show commit o rama : nombre-fichero Comparar dos ramas: 1 $ git diff master nueva-rama El comando git diff master nueva-rama devuelve las diferencias entre las ramas master y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama master . Merge de ramas : Mezclar la rama nueva-rama en la rama master (a\u00f1ade a la master los commits adicionales de la rama nueva-rama ): 1 2 $ git checkout master $ git merge [--no-ff] nueva-rama -m Mensaje de commit La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. 1 2 3 4 5 6 $ git merge nueva-rama CONFLICT (content): Merge conflict in hola.txt Automatic merge failed; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m Arreglado el conflicto en el merge $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama master ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git checkout -b experiment # hacemos cambios $ git commit -m Cambios en experiment $ git checkout master # hacemos cambios $ git commit -a -m Cambios en master $ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama master ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. IMPORTANTE : No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama master y tener una historia lineal: 1 2 3 4 $ git checkout master $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git rebase master CONFLICT (content): Merge conflict in some-file # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use git reset HEAD some-file ... to unstage) # (use git add/rm some-file ... as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add some-file $ git rebase --continue IMPORTANTE : Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: 1 $ git log --graph --oneline Borrar una rama: 1 2 $ git branch -d nueva-rama Deleted branch nueva-rama (was c241d7b) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: 1 $ git branch -D rama Subir una rama al repositorio remoto: 1 $ git push -u origin rama Para no tener que escribir la contrase\u00f1a del repositorio remoto cada vez puedes utilizar el siguiente comando que la guarda en una cach\u00e9: 1 $ git config --global credential.helper cache. Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) 1 2 $ git fetch $ git checkout -b rama origin/ rama Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) 1 $ git remote show origin Subir todas las ramas y etiquetas: 1 $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: 1 $ git push origin --delete branchName Modificar la historia Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: 1 $ git commit --amend [--m Nuevo mensaje ] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): 1 $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: 1 $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: 1 2 3 4 5 6 7 8 9 10 11 12 $ git checkout hash (o tag, por ejemplo v2.0) You are in detached HEAD state. # Ahora est\u00e1s en un detached HEAD $ git branch * (HEAD detached at 594b606) master $ git checkout -b v2.0.1 Switched to a new branch v2.0.1 $ git branch master * v2.0.1 $ git checkout master Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) 1 $ git reset --hard hash M\u00e1s informaci\u00f3n Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"Comandos Git"},{"location":"01-introduccion-play/comandos-git/#resumen-de-comandos-git","text":"Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi).","title":"Resumen de comandos Git"},{"location":"01-introduccion-play/comandos-git/#comandos-basicos","text":"Inicializar git en un directorio: 1 2 3 4 5 6 $ cd /ruta/a/mi/directorio $ git config --global user.name nombre-usuario $ git config --global user.email email $ git init $ git add . $ git commit -m Versi\u00f3n inicial Publicar por primera vez el repositorio local en el remoto (en GitHub): 1 2 $ git remote add origin https://github.com/ usuario / nombre-repo .git $ git push -u origin master El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama master (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: 1 $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: 1 $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): 1 $ git add fichero o directorio El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : 1 $ git commit -m Mensaje Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): 1 $ git reset HEAD fichero Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: 1 $ git commit -a -m Mensaje Se puede abreviar como 1 $ git commit -am Mensaje ` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: 1 2 $ git reset --hard HEAD $ git clean -fd (si se ha a\u00f1adido alg\u00fan fichero) Publicar los cambios en el repositorio remoto: 1 $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). 1 $ git log [--oneline] [--graph] [--all] Comprobar las diferencias entre dos commits: 1 $ git diff hash-previo hash-nuevo Devuelve las cambios que se han introducido desde el commit identificado por y hasta el .","title":"Comandos b\u00e1sicos"},{"location":"01-introduccion-play/comandos-git/#ramas","text":"Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: 1 2 3 $ git checkout -b nueva-rama M hola.txt (si hay cambios en el espacio de trabajo se llevan a la nueva rama) Switched to a new branch nueva-rama Listar las ramas de un repositorio: 1 2 3 4 $ git branch master * nueva-rama $ git commit -a -m Confirmamos los cambios en la nueva rama Moverse a otra rama: 1 2 $ git checkout master Switched to branch master Mostrar un fichero de una rama (o commit) dado: 1 $ git show commit o rama : nombre-fichero Comparar dos ramas: 1 $ git diff master nueva-rama El comando git diff master nueva-rama devuelve las diferencias entre las ramas master y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama master . Merge de ramas : Mezclar la rama nueva-rama en la rama master (a\u00f1ade a la master los commits adicionales de la rama nueva-rama ): 1 2 $ git checkout master $ git merge [--no-ff] nueva-rama -m Mensaje de commit La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. 1 2 3 4 5 6 $ git merge nueva-rama CONFLICT (content): Merge conflict in hola.txt Automatic merge failed; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m Arreglado el conflicto en el merge $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama master ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git checkout -b experiment # hacemos cambios $ git commit -m Cambios en experiment $ git checkout master # hacemos cambios $ git commit -a -m Cambios en master $ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama master ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. IMPORTANTE : No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama master y tener una historia lineal: 1 2 3 4 $ git checkout master $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git rebase master CONFLICT (content): Merge conflict in some-file # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use git reset HEAD some-file ... to unstage) # (use git add/rm some-file ... as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add some-file $ git rebase --continue IMPORTANTE : Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: 1 $ git log --graph --oneline Borrar una rama: 1 2 $ git branch -d nueva-rama Deleted branch nueva-rama (was c241d7b) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: 1 $ git branch -D rama Subir una rama al repositorio remoto: 1 $ git push -u origin rama Para no tener que escribir la contrase\u00f1a del repositorio remoto cada vez puedes utilizar el siguiente comando que la guarda en una cach\u00e9: 1 $ git config --global credential.helper cache. Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) 1 2 $ git fetch $ git checkout -b rama origin/ rama Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) 1 $ git remote show origin Subir todas las ramas y etiquetas: 1 $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: 1 $ git push origin --delete branchName","title":"Ramas"},{"location":"01-introduccion-play/comandos-git/#modificar-la-historia","text":"Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: 1 $ git commit --amend [--m Nuevo mensaje ] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): 1 $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: 1 $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: 1 2 3 4 5 6 7 8 9 10 11 12 $ git checkout hash (o tag, por ejemplo v2.0) You are in detached HEAD state. # Ahora est\u00e1s en un detached HEAD $ git branch * (HEAD detached at 594b606) master $ git checkout -b v2.0.1 Switched to a new branch v2.0.1 $ git branch master * v2.0.1 $ git checkout master Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) 1 $ git reset --hard hash","title":"Modificar la historia"},{"location":"01-introduccion-play/comandos-git/#mas-informacion","text":"Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"M\u00e1s informaci\u00f3n"},{"location":"01-introduccion-play/intro-play-teoria/","text":"Introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS Vamos a ver c\u00f3mo lanzar y desarrollar una aplicaci\u00f3n Play Framework en Java. Presentaremos las principales caracter\u00edsticas de este framework de desarrollo de aplicaciones web mediante ejemplos concretos de c\u00f3digo que vamos a utilizar en las pr\u00e1cticas de la asignatura. Aplicaci\u00f3n play-proyecto-inicial Descarga de la aplicaci\u00f3n La aplicaci\u00f3n play-proyecto-inicial se encuentra en GitHub: https://github.com/domingogallardo/play-proyecto-inicial . Es un esqueleto de aplicaci\u00f3n Play con ejemplos b\u00e1sicos del funcionamiento del framework. Puedes descargarla usando el comando git clone : 1 $ git clone https://github.com/domingogallardo/play-proyecto-inicial.git Se crear\u00e1 el directorio play-proyecto-inicial en el que se habr\u00e1 descargado la aplicaci\u00f3n Play. Uso de IntelliJ para trabajar con la aplicaci\u00f3n Play Aunque es posible trabajar con editores como Visual Studio Code , vamos a explicar c\u00f3mo desarrollar las aplicaciones Play usando el IDE IntelliJ IDEA. Las aplicaciones Play se pueden escribir en Java y en Scala. Nosotros usaremos Java. Una parte importante de las librer\u00edas del framework est\u00e1n escritas en Scala, por lo que debe estar instalado el plugin de Scala en IntelliJ. Se debe importar el proyecto usando la opci\u00f3n sbt , la herramienta de build que usa Play. Sbt es una herramienta similar a Maven para Java, es la herramienta que se usa para construir proyectos Scala. El fichero de configuraci\u00f3n de un proyecto sbt es el fichero build.sbt situado en el directorio ra\u00edz. Para compilar los proyectos tambi\u00e9n es necesario tener instalado JDK. Nos aseguramos de que aparece en el panel de importaci\u00f3n. Si no, seleccionamos el directorio donde se encuentra la versi\u00f3n del JDK que vamos a utilizar. Es conveniente activar la auto-importaci\u00f3n del proyecto sbt. De esta forma, si IntelliJ detecta alg\u00fan cambio en la configuraci\u00f3n sbt realiza la importaci\u00f3n de forma autom\u00e1tica. Si se pincha en el icono de la esquina inferior izquierda de la ventana de IntelliJ podremos activar o desactivar la visualizaci\u00f3n de los nombres de los paneles en los bordes de la ventana. Es recomendable dejarlos visibles. Utilizaremos el panel Terminal para trabajar con sbt y con git . Es recomendable abrir dos tabs, uno para cada cosa. Uso de Visual Studio Code para trabajar con la aplicaci\u00f3n Play Si no es posible utilizar un editor avanzado como IntelliJ es posible usar en su lugar Visual Studio Code . Abre la carpeta con el directorio del proyecto y abre un terminal con la opci\u00f3n Ver Terminal integrado . En ese terminal lanzaremos el comando Docker para trabajar con sbt . Puedes abrir otro terminal pulsando en el s\u00edmbolo + para trabajar con Git. Lanzar la aplicaci\u00f3n Play Podemos ejecutar la aplicaci\u00f3n Play de tres formas. Utilizaremos las tres a lo largo de las pr\u00e1cticas. Usando una m\u00e1quina Docker. Usando el sbt shell que proporciona IntelliJ. Usando la configuraci\u00f3n de ejecuci\u00f3n de IntelliJ. M\u00e1quina Docker La m\u00e1quina docker domingogallardo/playframework contiene todo el software y librer\u00edas para ejecutar aplicaciones Play 2.5.18. La ventaja de utilizar la m\u00e1quina Docker es que Una vez descargada la m\u00e1quina ya no es necesario descargar librer\u00edas adicionales. Est\u00e1 instalada en los laboratorios de la EPS. Nos movemos al directorio de la aplicaci\u00f3n Play y desde el terminal lanzamos el comando docker run para ejecutar la m\u00e1quina sobre el directorio actual conectando el puerto 9000 en el mismo puerto de nuestra m\u00e1quina: 1 2 3 $ cd play-proyecto-inicial $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework [play-java] $ Aparecer\u00e1 el prompt de sbt con el nombre del proyecto. Podremos lanzar comandos de sbt como run o test . Haciendo run se ejecuta la aplicaci\u00f3n web. Por defecto el puerto al que hay que atacar es el 9000. Accediendo a la URL http://localhost:9000 pondremos en marcha la aplicaci\u00f3n. Haciendo test se lanzan los tests incluidos en la aplicaci\u00f3n. Con exit se sale del prompt de sbt y autom\u00e1ticamente se para el contenedor y se elimina el contenedor de Docker. Shell sbt de IntelliJ Tambi\u00e9n es posible arrancar el shell de sbt en un panel propio que proporciona IntelliJ. Cuando lo ejecutamos por primera vez se descargan todas las librer\u00edas necesarias. Configuraci\u00f3n de ejecuci\u00f3n de IntelliJ Tambi\u00e9n podemos crear una configuraci\u00f3n de ejecuci\u00f3n de IntelliJ con la que podremos ejecutar y depurar los proyectos con la opci\u00f3n Run Edit Configurations.. . Una vez creada la configuraci\u00f3n podremos seleccionarla y realizar una ejecuci\u00f3n o una depuraci\u00f3n de la aplicaci\u00f3n pulsando los botones correspondientes en la parte superior de la ventana de IntelliJ. Fichero routes El routes , situado en el directorio conf , especifica el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Fichero conf/routes : 1 2 3 4 5 6 7 8 9 10 11 12 13 # Routes # This file defines all application routes (Higher priority routes first) # ~~~~ # An example controller showing a sample home page GET / controllers.HomeController.index # An example controller showing how to use dependency injection GET /count controllers.CountController.count # An example controller showing how to write asynchronous code GET /message controllers.AsyncController.message # Map static resources from the /public folder to the /assets URL path GET /assets/*file controllers.Assets.versioned(path= /public , file: Asset) Por ejemplo, cuando se recibe la petici\u00f3n GET / (cuando en el navegador escribimos la URL http::/localhost/ ) se ejecutar\u00e1 el m\u00e9todo index de la clase controllers.HomeController . O cuando desde el navegador accedamos a la URL http://localhost/count se generar\u00e1 la petici\u00f3n GET /count y se ejecutar\u00e1 el m\u00e9todo count de la clase controllers.CountController . Controllers El c\u00f3digo a ejecutar cuando se realiza una petici\u00f3n HTTP se define en m\u00e9todos de clases que heredan de Controller . Se suelen colocar en el paquete controllers . Por ejemplo, en la clase controllers.HomeController se define el m\u00e9todo index . Fichero app/controllers/HomeController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 public class HomeController extends Controller { /** * An action that renders an HTML page with a welcome message. * The configuration in the code routes /code file means that * this method will be called when the application receives a * code GET /code request with a path of code / /code . */ public Result index () { return ok ( index . render ( Your new application is ready. )); } } Los m\u00e9todos de las clases Controller deben devolver un objeto Result que representa la respuesta HTTP a la petici\u00f3n. En el caso anterior se devuelve un OK (c\u00f3digo HTTP 200) junto con el c\u00f3digo HTML resultante de renderizar la vista index . Vistas Las p\u00e1ginas HTML que se devuelven se construyen mediante vistas . Las vistas se definen mediante plantillas Scala definidas en el directorio views . En la llamada a renderizar la vista se pueden pasar par\u00e1metros cuyos valores se utilizan en la propia vista. Por ejemplo, la vista anterior index se define en el fichero index.scala.html situado en el directorio views . Fichero views/index.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @* * This template takes a single argument, a String containing a * message to display. *@ @(message: String) @* * Call the `main` template with two arguments. The first * argument is a `String` with the title of the page, the second * argument is an `Html` object containing the body of the page. *@ @main( Welcome to Play ) { @* * Get an `Html` object by calling the built-in Play welcome * template and passing a `String` message. *@ @welcome(message, style = java ) } La vista recibe un par\u00e1metro String . En el cuerpo de la vista se puede escribir c\u00f3digo HTML, c\u00f3digo Scala, y tambi\u00e9n llamar a otras plantillas. Por ejemplo, en la vista anterior se llama a la plantilla main que se define en el fichero main.scala.html , pas\u00e1ndole como par\u00e1metro el c\u00f3digo HTML generado por la plantilla welcome , definida en el fichero welcome.scala.html . Fichero views/main.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @* * This template is called from the `index` template. This template * handles the rendering of the page header and body tags. It takes * two arguments, a `String` for the title of the page and an `Html` * object to insert into the body of the page. *@ @(title: String)(content: Html) !DOCTYPE html html lang = en head @* Here s where we render the page title `String`. *@ title @title / title link rel = stylesheet media = screen href = @routes.Assets.versioned( stylesheets / main . css ) link rel = shortcut icon type = image/png href = @routes.Assets.versioned( images / favicon . png ) script src = @routes.Assets.versioned( javascripts / hello . js ) type = text/javascript / script / head body @* And here s where we render the `Html` object containing * the page content. *@ @content / body / html Fichero views/welcome.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @(message: String, style: String = java ) @defining(play.core.PlayVersion.current) { version = link rel = stylesheet media = screen href = /@@documentation/resources/style/main.css section id = top div class = wrapper h1 a href = https://playframework.com/documentation/@version/Home @message / a / h1 / div / section div id = content class = wrapper doc article h1 Welcome to Play / h1 p Congratulations, you\u2019ve just created a new Play application. This page will help you with the next few steps. / p blockquote p You\u2019re using Play @version / p / blockquote ... } Para incorporar el valor del par\u00e1metro en la plantilla hay que preceder el par\u00e1metro con @ . En el ejemplo anterior se obtiene as\u00ed el mensaje, que se pinta en la parte superior de la p\u00e1gina. La p\u00e1gina HTML resultante mostrada en el navegador es la siguiente: La directiva @defining permite obtener un valor y asign\u00e1rselo a una variable que se utiliza en un bloque de c\u00f3digo. En el caso anterior se utiliza para obtener la versi\u00f3n de Play. Otro ejemplo de su utilizaci\u00f3n es el que aparece en la documentaci\u00f3n de Play sobre plantillas: 1 2 3 @defining(user.getFirstName() + + user.getLastName()) { fullName = div Hello @fullName / div } Inyecci\u00f3n de dependencias Play usa el framework Java de Google Guice para realizar inyecci\u00f3n de dependencias. La anotaci\u00f3n @Inject hace que Play inyecte en la variable anotada un objeto nuevo del tipo indicado por la variable. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. Es posible definir singletons con la anotaci\u00f3n @Singleton . En la aplicaci\u00f3n ejemplo se define un servicio y un controller para implementar un contador que se incrementa en cada petici\u00f3n a la acci\u00f3n count . En el controller se inyecta el componente counter : Fichero controllers/CountController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package controllers ; import javax.inject.* ; import play.mvc.* ; import services.Counter ; @Singleton public class CountController extends Controller { private final Counter counter ; @Inject public CountController ( Counter counter ) { this . counter = counter ; } /** * An action that responds with the {@link Counter} s current * count. The result is plain text. This action is mapped to * code GET /code requests with a path of code /count /code * requests by an entry in the code routes /code config file. */ public Result count () { return ok ( Integer . toString ( counter . nextCount ())); } } El contador se define con una interfaz y una implementaci\u00f3n concreta. Fichero services/Counter.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 package services ; /** * This interface demonstrates how to create a component that is injected * into a controller. The interface represents a counter that returns a * incremented number each time it is called. * * The {@link Modules} class binds this interface to the * {@link AtomicCounter} implementation. */ public interface Counter { int nextCount (); } Fichero services/AtomicCounter.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package services ; import java.util.concurrent.atomic.AtomicInteger ; import javax.inject.* ; /** * This class is a concrete implementation of the {@link Counter} trait. * It is configured for Guice dependency injection in the {@link Module} * class. * * This class has a {@link Singleton} annotation because we need to make * sure we only use one counter per application. Without this * annotation we would get a new instance every time a {@link Counter} is * injected. */ @Singleton public class AtomicCounter implements Counter { private final AtomicInteger atomicCounter = new AtomicInteger (); @Override public int nextCount () { return atomicCounter . getAndIncrement (); } } La definici\u00f3n de la clase concreta que se inyecta se realiza en el m\u00e9todo configure() de una clase llamada Module que debe extender AbstractModule y estar situada en el paquete ra\u00edz. Fichero Module.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import com.google.inject.AbstractModule ; import services.AtomicCounter ; import services.Counter ; /** * This class is a Guice module that tells Guice how to bind several * different types. This Guice module is created when the Play * application starts. * * Play will automatically use any class called `Module` that is in * the root package. You can create modules in other locations by * adding `play.modules.enabled` settings to the `application.conf` * configuration file. */ public class Module extends AbstractModule { @Override public void configure () { // Set AtomicCounter as the implementation for Counter. bind ( Counter . class ). to ( AtomicCounter . class ); } } Tests Los tests se encuentran en el directorio tests . Se utiliza JUnit como framework de testing. Desde los tests se puede comprobar los distintos componentes de la aplicaci\u00f3n, incluyendo plantillas y peticiones a controllers. Lanzamiento de los tests desde sbt Para lanzar los tests desde la consola sbt se debe usar el comando test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [play-java] $ test [info] Updating {file:/code/}root... [info] Resolving jline#jline;2.14.3 ... [info] Done updating. [info] Test run started [info] Test ApplicationTest.simpleCheck started [info] Test ApplicationTest.renderTemplate started [info] Test run finished: 0 failed, 0 ignored, 2 total, 1.337s [info] Test run started [info] Test IntegrationTest.test started [info] application - Creating Pool for datasource default [info] application - ApplicationTimer demo: Starting application at 2018-08-21T07:41:46.226Z [info] application - ApplicationTimer demo: Stopping application at 2018-08-21T07:41:52.807Z after 6s. [info] application - Shutting down connection pool. [info] Test run finished: 0 failed, 0 ignored, 1 total, 9.704s [info] Passed: Total 3, Failed 0, Errors 0, Passed 3 [success] Total time: 37 s, completed Aug 21, 2018 7:41:53 AM Podemos lanzar una parte de los tests con el comando testOnly seguido del nombre completo de la clase (incluyendo el paquete en el que est\u00e9 incluida): 1 2 3 4 5 6 7 8 [play-java] $ testOnly ApplicationTest [info] Test run started [info] Test ApplicationTest.simpleCheck started [info] Test ApplicationTest.renderTemplate started [info] Test run finished: 0 failed, 0 ignored, 2 total, 1.405s [info] Passed: Total 2, Failed 0, Errors 0, Passed 2 [success] Total time: 12 s, completed Aug 21, 2018 9:58:57 AM [play-java] $ Lanzamiento de los tests de IntelliJ Tambi\u00e9n es posible lanzar los tests desde el entorno IntelliJ pulsando con el bot\u00f3n derecho la opci\u00f3n Run sobre la clase de test seleccionada. Aplicaci\u00f3n mads-todolist-inicial La aplicaci\u00f3n mads-todolist-inicial es una versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante todo el cuatrimestre en la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista anteriormente. Entre otros, tiene los siguientes elementos: Distintos comandos HTTP en el fichero de rutas: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban sobre todo la capa de servicios. Distintos ficheros de configuraci\u00f3n para poder arrancar la aplicaci\u00f3n en distintos entornos: desarrollo, integraci\u00f3n y stage (similar a producci\u00f3n). A continuaci\u00f3n se muestran dos de sus pantallas. Pantalla de login Pantalla con listado de tareas Descarga de la aplicaci\u00f3n mads-todolist-inicial Se encuentra en GitHub: https://github.com/domingogallardo/mads-todolist-inicial . Puedes descargarla con el comando git clone : 1 $ git clone https://github.com/domingogallardo/mads-todolist-inicial.git Se crear\u00e1 el directorio mads-todolist-inicial en el que se habr\u00e1 descargado la aplicaci\u00f3n. Importaci\u00f3n en IntellJ IDEA Al importar la aplicaci\u00f3n en IntelliJ IDEA aparece el aviso de que se ha detectado el framework JPA y da la opci\u00f3n de configurarlo. La configuraci\u00f3n es sencilla, s\u00f3lo hay que aceptar la localizaci\u00f3n del fichero persistence.xml que nos muestra la ventana de di\u00e1logo. Hablaremos m\u00e1s adelante de JPA. Ejecuci\u00f3n de la aplicaci\u00f3n usando la base de datos en memoria Si ejecutamos la aplicaci\u00f3n usando el comando docker run ya visto se utilizar\u00e1 la base de datos H2 en memoria. Los datos almacenados en ella s\u00f3lo durar\u00e1n mientras que est\u00e1 en marcha el contenedor. 1 $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework Base de datos MySQL con Docker Si queremos que los datos introducidos persistan a distintas activaciones de la aplicaci\u00f3n web debemos usar una base de datos externa. Esto es necesario cuando la aplicaci\u00f3n est\u00e9 en producci\u00f3n, pero tambi\u00e9n puede ser \u00fatil para realizar pruebas manuales en desarrollo. Podemos utilizar Docker para poner en marcha un servidor MySQL con el siguiente comando: 1 $ docker run -d -p 3316:3306 --name play-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql:5 El comando pone en marcha un servidor MySQL escuchando en el puerto 3316 del host con el nombre docker play-mysql , con la contrase\u00f1a de root indicada y creando la base de datos mads . El puerto del host 3316 se mapea con el puerto interno del contenedor 3306. Ponemos el puerto 3316 para evitar posibles conflictos con un posible servidor de MySQL que tengamos funcionando en el host. Importante En los laboratorios de la EPS est\u00e1 instalada la imagen 5.7.18 de MySQL. Hay que definir expl\u00edcitamente esa versi\u00f3n en el comando docker, escribiendo mysql:5.7.18 . Podemos comprobar que el contenedor est\u00e1 funcionando con el comando docker container ls : 1 2 3 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7c1bed0b5b7e mysql docker-entrypoint... 6 seconds ago Up 4 seconds 0.0.0.0:3316- 3306/tcp play-mysql Para parar y volver a poner en marcha el contenedor mysql puedes usar los comandos docker stop container-id y docker start container-id . Los datos a\u00f1adidos en la base de datos se mantendr\u00e1n mientras que el contenedor no se borre. El comando docker container ls lista los contenedores en marcha, y con la opci\u00f3n -a tambi\u00e9n los parados. 1 2 3 4 5 6 7 8 9 10 11 $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 30 minutes ago Up 22 minutes 33060/tcp, 0.0.0.0:3316- 3306/tcp play-mysql $ docker container stop bd057639b6ac $ docker container ls -a CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 31 minutes ago Exited (0) 7 seconds ago play-mysql $ docker container start bd057639b6ac $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 32 minutes ago Up 5 seconds 33060/tcp, 0.0.0.0:3316- 3306/tcp play-mysql Podemos usar el identificador o el nombre del contenedor para pararlo: 1 $ docker container stop play-mysql Para borrar un contenedor debe estar parado y debemos usar el comando docker container rm container-id . Ejecuci\u00f3n de la aplicaci\u00f3n usando la base de datos MySQL Desde Docker Lanzamos la aplicaci\u00f3n con Docker, definiendo en variables de entorno la URL, el usuario y la contrase\u00f1a con la que debe conectarse la aplicaci\u00f3n a la base de datos. Usamos la opci\u00f3n link de docker para definir el nombre l\u00f3gico del contenedor al que debe conectarse la aplicaci\u00f3n. 1 2 3 $ docker run --link play-mysql --rm -it -p 9000:9000 -e \\ DB_URL= jdbc:mysql://play-mysql:3306/mads -e DB_USER_NAME= root -e \\ DB_USER_PASSWD= mads -v ${PWD}:/code domingogallardo/playframework Y desde la consola sbt modificamos la preferencia config.file para que la aplicaci\u00f3n utilice la configuraci\u00f3n definida en el fichero conf/develop-mysql.conf (lo explicamos m\u00e1s adelante). 1 2 [mads-todolist-2018] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-2018] $ run Desde el run/debug de IntelliJ Tambi\u00e9n es posible definir una configuraci\u00f3n de run/debug en IntelliJ en la que se inicialice la preferencia config.file y las variables de entorno para conectarse con la base de datos, en el puerto del host en el que est\u00e1 escuchando (3331, si hemos lanzado el servicio de base de datos usando Docker como hemos visto anteriormente): Cuidado : Si est\u00e1s lanzando MySQL usando Docker Toolbox debes modificar la DB_URL indicando el host al que conectarse (no ser\u00e1 localhost ). La direcci\u00f3n IP ser\u00e1 la que aparece en la consola de docker al arrancar. Por ejemplo jdbd:mysql://192.168.99.100/mads . Panel Database de IntelliJ Desde el panel Database de IntelliJ (en la esquina superior derecha) es posible crear una conexi\u00f3n a la base de datos que nos permitir\u00e1 verificar c\u00f3mo se guardan los datos de la aplicaci\u00f3n. Hay que a\u00f1adir una base de datos de tipo MySQL y configurarla con los siguientes par\u00e1metros: Cuidado : Igual que en el apartado anterior, si est\u00e1s lanzando MySQL usando Docker Toolbox debes indicar el host al que conectarse (no ser\u00e1 localhost ) escribiendo la direcci\u00f3n IP que aparece en la consola de docker al arrancar. Es posible examinar el esquema de la base de datos: Y examinar tablas en concreto: Configuraci\u00f3n de la aplicaci\u00f3n Los distintos par\u00e1metros de la aplicaci\u00f3n Play se configuran en un fichero de propiedades. Configuraci\u00f3n por defecto El fichero de configuraci\u00f3n que carga la aplicaci\u00f3n por defecto es conf/application.conf . Por ejemplo, las propiedades relacionadas con la definici\u00f3n de la base de datos que se definen en el fichero son las siguientes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Default persistenceUnit for JPA jpa.default = develop db { # You can declare as many datasources as you want. # By convention, the default datasource is named `default` # https://www.playframework.com/documentation/latest/Developing-with-the-H2-Database # Memory H2 database default.driver = org.h2.Driver default.url = jdbc:h2:mem:play;MODE=MYSQL #default.username = sa #default.password = # Definiemos el nombre JNDI de la BD que va a usar la aplicaci\u00f3n default.jndiName=DBTodoList # You can turn on SQL logging for any datasource # https://www.playframework.com/documentation/latest/Highlights25#Logging-SQL-statements # default.logSql=true } En el fichero por defecto se define una conexi\u00f3n con la base de datos de memoria H2 en la fuente de datos llamada default (la fuente de datos que usa por defecto la aplicaci\u00f3n). Se definen las siguientes propiedades: jpa.default : Nombre de la unidad de persistencia JPA que se usar\u00e1 en la aplicaci\u00f3n. db.default.driver : Driver de la base de datos. db.default.url : URL de conexi\u00f3n a la base de datos. db.default.jndiName : Nombre l\u00f3gico JNDI que se asigna a la base de datos. db.default.logSql : Si se descomenta se mostrar\u00e1 en la consola el log de todas las operaciones sobre la base de datos. Otras configuraciones Como ya hemos visto, modificando la propiedad del sistema Java config.file podemos definir un fichero de configuraci\u00f3n distinto. Se definen tambi\u00e9n los siguientes ficheros adicionales que se usar\u00e1n para lanzar la aplicaci\u00f3n en distintas configuraciones: develop-mysql.conf : configuraci\u00f3n de desarrollo con base de datos externa. La aplicaci\u00f3n trabaja sobre una base de datos MySQL externa cuyo esquema se actualiza autom\u00e1ticamente al modificar y a\u00f1adir nuevas entidades a la aplicaci\u00f3n. production.conf : configuraci\u00f3n de producci\u00f3n. La aplicaci\u00f3n trabaja sobre una base de datos MySQL externa, cuyo esquema es validado para que se corresponda con las entidades de la aplicaci\u00f3n. Fichero conf/develop-mysql.conf : 1 2 3 4 5 6 include application.conf db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Fichero conf/production.conf : 1 2 3 4 5 6 7 8 9 10 include application.conf play.crypto.secret= abcdefghijkl jpa.default = production db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Los dos ficheros de configuraci\u00f3n incluyen el fichero application.conf y despu\u00e9s modifican las propiedades necesarias. Los valores de los par\u00e1metros de configuraci\u00f3n de la base de datos url , username y password se obtienen de las variables de entorno. Gesti\u00f3n de persistencia con JPA Para la gesti\u00f3n de la persistencia de los datos en una aplicaci\u00f3n Play usaremos JPA ( Java Persistence API ), en concreto la implementaci\u00f3n 5.2.5 de Hibernate. Definici\u00f3n del modelo de datos El framework JPA permite definir el esquema de la base de datos usando anotaciones en las clases denominadas de entidad. Para cada clase de entidad se define una tabla en la base de datos, con columnas que se mapean con sus atributos. Por ejemplo, la clase Usuario define una tabla Usuario en la base de datos. Los distintos atributos ( login , email , ...) se corresponden con las columnas de la tabla. El atributo id se corresponde con la clave primaria de la tabla. JPA define varias estrategias para obtener esa clave primera, y se ha escogido la estrategia AUTO . Cuando un usuario creado en memoria se haga persistente en la base de datos, este atributo se actualizar\u00e1 con el valor obtenido por Hibernate. La estrategia AUTO se basa en obtener el valor de la clave primaria usando una tabla auxiliar hibernate_sequence que guarda el siguiente valor a asignar a una nueva clave primaria. Adem\u00e1s de los atributos, en la clase se define un constructor con los atributos obligatorios para definir un usuario, unos getters y setters y los m\u00e9todos equals y hashCode para comparar usuarios. Fichero models/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @Entity public class Usuario { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; private String login ; private String email ; private String password ; private String nombre ; private String apellidos ; @Temporal ( TemporalType . DATE ) private Date fechaNacimiento ; // Relaci\u00f3n uno-a-muchos entre usuario y tarea @OneToMany ( mappedBy = usuario , fetch = FetchType . EAGER ) private Set Tarea tareas = new HashSet (); @ManyToMany ( mappedBy = usuarios , fetch = FetchType . EAGER ) private Set Equipo equipos = new HashSet (); // Un constructor vac\u00edo necesario para JPA public Usuario () { } // El constructor principal con los campos obligatorios public Usuario ( String login , String email ) { this . login = login ; this . email = email ; } // Getters y setters necesarios para JPA ... // Funci\u00f3n para imprimr los datos de un usuario public String toString () { String fechaStr = null ; if ( fechaNacimiento != null ) { SimpleDateFormat formateador = new SimpleDateFormat ( dd-MM-yyyy ); fechaStr = formateador . format ( fechaNacimiento ); } return String . format ( Usuario id: %s login: %s password: %s nombre: %s + apellidos: %s e-mail: %s fechaNacimiento: %s , id , login , password , nombre , apellidos , email , fechaNacimiento ); } // Funciones hashCode y equals para poder comparar usuarios y // necesarias para poder crear un Set de usuarios @Override public int hashCode () { // Devolvemos el hash de los campos obligatorios return Objects . hash ( login , email ); } // Si el usuario tiene un ID (se ha obtenido de la BD) // la comparaci\u00f3n se basa en ese ID. Si el ID no existe (el usuario // se ha creado en memoria y todav\u00eda no se ha sincronizado con la BD) // la comparaci\u00f3n se basa en los atributos obligatorios. @Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( getClass () != obj . getClass ()) return false ; Usuario other = ( Usuario ) obj ; if ( id != null other . id != null ) { // Si tenemos los ID, comparamos por ID return ( id == other . id ); } // sino comparamos por campos obligatorios else { if ( login == null ) { if ( other . login != null ) return false ; } else if (! login . equals ( other . login )) return false ; if ( email == null ) { if ( other . email != null ) return false ; } else if (! email . equals ( other . email )) return false ; } return true ; } } En la definici\u00f3n de la entidad tambi\u00e9n se incluyen relaciones con otras entidades. En este caso un Usuario tiene muchas Tarea s (una relaci\u00f3n una-a-muchos) y puede participar en Equipo s (relaci\u00f3n muchos-a-muchos). La relaci\u00f3n uno-a-muchos se representa en la base de datos con una clave ajena. El atributo mappedBy indica que la clave ajena se va a guardar en la columna correspondiente con el atributo usuario de la entidad Tarea . La relaci\u00f3n muchos-a-muchos se representa en la base de datos con una tabla auxiliar con dos claves ajenas. El atributo mappedBy indica que la definici\u00f3n de esa tabla se encuentra en el atributo usuario de la entidad Equipo . Las definiciones de Tarea y Equipo son las siguientes: Fichero models/Tarea.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Entity public class Tarea { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; private String titulo ; // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = usuarioId ) public Usuario usuario ; public Tarea () { } // Constructor, getters y setters, equals y hashCode } Fichero models/Equipo.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Entity public class Equipo { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; private String nombre ; @ManyToMany @JoinTable ( name = Equipo_Usuario , joinColumns = { @JoinColumn ( name = fk_equipo ) }, inverseJoinColumns = { @JoinColumn ( name = fk_usuario )}) private Set Usuario usuarios = new HashSet (); // Un constructor vac\u00edo necesario para JPA public Equipo () { } // Constructor, getters y setters, equals y hashCode // M\u00e9todos de actualizaci\u00f3n de la relaci\u00f3n muchos-a-muchos con usuario public void addUsuario ( Usuario usuario ) { usuarios . add ( usuario ); usuario . getEquipos (). add ( this ); } public void removeUsuario ( Usuario usuario ) { usuarios . remove ( usuario ); usuario . getEquipos (). remove ( this ); } } Actualizaci\u00f3n de los datos Se definen clases repository que definen m\u00e9todos para actualizar las entidades y realizar queries sobre ellas. Para dejar abierta la posibilidad de cambiar la implementaci\u00f3n, se definen con interfaces. Fichero models/UsuarioRepository.java : 1 2 3 4 5 6 7 public interface UsuarioRepository { Usuario add ( Usuario usuario ); // Queries Usuario findById ( Long id ); Usuario findByLogin ( String login ); } Fichero models/TareaRepository.java : 1 2 3 4 5 6 7 8 public interface TareaRepository { Tarea add ( Tarea tarea ); Tarea update ( Tarea tarea ); void delete ( Tarea tarea ); // Queries Tarea findById ( Long idTarea ); } Fichero models/EquipoRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 public interface EquipoRepository { Equipo add ( Equipo equipo ); Equipo update ( Equipo equipo ); void delete ( Equipo equipo ); void addUsuarioEquipo ( Usuario usuario , Equipo equipo ); void deleteUsuarioEquipo ( Usuario usuario , Equipo equipo ); // Queries Equipo findById ( Long idEquipo ); Equipo findByNombre ( String nombre ); List Equipo findAll (); List Usuario findUsuariosEquipo ( String nombreEquipo ); } La implementaci\u00f3n utiliza JPA para realizar las actualizaciones y consultas sobre las entidades. Cada m\u00e9todo abre y cierra una transacci\u00f3n en la que se propaga el cambio a la base de datos. Para trabajar con JPA en Play se debe usar un objeto JPAApi que se obtiene por inyecci\u00f3n de dependencias. Play guarda en la variable jpaApi una instancia con la que podemos, entre otras cosas, abrir y cerrar transacciones. Por ejemplo, la implementaci\u00f3n de la parte de la interfaz EquipoRepository que trata de la actualizaci\u00f3n de la entidad en la base de datos es la siguiente: Fichero models/JPAEquipoRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public class JPAEquipoRepository implements EquipoRepository { JPAApi jpaApi ; @Inject public JPAEquipoRepository ( JPAApi api ) { this . jpaApi = api ; } @Override public Equipo add ( Equipo equipo ) { return jpaApi . withTransaction ( entityManager - { entityManager . persist ( equipo ); entityManager . flush (); entityManager . refresh ( equipo ); return equipo ; }); } @Override public Equipo update ( Equipo equipo ) { return jpaApi . withTransaction ( entityManager - { return entityManager . merge ( equipo ); }); } @Override public void delete ( Equipo equipo ) { jpaApi . withTransaction ( () - { EntityManager entityManager = jpaApi . em (); Equipo equipoBD = entityManager . getReference ( Equipo . class , equipo . getId ()); entityManager . remove ( equipoBD ); }); } @Override public void addUsuarioEquipo ( Usuario usuario , Equipo equipo ) { jpaApi . withTransaction ( () - { EntityManager entityManager = jpaApi . em (); Equipo equipoBD = entityManager . merge ( equipo ); Usuario usuarioBD = entityManager . merge ( usuario ); equipoBD . addUsuario ( usuarioBD ); }); } @Override public void deleteUsuarioEquipo ( Usuario usuario , Equipo equipo ) { jpaApi . withTransaction ( () - { EntityManager entityManager = jpaApi . em (); Equipo equipoBD = entityManager . merge ( equipo ); Usuario usuarioBD = entityManager . merge ( usuario ); equipoBD . removeUsuario ( usuarioBD ); }); } Todos los m\u00e9todos trabajan con un EntityManager , que es la clase de JPA que gestiona las actualizaciones y queries sobre la base de datos. Y las queries se implementan de la siguiente manera: Fichero models/JPAEquipoRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @Override public Equipo findById ( Long idEquipo ) { return jpaApi . withTransaction ( entityManager - { return entityManager . find ( Equipo . class , idEquipo ); }); } @Override public Equipo findByNombre ( String nombre ) { return jpaApi . withTransaction ( entityManager - { TypedQuery Equipo query = entityManager . createQuery ( select e from Equipo e where e.nombre = :nombre , Equipo . class ); try { Equipo equipo = query . setParameter ( nombre , nombre ). getSingleResult (); return equipo ; } catch ( NoResultException ex ) { return null ; } }); } @Override public List Equipo findAll () { return jpaApi . withTransaction ( entityManager - { TypedQuery Equipo query = entityManager . createQuery ( select e from Equipo e , Equipo . class ); return query . getResultList (); }); } public List Usuario findUsuariosEquipo ( String nombreEquipo ) { return jpaApi . withTransaction ( entityManager - { TypedQuery Usuario query = entityManager . createQuery ( select u from Usuario u join u.equipos e where e.nombre = :nombreEquipo , Usuario . class ); try { return query . setParameter ( nombreEquipo , nombreEquipo ). getResultList (); } catch ( NoResultException ex ) { return null ; } }); } } Servicios La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es obtener o crear los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas. Fichero services/UsuarioService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class UsuarioService { UsuarioRepository repository ; // Play proporcionar\u00e1 autom\u00e1ticamente el UsuarioRepository necesario // usando inyecci\u00f3n de dependencias @Inject public UsuarioService ( UsuarioRepository repository ) { this . repository = repository ; } public Usuario creaUsuario ( String login , String email , String password ) { if ( repository . findByLogin ( login ) != null ) { throw new UsuarioServiceException ( Login ya existente ); } Usuario usuario = new Usuario ( login , email ); usuario . setPassword ( password ); return repository . add ( usuario ); } public Usuario findUsuarioPorLogin ( String login ) { return repository . findByLogin ( login ); } public Usuario findUsuarioPorId ( Long id ) { return repository . findById ( id ); } public Usuario login ( String login , String password ) { Usuario usuario = repository . findByLogin ( login ); if ( usuario != null usuario . getPassword (). equals ( password )) { return usuario ; } else { return null ; } } } Fichero services/UsuarioServiceException.java : 1 2 3 4 5 6 7 8 9 public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException () { } public UsuarioServiceException ( String message ) { super ( message ); } } Controllers Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen tres clases controller: UsuarioController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. EquipoController : con m\u00e9todos para crear, a\u00f1adir usuarios y listar equipos. Por ejemplo, la clase EquipoController define las acciones relacionadas con crear equipos de usuarios. En este controlador se obtienen los datos del formulario de la petici\u00f3n HTTP usando un DynamicForm que contiene todos los valores (Strings) asociados a los datos del formulario. Tambi\u00e9n es posible realizar un mapping autom\u00e1tico entre los datos de un formulario y un objeto Java usando un objeto Form . En el UsuarioController se puede ver un ejemplo que usa las clases Login y Registro . En este caso es posible definir restricciones en los atributos y realizar una validaci\u00f3n en el servidor. Fichero controllers/EquipoController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package controllers ; public class EquipoController extends Controller { @Inject FormFactory formFactory ; @Inject EquipoService equipoService ; @Security.Authenticated ( ActionAuthenticator . class ) public Result formularioNuevoEquipo () { return ok ( formNuevoEquipo . render ( )); } @Security.Authenticated ( ActionAuthenticator . class ) public Result creaNuevoEquipo () { DynamicForm requestData = formFactory . form (). bindFromRequest (); String nombre = requestData . get ( nombre ); if ( nombre == null || nombre . equals ( )) { return badRequest ( formNuevoEquipo . render ( Debes rellenar el nombre )); } equipoService . addEquipo ( nombre ); return ok ( Equipo + nombre + a\u00f1adido correctamente ); } public Result listaEquipos () { List Equipo equipos = equipoService . allEquipos (); return ok ( listaEquipos . render ( equipos )); } @Security.Authenticated ( ActionAuthenticator . class ) public Result formularioAddUsuarioEquipo () { return ok ( formEquipoUsuario . render ()); } @Security.Authenticated ( ActionAuthenticator . class ) public Result addUsuarioEquipo () { DynamicForm requestData = formFactory . form (). bindFromRequest (); String equipo = requestData . get ( equipo ); String usuario = requestData . get ( usuario ); try { equipoService . addUsuarioEquipo ( usuario , equipo ); return ok ( Usuario + usuario + a\u00f1adido al equipo + equipo ); } catch ( EquipoServiceException exception ) { return notFound ( No existe usuario / equipo ); } } } La clase UsuarioController se encarga de las acciones de registro y login. Fichero controllers/UsuarioController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 package controllers ; public class UsuarioController extends Controller { @Inject FormFactory formFactory ; // Play injecta un usuarioService junto con todas las dependencias necesarias: // UsuarioRepository y JPAApi @Inject UsuarioService usuarioService ; public Result saludo ( String mensaje ) { return ok ( saludo . render ( El mensaje que he recibido es: + mensaje )); } public Result formularioRegistro () { return ok ( formRegistro . render ( formFactory . form ( Registro . class ), )); } public Result registroUsuario () { Form Registro form = formFactory . form ( Registro . class ). bindFromRequest (); if ( form . hasErrors ()) { return badRequest ( formRegistro . render ( form , Hay errores en el formulario )); } Registro datosRegistro = form . get (); if ( usuarioService . findUsuarioPorLogin ( datosRegistro . login ) != null ) { return badRequest ( formRegistro . render ( form , Login ya existente: escoge otro )); } if (! datosRegistro . password . equals ( datosRegistro . confirmacion )) { return badRequest ( formRegistro . render ( form , No coinciden la contrase\u00f1a y la confirmaci\u00f3n )); } Usuario usuario = usuarioService . creaUsuario ( datosRegistro . login , datosRegistro . email , datosRegistro . password ); return redirect ( controllers . routes . UsuarioController . formularioLogin ()); } public Result formularioLogin () { return ok ( formLogin . render ( formFactory . form ( Login . class ), )); } public Result loginUsuario () { Form Login form = formFactory . form ( Login . class ). bindFromRequest (); if ( form . hasErrors ()) { return badRequest ( formLogin . render ( form , Hay errores en el formulario )); } Login login = form . get (); Usuario usuario = usuarioService . login ( login . username , login . password ); if ( usuario == null ) { return notFound ( formLogin . render ( form , Login y contrase\u00f1a no existentes )); } else { // A\u00f1adimos el id del usuario a la clave `connected` de // la sesi\u00f3n de Play // https://www.playframework.com/documentation/2.5.x/JavaSessionFlash // Esa clave es la usada en la autenticaci\u00f3n session ( connected , usuario . getId (). toString ()); return redirect ( controllers . routes . TareasController . listaTareas ( usuario . getId ())); } } // Comprobamos si hay alguien logeado con @Security.Authenticated(ActionAuthenticator.class) // https://alexgaribay.com/2014/06/15/authentication-in-play-framework-using-java/ @Security.Authenticated ( ActionAuthenticator . class ) public Result logout () { session (). remove ( connected ); return redirect ( controllers . routes . UsuarioController . loginUsuario ()); } @Security.Authenticated ( ActionAuthenticator . class ) public Result detalleUsuario ( Long id ) { String connectedUserStr = session ( connected ); Long connectedUser = Long . valueOf ( connectedUserStr ); if ( connectedUser != id ) { return unauthorized ( Lo siento, no est\u00e1s autorizado ); } else { Usuario usuario = usuarioService . findUsuarioPorId ( id ); if ( usuario == null ) { return notFound ( Usuario no encontrado ); } else { Logger . debug ( Encontrado usuario + usuario . getId () + : + usuario . getLogin ()); return ok ( detalleUsuario . render ( usuario )); } } } } Para mapear los datos de los formularios se usan las clases Login y Registro . Fichero controllers/Login.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package controllers ; import play.data.validation.Constraints ; public class Login { @Constraints.Required public String username ; @Constraints.Required public String password ; public String getUsername () { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } } Fichero controllers/Registro.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package controllers ; import play.data.validation.Constraints ; public class Registro { @Constraints.Required public String login ; @Constraints.Required @Constraints.Email public String email ; @Constraints.Required public String password ; @Constraints.Required public String confirmacion ; public String getLogin () { return login ; } public void setLogin ( String login ) { this . login = login ; } public String getEmail () { return email ; } public void setEmail ( String email ) { this . email = email ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getConfirmacion () { return confirmacion ; } public void setConfirmacion ( String confirmacion ) { this . confirmacion = confirmacion ; } } Vistas Todas las vistas de la aplicaci\u00f3n usan como plantilla base la vista main.scala.html , en la que se carga el framework CSS Bootstrap y la librer\u00eda JavaScript JQuery . Ambos se encuentran en el directorio public , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Play. Es importante hacer notar que se obtiene la ruta absoluta a los ficheros est\u00e1ticos llamando a routes.Assets.versioned con su ruta relativa. De esta forma se modificar el directorio por defecto en el que se guardan los recursos est\u00e1ticos sin afectar a la aplicaci\u00f3n. A la plantilla main se le pasa el t\u00edtulo de la p\u00e1gina, scripts JavaScript (por defecto vac\u00edo) y un contenido HTML que se inserta en el cuerpo principal. Fichero views/main.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @* * This template is called from the `index` template. This template * handles the rendering of the page header and body tags. It takes * two arguments, a `String` for the title of the page and an `Html` * object to insert into the body of the page. *@ @(title: String, scripts: Html = Html( ))(content: Html) !DOCTYPE html html lang = en head @* Here s where we render the page title `String`. *@ title @title / title link href = @routes.Assets.versioned( bootstrap / css / bootstrap . min . css ) rel = stylesheet media = screen link rel = stylesheet media = screen href = @routes.Assets.versioned( stylesheets / main . css ) link rel = shortcut icon type = image/png href = @routes.Assets.versioned( images / favicon . png ) script src = @routes.Assets.versioned( javascripts / hello . js ) type = text/javascript / script / head body div class = container @content / div script src = @routes.Assets.versioned( javascripts / jquery . min . js ) type = text/javascript / script script src = @routes.Assets.versioned( bootstrap / js / bootstrap . min . js ) type = text/javascript / script @scripts / body / html Un ejemplo del uso de esta plantilla es la plantilla principal del listado de tareas. Se trata de una plantilla compleja, con bastantes ejemplos de c\u00f3mo usar los distintos elementos de Play: La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n for para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se usan enlaces a las URLs definidas por rutas inversas. Fichero views/listaTareas.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @(tareas: List[Tarea], usuario: Usuario, mensaje: String) @scripts = { script type = text/javascript function del ( urlBorrar ) { $ . ajax ({ url : urlBorrar , type : DELETE , success : function ( results ) { //refresh the page location . reload (); } }); } / script } @main( Tareas del usuario @usuario.getLogin() , scripts) { h2 Listado de tareas de @usuario.getLogin() / h2 table class = table table-striped tr th Tareas / th th Acci\u00f3n / th / tr @for(tarea - tareas ) { tr td @tarea.getTitulo() / td td a href = @routes.TareasController.formularioEditaTarea(tarea.getId()) span class = glyphicon glyphicon-pencil / span nbsp; / a a onmouseover = style = cursor: pointer; onclick = del( @routes.TareasController.borraTarea(tarea.getId()) ) span class = glyphicon glyphicon-trash aria-hidden = true / span / a / td / tr } tr td a href = @routes.TareasController.formularioNuevaTarea(usuario.getId()) span class = glyphicon glyphicon-plus / / a / td td a href = @routes.UsuarioController.logout() Salir / a / td / tr / table @if(mensaje != null) { div class = alert alert-success role = alert button type = button class = close data-dismiss = alert aria-label = Close span aria-hidden = true times; / span / button @mensaje / div } } Tests La mayor\u00eda de los tests que contiene la aplicaci\u00f3n son tests de integraci\u00f3n, en los que no se usan mocks , sino que se comprueba el funcionamiento de la capa de servicio y la de repositorio. Como framework de testing se usa JUnit . Los datos de prueba en las tablas de la base de datos se definen y se cargan usando DBUnit . Por ejemplo, la clase models.EquipoTest contiene tests para el modelo Equipo y el EquipoRepository . Los tests se realizar\u00e1n utilizando la base de datos definida en el fichero de configuraci\u00f3n. En el fichero de configuraci\u00f3n por defecto ( conf/application.conf ) se define la base de datos de memoria H2 . Tests con la base de datos de memoria H2 Ejemplo de ejecuci\u00f3n de los tests sobre la base de datos de memoria: 1 2 3 4 5 6 $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework [mads-todolist-inicial] $ test .. [info] Test run finished: 0 failed, 0 ignored, 5 total, 1.753s [info] Passed: Total 36, Failed 0, Errors 0, Passed 36 [success] Total time: 51 s, completed Aug 21, 2018 10:56:42 AM Podemos lanzar una clase de test en concreto: 1 2 3 4 5 [mads-todolist-inicial] $ testOnly models.EquipoTest ... [info] Test run finished: 0 failed, 0 ignored, 6 total, 11.377s [info] Passed: Total 6, Failed 0, Errors 0, Passed 6 [success] Total time: 38 s, completed Aug 22, 2018 7:41:09 AM Tests con la base de datos MySQL La otra configuraci\u00f3n que vamos a usar en los tests es conf/develop-mysql.conf , en la que se utiliza una base de datos MySQL. Como ya vimos anteriormente, para utilizar esta configuraci\u00f3n hay que lanzar el servicio de MySQL usando docker y definir en la ejecuci\u00f3n del contenedor de Play las variables de entorno DB_URL , DB_USER_NAME y DB_USER_PASSWD con los datos correctos para acceder a la base de datos MySQL. 1 2 3 4 5 6 7 8 9 $ docker run -d --rm -p 3306:3306 --name play-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql $ docker run --link play-mysql --rm -it -p 9000:9000 -e \\ DB_URL= jdbc:mysql://play-mysql:3306/mads -e DB_USER_NAME= root -e \\ DB_USER_PASSWD= mads -v ${PWD}:/code domingogallardo/playframework [mads-todolist-inicial] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-inicial] $ test ... [success] Total time: 44 s, completed Aug 22, 2018 7:48:32 AM [mads-todolist-inicial] $ Ejemplos de tests de la aplicaci\u00f3n En la aplicaci\u00f3n se definen tests sobre los modelos (clases entidad y clases repositorio) y sobre los servicios. Como hemos mencionado antes se tratan de unos tests de integraci\u00f3n que se prueban directamente sobre la base de datos activa en el fichero de configuraci\u00f3n. Aunque Play proporciona facilidades para el uso de mocks no los hemos utilizado por simplificar la realizaci\u00f3n de los tests. Se utiliza DBUnit para rellenar las tablas con los datos de pruebas. El m\u00e9todo initData() limpia las tablas e inicializa estos datos con los existentes en test/resources/test_dataset.xml comienzo de la ejecuci\u00f3n de cada test. DBUnit rellena las tablas f\u00edsicas de la base de datos, no usa JPA. Hay que utilizar los nombres de las tablas y de las columnas de la propia base de datos, no los de las entidades JPA. Hay que incluir en el fichero de dataset todas las tablas de la aplicaci\u00f3n, incluyendo las tablas auxiliares de las relaciones muchos-a-muchos, para que se vac\u00eden de datos (por ejemplo, la tabla Equipo_Usuario ). Por \u00faltimo, se debe tener cuidado con las claves ajenas. No es posible borrar una tabla si hay claves ajenas que referencian a algunos de sus elementos. Para esto hay que considerar que DBUnit inserta los datos de arriba a abajo y los borra de abajo a arriba. Fichero test/resources/test_dataset.xml : 1 2 3 4 5 6 7 8 9 10 11 12 ?xml version= 1.0 encoding= UTF-8 ? dataset Usuario id= 1000 login= juangutierrez nombre= Juan apellidos= Gutierrez password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / Usuario id= 1005 login= anagarcia nombre= Ana apellidos= Garcia password= 123456789 eMail= ana.garcia@gmail.com fechaNacimiento= 1993-02-08 / Tarea id= 1001 titulo= Renovar DNI usuarioId= 1000 / Tarea id= 1002 titulo= Pr\u00e1ctica 1 MADS usuarioId= 1000 / Equipo id= 1003 nombre= Equipo A / Equipo id= 1004 nombre= Equipo B / Equipo_Usuario/ /dataset En cuanto a los tests propiamente dichos hay que resaltar algunos puntos. Los objetos definidos con inyecci\u00f3n de dependencias (la anotaci\u00f3n @Inject ) se instancian mediante el Injector de la aplicaci\u00f3n Play. La aplicaci\u00f3n se construye leyendo el fichero de configuraci\u00f3n por defecto (se puede modificar con la variable config.file de las opciones Java al lanzar el test). De esta forma los objetos instanciados utilizar\u00e1n la fuente de datos definida en la configuraci\u00f3n de la aplicaci\u00f3n (H2 o MySQL). Los tests sobre los modelos contienen pruebas sobre las entidades (por ejemplo, se comprueba el m\u00e9todo equal con entidades con y sin identificador) y sobre el repositorio del modelo, en los que se comprueba que las operaciones sobre la base de datos funcionan correctamente. Los tests sobre los servicios contienen pruebas sobre los m\u00e9todos de negocio de la clase servicio, incluyendo comprobaciones de que se lanzan excepciones si hay alg\u00fan error. Fichero test/Models/EquipoTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 package models ; public class EquipoTest { static Database db ; static private Injector injector ; // Se ejecuta s\u00f3lo una vez, al principio de todos los tests @BeforeClass static public void initApplication () { // Creamos la aplicaci\u00f3n a partir del fichero de configuraci\u00f3n. // El fichero de configuraci\u00f3n se puede cambiar en el comando // para lanzar sbt y los tests: // sbt ; set javaOptions += -Dconfig.file=conf/develop-mysql.conf ; testOnly models.EquipoTest GuiceApplicationBuilder guiceApplicationBuilder = new GuiceApplicationBuilder (). in ( Environment . simple ()); injector = guiceApplicationBuilder . injector (); // Obtenemos la base de datos utilizada por la aplicaci\u00f3n db = injector . instanceOf ( Database . class ); // Necesario para inicializar JPA injector . instanceOf ( JPAApi . class ); } @Before public void initData () throws Exception { // Creamos la base de datos de test y le asignamos el nombre JNDI DBTodoList JndiDatabaseTester databaseTester = new JndiDatabaseTester ( DBTodoList ); IDataSet initialDataSet = new FlatXmlDataSetBuilder (). build ( new FileInputStream ( test/resources/test_dataset.xml )); databaseTester . setDataSet ( initialDataSet ); databaseTester . setSetUpOperation ( DatabaseOperation . CLEAN_INSERT ); databaseTester . onSetup (); } @Test public void testEqualsEquiposConId () { Equipo equipo1 = new Equipo ( Equipo A ); Equipo equipo2 = new Equipo ( Equipo B ); Equipo equipo3 = new Equipo ( Equipo C ); equipo1 . setId ( 1L ); equipo2 . setId ( 1L ); equipo3 . setId ( 2L ); assertEquals ( equipo1 , equipo2 ); assertNotEquals ( equipo1 , equipo3 ); } @Test public void testEqualsEquiposSinId () { Equipo equipo1 = new Equipo ( Equipo A ); Equipo equipo2 = new Equipo ( Equipo A ); Equipo equipo3 = new Equipo ( Equipo B ); assertEquals ( equipo1 , equipo2 ); assertNotEquals ( equipo1 , equipo3 ); } @Test public void testAddEquipoJPARepositoryInsertsEquipoDatabase () { EquipoRepository equipoRepository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = new Equipo ( Equipo A ); equipo = equipoRepository . add ( equipo ); Logger . info ( N\u00famero de tarea: + Long . toString ( equipo . getId ())); assertNotNull ( equipo . getId ()); assertEquals ( Equipo A , getNombreFromEquipoDB ( equipo . getId ())); } private String getNombreFromEquipoDB ( Long equipoId ) { String titulo = db . withConnection ( connection - { String selectStatement = SELECT NOMBRE FROM Equipo WHERE ID = ? ; PreparedStatement prepStmt = connection . prepareStatement ( selectStatement ); prepStmt . setLong ( 1 , equipoId ); ResultSet rs = prepStmt . executeQuery (); rs . next (); return rs . getString ( NOMBRE ); }); return titulo ; } @Test public void testFindEquipoPorId () { EquipoRepository repository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = repository . findById ( 1003L ); assertEquals ( Equipo A , equipo . getNombre ()); } @Test public void testUpdateEquipo () { EquipoRepository repository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = new Equipo ( Equipo B ); equipo . setId ( 1003L ); repository . update ( equipo ); Equipo equipoActualizado = repository . findById ( 1003L ); assertEquals ( Equipo B , equipo . getNombre ()); } @Test public void testDeleteEquipo () { EquipoRepository repository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = repository . findById ( 1003L ); repository . delete ( equipo ); equipo = repository . findById ( 1003L ); assertNull ( equipo ); } } Fichero test/services/EquipoService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package services ; public class EquipoServiceTest { static private Injector injector ; @BeforeClass static public void initApplication () { GuiceApplicationBuilder guiceApplicationBuilder = new GuiceApplicationBuilder (). in ( Environment . simple ()); injector = guiceApplicationBuilder . injector (); injector . instanceOf ( JPAApi . class ); } @Before public void initData () throws Exception { JndiDatabaseTester databaseTester = new JndiDatabaseTester ( DBTodoList ); IDataSet initialDataSet = new FlatXmlDataSetBuilder (). build ( new FileInputStream ( test/resources/test_dataset.xml )); databaseTester . setDataSet ( initialDataSet ); databaseTester . setSetUpOperation ( DatabaseOperation . CLEAN_INSERT ); databaseTester . onSetup (); } @Test ( expected = EquipoServiceException . class ) public void addEquipoNombreRepetido () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); equipoService . addEquipo ( Equipo A ); } @Test public void listaEquipos () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); List Equipo equipos = equipoService . allEquipos (); assertEquals ( 2 , equipos . size ()); } @Test public void addUsuarioEquipo () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); UsuarioService usuarioService = injector . instanceOf ( UsuarioService . class ); equipoService . addUsuarioEquipo ( juangutierrez , Equipo A ); Usuario usuario = usuarioService . findUsuarioPorLogin ( juangutierrez ); List Equipo equipos = new ArrayList ( usuario . getEquipos ()); assertEquals ( 1 , equipos . size ()); assertEquals ( Equipo A , equipos . get ( 0 ). getNombre ()); } @Test public void getUsuariosEquipo () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); UsuarioService usuarioService = injector . instanceOf ( UsuarioService . class ); equipoService . addUsuarioEquipo ( juangutierrez , Equipo A ); equipoService . addUsuarioEquipo ( anagarcia , Equipo A ); List Usuario usuarios = equipoService . findUsuariosEquipo ( Equipo A ); assertEquals ( 2 , usuarios . size ()); Usuario usuario = usuarioService . findUsuarioPorLogin ( juangutierrez ); assertEquals ( 1 , usuario . getEquipos (). size ()); } @Test public void deleteUsuarioEquipo () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); UsuarioService usuarioService = injector . instanceOf ( UsuarioService . class ); equipoService . addUsuarioEquipo ( juangutierrez , Equipo A ); equipoService . addUsuarioEquipo ( anagarcia , Equipo A ); equipoService . deleteUsuarioEquipo ( juangutierrez , Equipo A ); List Usuario usuarios = equipoService . findUsuariosEquipo ( Equipo A ); assertEquals ( 1 , usuarios . size ()); Usuario usuario = usuarioService . findUsuarioPorLogin ( juangutierrez ); assertEquals ( 0 , usuario . getEquipos (). size ()); } } Tecnolog\u00edas usadas Play Framework Play Framework es un framework de desarrollo r\u00e1pido de aplicaciones web disponible en los lenguajes Java y Scala. Vamos a utilizar la versi\u00f3n Java. El framework proporciona un soporte de ejecuci\u00f3n que tiene como base el servidor Netty . Con este soporte es posible dise\u00f1ar y poner en marcha distintos tipos de aplicaciones: servicios HTTP, servicios HTTP as\u00edncronos basados en websockets, aplicaciones as\u00edncronas basadas en eventos, etc. Nosotros vamos a implementar una aplicaci\u00f3n tradicional que implementa un servicio HTTP. Vamos a utilizar la versi\u00f3n 2.5 en Java . Para entender el funcionamiento de esta primera pr\u00e1ctica es necesario consultar la siguiente documentaci\u00f3n del framework: Sobre el funcionamiento de Play: Using the Play console Anatomy of a Play application Sobre peticiones y respuestas HTTP: Actions, Controllers and Results HTTP routing Session and Flash scope Sobre plantillas: The template engine Common template use cases Sobre env\u00edo de datos de formularios: Handling form submission Rendering an element Sobre el acceso a base de datos y JPA Acceso a base de datos SQL Integrating with JPA Sobre la inyecci\u00f3n de dependencias Dependency Injection Sobre los tests en Play: Testing your application Sobre la configuraci\u00f3n de la aplicaci\u00f3n Play: Configuraci\u00f3n Java Persistence API (JPA) JPA es el API que utilizaremos para acceder a bases de datos y gestionar entidades persistentes usando un modelo ORM ( Object Relational Mapping ). Est\u00e1 integrado en Play, no es necesario instalar ninguna librer\u00eda adicional. JPA tambi\u00e9n es conocido por el nombre de una de sus implementaciones m\u00e1s populares, Hibernate. Es una tecnolog\u00eda muy usada y madura en el mundo Java. Permite gestionar la persistencia directamente con el modelo de objetos de la aplicaci\u00f3n (se denominan entidades ), independiz\u00e1ndola del modelo relacional basado en tablas y registros. La implementaci\u00f3n de JPA ObjectDB tiene unos tutoriales muy completos y accesibles: JPA Quick tour Entity classes Using JPA JPA Queries No es necesario estudiar todos los tutoriales. El objetivo de las pr\u00e1cticas no es aprender JPA, sino desarrollar de forma \u00e1gil una aplicaci\u00f3n. Vamos a utilizar lo m\u00e1s b\u00e1sico de JPA y en la mayor\u00eda de las ocasiones se va a proporcionar el c\u00f3digo necesario. Adem\u00e1s, en caso de duda, siempre podr\u00e1s realizar preguntas sobre c\u00f3mo implementar una determinada funcionalidad en el foro de Moodle. La implementaci\u00f3n de JPA que se utiliza en PlayFramework 2.5 es Hibernate 5.1.0.Final. Puedes encontrar toda la informaci\u00f3n sobre esta implementaci\u00f3n en la gu\u00eda de usuario: Hibernate ORM 5.1 User Guide Bootstrap Para hacer m\u00e1s atractivo el dise\u00f1o de las p\u00e1ginas HTML vamos a usuar el framework CSS Bootstrap . Es conveniente tener a mano su documentaci\u00f3n, en concreto la lista de componentes: Bootstrap components","title":"Intro a Play para MADS"},{"location":"01-introduccion-play/intro-play-teoria/#introduccion-a-play-framework-para-las-practicas-de-mads","text":"Vamos a ver c\u00f3mo lanzar y desarrollar una aplicaci\u00f3n Play Framework en Java. Presentaremos las principales caracter\u00edsticas de este framework de desarrollo de aplicaciones web mediante ejemplos concretos de c\u00f3digo que vamos a utilizar en las pr\u00e1cticas de la asignatura.","title":"Introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS"},{"location":"01-introduccion-play/intro-play-teoria/#aplicacion-play-proyecto-inicial","text":"","title":"Aplicaci\u00f3n play-proyecto-inicial"},{"location":"01-introduccion-play/intro-play-teoria/#descarga-de-la-aplicacion","text":"La aplicaci\u00f3n play-proyecto-inicial se encuentra en GitHub: https://github.com/domingogallardo/play-proyecto-inicial . Es un esqueleto de aplicaci\u00f3n Play con ejemplos b\u00e1sicos del funcionamiento del framework. Puedes descargarla usando el comando git clone : 1 $ git clone https://github.com/domingogallardo/play-proyecto-inicial.git Se crear\u00e1 el directorio play-proyecto-inicial en el que se habr\u00e1 descargado la aplicaci\u00f3n Play.","title":"Descarga de la aplicaci\u00f3n"},{"location":"01-introduccion-play/intro-play-teoria/#uso-de-intellij-para-trabajar-con-la-aplicacion-play","text":"Aunque es posible trabajar con editores como Visual Studio Code , vamos a explicar c\u00f3mo desarrollar las aplicaciones Play usando el IDE IntelliJ IDEA. Las aplicaciones Play se pueden escribir en Java y en Scala. Nosotros usaremos Java. Una parte importante de las librer\u00edas del framework est\u00e1n escritas en Scala, por lo que debe estar instalado el plugin de Scala en IntelliJ. Se debe importar el proyecto usando la opci\u00f3n sbt , la herramienta de build que usa Play. Sbt es una herramienta similar a Maven para Java, es la herramienta que se usa para construir proyectos Scala. El fichero de configuraci\u00f3n de un proyecto sbt es el fichero build.sbt situado en el directorio ra\u00edz. Para compilar los proyectos tambi\u00e9n es necesario tener instalado JDK. Nos aseguramos de que aparece en el panel de importaci\u00f3n. Si no, seleccionamos el directorio donde se encuentra la versi\u00f3n del JDK que vamos a utilizar. Es conveniente activar la auto-importaci\u00f3n del proyecto sbt. De esta forma, si IntelliJ detecta alg\u00fan cambio en la configuraci\u00f3n sbt realiza la importaci\u00f3n de forma autom\u00e1tica. Si se pincha en el icono de la esquina inferior izquierda de la ventana de IntelliJ podremos activar o desactivar la visualizaci\u00f3n de los nombres de los paneles en los bordes de la ventana. Es recomendable dejarlos visibles. Utilizaremos el panel Terminal para trabajar con sbt y con git . Es recomendable abrir dos tabs, uno para cada cosa.","title":"Uso de IntelliJ para trabajar con la aplicaci\u00f3n Play"},{"location":"01-introduccion-play/intro-play-teoria/#uso-de-visual-studio-code-para-trabajar-con-la-aplicacion-play","text":"Si no es posible utilizar un editor avanzado como IntelliJ es posible usar en su lugar Visual Studio Code . Abre la carpeta con el directorio del proyecto y abre un terminal con la opci\u00f3n Ver Terminal integrado . En ese terminal lanzaremos el comando Docker para trabajar con sbt . Puedes abrir otro terminal pulsando en el s\u00edmbolo + para trabajar con Git.","title":"Uso de Visual Studio Code para trabajar con la aplicaci\u00f3n Play"},{"location":"01-introduccion-play/intro-play-teoria/#lanzar-la-aplicacion-play","text":"Podemos ejecutar la aplicaci\u00f3n Play de tres formas. Utilizaremos las tres a lo largo de las pr\u00e1cticas. Usando una m\u00e1quina Docker. Usando el sbt shell que proporciona IntelliJ. Usando la configuraci\u00f3n de ejecuci\u00f3n de IntelliJ.","title":"Lanzar la aplicaci\u00f3n Play"},{"location":"01-introduccion-play/intro-play-teoria/#maquina-docker","text":"La m\u00e1quina docker domingogallardo/playframework contiene todo el software y librer\u00edas para ejecutar aplicaciones Play 2.5.18. La ventaja de utilizar la m\u00e1quina Docker es que Una vez descargada la m\u00e1quina ya no es necesario descargar librer\u00edas adicionales. Est\u00e1 instalada en los laboratorios de la EPS. Nos movemos al directorio de la aplicaci\u00f3n Play y desde el terminal lanzamos el comando docker run para ejecutar la m\u00e1quina sobre el directorio actual conectando el puerto 9000 en el mismo puerto de nuestra m\u00e1quina: 1 2 3 $ cd play-proyecto-inicial $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework [play-java] $ Aparecer\u00e1 el prompt de sbt con el nombre del proyecto. Podremos lanzar comandos de sbt como run o test . Haciendo run se ejecuta la aplicaci\u00f3n web. Por defecto el puerto al que hay que atacar es el 9000. Accediendo a la URL http://localhost:9000 pondremos en marcha la aplicaci\u00f3n. Haciendo test se lanzan los tests incluidos en la aplicaci\u00f3n. Con exit se sale del prompt de sbt y autom\u00e1ticamente se para el contenedor y se elimina el contenedor de Docker.","title":"M\u00e1quina Docker"},{"location":"01-introduccion-play/intro-play-teoria/#shell-sbt-de-intellij","text":"Tambi\u00e9n es posible arrancar el shell de sbt en un panel propio que proporciona IntelliJ. Cuando lo ejecutamos por primera vez se descargan todas las librer\u00edas necesarias.","title":"Shell sbt de IntelliJ"},{"location":"01-introduccion-play/intro-play-teoria/#configuracion-de-ejecucion-de-intellij","text":"Tambi\u00e9n podemos crear una configuraci\u00f3n de ejecuci\u00f3n de IntelliJ con la que podremos ejecutar y depurar los proyectos con la opci\u00f3n Run Edit Configurations.. . Una vez creada la configuraci\u00f3n podremos seleccionarla y realizar una ejecuci\u00f3n o una depuraci\u00f3n de la aplicaci\u00f3n pulsando los botones correspondientes en la parte superior de la ventana de IntelliJ.","title":"Configuraci\u00f3n de ejecuci\u00f3n de IntelliJ"},{"location":"01-introduccion-play/intro-play-teoria/#fichero-routes","text":"El routes , situado en el directorio conf , especifica el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Fichero conf/routes : 1 2 3 4 5 6 7 8 9 10 11 12 13 # Routes # This file defines all application routes (Higher priority routes first) # ~~~~ # An example controller showing a sample home page GET / controllers.HomeController.index # An example controller showing how to use dependency injection GET /count controllers.CountController.count # An example controller showing how to write asynchronous code GET /message controllers.AsyncController.message # Map static resources from the /public folder to the /assets URL path GET /assets/*file controllers.Assets.versioned(path= /public , file: Asset) Por ejemplo, cuando se recibe la petici\u00f3n GET / (cuando en el navegador escribimos la URL http::/localhost/ ) se ejecutar\u00e1 el m\u00e9todo index de la clase controllers.HomeController . O cuando desde el navegador accedamos a la URL http://localhost/count se generar\u00e1 la petici\u00f3n GET /count y se ejecutar\u00e1 el m\u00e9todo count de la clase controllers.CountController .","title":"Fichero routes"},{"location":"01-introduccion-play/intro-play-teoria/#controllers","text":"El c\u00f3digo a ejecutar cuando se realiza una petici\u00f3n HTTP se define en m\u00e9todos de clases que heredan de Controller . Se suelen colocar en el paquete controllers . Por ejemplo, en la clase controllers.HomeController se define el m\u00e9todo index . Fichero app/controllers/HomeController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 public class HomeController extends Controller { /** * An action that renders an HTML page with a welcome message. * The configuration in the code routes /code file means that * this method will be called when the application receives a * code GET /code request with a path of code / /code . */ public Result index () { return ok ( index . render ( Your new application is ready. )); } } Los m\u00e9todos de las clases Controller deben devolver un objeto Result que representa la respuesta HTTP a la petici\u00f3n. En el caso anterior se devuelve un OK (c\u00f3digo HTTP 200) junto con el c\u00f3digo HTML resultante de renderizar la vista index .","title":"Controllers"},{"location":"01-introduccion-play/intro-play-teoria/#vistas","text":"Las p\u00e1ginas HTML que se devuelven se construyen mediante vistas . Las vistas se definen mediante plantillas Scala definidas en el directorio views . En la llamada a renderizar la vista se pueden pasar par\u00e1metros cuyos valores se utilizan en la propia vista. Por ejemplo, la vista anterior index se define en el fichero index.scala.html situado en el directorio views . Fichero views/index.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @* * This template takes a single argument, a String containing a * message to display. *@ @(message: String) @* * Call the `main` template with two arguments. The first * argument is a `String` with the title of the page, the second * argument is an `Html` object containing the body of the page. *@ @main( Welcome to Play ) { @* * Get an `Html` object by calling the built-in Play welcome * template and passing a `String` message. *@ @welcome(message, style = java ) } La vista recibe un par\u00e1metro String . En el cuerpo de la vista se puede escribir c\u00f3digo HTML, c\u00f3digo Scala, y tambi\u00e9n llamar a otras plantillas. Por ejemplo, en la vista anterior se llama a la plantilla main que se define en el fichero main.scala.html , pas\u00e1ndole como par\u00e1metro el c\u00f3digo HTML generado por la plantilla welcome , definida en el fichero welcome.scala.html . Fichero views/main.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @* * This template is called from the `index` template. This template * handles the rendering of the page header and body tags. It takes * two arguments, a `String` for the title of the page and an `Html` * object to insert into the body of the page. *@ @(title: String)(content: Html) !DOCTYPE html html lang = en head @* Here s where we render the page title `String`. *@ title @title / title link rel = stylesheet media = screen href = @routes.Assets.versioned( stylesheets / main . css ) link rel = shortcut icon type = image/png href = @routes.Assets.versioned( images / favicon . png ) script src = @routes.Assets.versioned( javascripts / hello . js ) type = text/javascript / script / head body @* And here s where we render the `Html` object containing * the page content. *@ @content / body / html Fichero views/welcome.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @(message: String, style: String = java ) @defining(play.core.PlayVersion.current) { version = link rel = stylesheet media = screen href = /@@documentation/resources/style/main.css section id = top div class = wrapper h1 a href = https://playframework.com/documentation/@version/Home @message / a / h1 / div / section div id = content class = wrapper doc article h1 Welcome to Play / h1 p Congratulations, you\u2019ve just created a new Play application. This page will help you with the next few steps. / p blockquote p You\u2019re using Play @version / p / blockquote ... } Para incorporar el valor del par\u00e1metro en la plantilla hay que preceder el par\u00e1metro con @ . En el ejemplo anterior se obtiene as\u00ed el mensaje, que se pinta en la parte superior de la p\u00e1gina. La p\u00e1gina HTML resultante mostrada en el navegador es la siguiente: La directiva @defining permite obtener un valor y asign\u00e1rselo a una variable que se utiliza en un bloque de c\u00f3digo. En el caso anterior se utiliza para obtener la versi\u00f3n de Play. Otro ejemplo de su utilizaci\u00f3n es el que aparece en la documentaci\u00f3n de Play sobre plantillas: 1 2 3 @defining(user.getFirstName() + + user.getLastName()) { fullName = div Hello @fullName / div }","title":"Vistas"},{"location":"01-introduccion-play/intro-play-teoria/#inyeccion-de-dependencias","text":"Play usa el framework Java de Google Guice para realizar inyecci\u00f3n de dependencias. La anotaci\u00f3n @Inject hace que Play inyecte en la variable anotada un objeto nuevo del tipo indicado por la variable. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. Es posible definir singletons con la anotaci\u00f3n @Singleton . En la aplicaci\u00f3n ejemplo se define un servicio y un controller para implementar un contador que se incrementa en cada petici\u00f3n a la acci\u00f3n count . En el controller se inyecta el componente counter : Fichero controllers/CountController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package controllers ; import javax.inject.* ; import play.mvc.* ; import services.Counter ; @Singleton public class CountController extends Controller { private final Counter counter ; @Inject public CountController ( Counter counter ) { this . counter = counter ; } /** * An action that responds with the {@link Counter} s current * count. The result is plain text. This action is mapped to * code GET /code requests with a path of code /count /code * requests by an entry in the code routes /code config file. */ public Result count () { return ok ( Integer . toString ( counter . nextCount ())); } } El contador se define con una interfaz y una implementaci\u00f3n concreta. Fichero services/Counter.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 package services ; /** * This interface demonstrates how to create a component that is injected * into a controller. The interface represents a counter that returns a * incremented number each time it is called. * * The {@link Modules} class binds this interface to the * {@link AtomicCounter} implementation. */ public interface Counter { int nextCount (); } Fichero services/AtomicCounter.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package services ; import java.util.concurrent.atomic.AtomicInteger ; import javax.inject.* ; /** * This class is a concrete implementation of the {@link Counter} trait. * It is configured for Guice dependency injection in the {@link Module} * class. * * This class has a {@link Singleton} annotation because we need to make * sure we only use one counter per application. Without this * annotation we would get a new instance every time a {@link Counter} is * injected. */ @Singleton public class AtomicCounter implements Counter { private final AtomicInteger atomicCounter = new AtomicInteger (); @Override public int nextCount () { return atomicCounter . getAndIncrement (); } } La definici\u00f3n de la clase concreta que se inyecta se realiza en el m\u00e9todo configure() de una clase llamada Module que debe extender AbstractModule y estar situada en el paquete ra\u00edz. Fichero Module.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import com.google.inject.AbstractModule ; import services.AtomicCounter ; import services.Counter ; /** * This class is a Guice module that tells Guice how to bind several * different types. This Guice module is created when the Play * application starts. * * Play will automatically use any class called `Module` that is in * the root package. You can create modules in other locations by * adding `play.modules.enabled` settings to the `application.conf` * configuration file. */ public class Module extends AbstractModule { @Override public void configure () { // Set AtomicCounter as the implementation for Counter. bind ( Counter . class ). to ( AtomicCounter . class ); } }","title":"Inyecci\u00f3n de dependencias"},{"location":"01-introduccion-play/intro-play-teoria/#tests","text":"Los tests se encuentran en el directorio tests . Se utiliza JUnit como framework de testing. Desde los tests se puede comprobar los distintos componentes de la aplicaci\u00f3n, incluyendo plantillas y peticiones a controllers.","title":"Tests"},{"location":"01-introduccion-play/intro-play-teoria/#lanzamiento-de-los-tests-desde-sbt","text":"Para lanzar los tests desde la consola sbt se debe usar el comando test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [play-java] $ test [info] Updating {file:/code/}root... [info] Resolving jline#jline;2.14.3 ... [info] Done updating. [info] Test run started [info] Test ApplicationTest.simpleCheck started [info] Test ApplicationTest.renderTemplate started [info] Test run finished: 0 failed, 0 ignored, 2 total, 1.337s [info] Test run started [info] Test IntegrationTest.test started [info] application - Creating Pool for datasource default [info] application - ApplicationTimer demo: Starting application at 2018-08-21T07:41:46.226Z [info] application - ApplicationTimer demo: Stopping application at 2018-08-21T07:41:52.807Z after 6s. [info] application - Shutting down connection pool. [info] Test run finished: 0 failed, 0 ignored, 1 total, 9.704s [info] Passed: Total 3, Failed 0, Errors 0, Passed 3 [success] Total time: 37 s, completed Aug 21, 2018 7:41:53 AM Podemos lanzar una parte de los tests con el comando testOnly seguido del nombre completo de la clase (incluyendo el paquete en el que est\u00e9 incluida): 1 2 3 4 5 6 7 8 [play-java] $ testOnly ApplicationTest [info] Test run started [info] Test ApplicationTest.simpleCheck started [info] Test ApplicationTest.renderTemplate started [info] Test run finished: 0 failed, 0 ignored, 2 total, 1.405s [info] Passed: Total 2, Failed 0, Errors 0, Passed 2 [success] Total time: 12 s, completed Aug 21, 2018 9:58:57 AM [play-java] $","title":"Lanzamiento de los tests desde sbt"},{"location":"01-introduccion-play/intro-play-teoria/#lanzamiento-de-los-tests-de-intellij","text":"Tambi\u00e9n es posible lanzar los tests desde el entorno IntelliJ pulsando con el bot\u00f3n derecho la opci\u00f3n Run sobre la clase de test seleccionada.","title":"Lanzamiento de los tests de IntelliJ"},{"location":"01-introduccion-play/intro-play-teoria/#aplicacion-mads-todolist-inicial","text":"La aplicaci\u00f3n mads-todolist-inicial es una versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante todo el cuatrimestre en la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista anteriormente. Entre otros, tiene los siguientes elementos: Distintos comandos HTTP en el fichero de rutas: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban sobre todo la capa de servicios. Distintos ficheros de configuraci\u00f3n para poder arrancar la aplicaci\u00f3n en distintos entornos: desarrollo, integraci\u00f3n y stage (similar a producci\u00f3n). A continuaci\u00f3n se muestran dos de sus pantallas. Pantalla de login Pantalla con listado de tareas","title":"Aplicaci\u00f3n mads-todolist-inicial"},{"location":"01-introduccion-play/intro-play-teoria/#descarga-de-la-aplicacion-mads-todolist-inicial","text":"Se encuentra en GitHub: https://github.com/domingogallardo/mads-todolist-inicial . Puedes descargarla con el comando git clone : 1 $ git clone https://github.com/domingogallardo/mads-todolist-inicial.git Se crear\u00e1 el directorio mads-todolist-inicial en el que se habr\u00e1 descargado la aplicaci\u00f3n.","title":"Descarga de la aplicaci\u00f3n mads-todolist-inicial"},{"location":"01-introduccion-play/intro-play-teoria/#importacion-en-intellj-idea","text":"Al importar la aplicaci\u00f3n en IntelliJ IDEA aparece el aviso de que se ha detectado el framework JPA y da la opci\u00f3n de configurarlo. La configuraci\u00f3n es sencilla, s\u00f3lo hay que aceptar la localizaci\u00f3n del fichero persistence.xml que nos muestra la ventana de di\u00e1logo. Hablaremos m\u00e1s adelante de JPA.","title":"Importaci\u00f3n en IntellJ IDEA"},{"location":"01-introduccion-play/intro-play-teoria/#ejecucion-de-la-aplicacion-usando-la-base-de-datos-en-memoria","text":"Si ejecutamos la aplicaci\u00f3n usando el comando docker run ya visto se utilizar\u00e1 la base de datos H2 en memoria. Los datos almacenados en ella s\u00f3lo durar\u00e1n mientras que est\u00e1 en marcha el contenedor. 1 $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework","title":"Ejecuci\u00f3n de la aplicaci\u00f3n usando la base de datos en memoria"},{"location":"01-introduccion-play/intro-play-teoria/#base-de-datos-mysql-con-docker","text":"Si queremos que los datos introducidos persistan a distintas activaciones de la aplicaci\u00f3n web debemos usar una base de datos externa. Esto es necesario cuando la aplicaci\u00f3n est\u00e9 en producci\u00f3n, pero tambi\u00e9n puede ser \u00fatil para realizar pruebas manuales en desarrollo. Podemos utilizar Docker para poner en marcha un servidor MySQL con el siguiente comando: 1 $ docker run -d -p 3316:3306 --name play-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql:5 El comando pone en marcha un servidor MySQL escuchando en el puerto 3316 del host con el nombre docker play-mysql , con la contrase\u00f1a de root indicada y creando la base de datos mads . El puerto del host 3316 se mapea con el puerto interno del contenedor 3306. Ponemos el puerto 3316 para evitar posibles conflictos con un posible servidor de MySQL que tengamos funcionando en el host. Importante En los laboratorios de la EPS est\u00e1 instalada la imagen 5.7.18 de MySQL. Hay que definir expl\u00edcitamente esa versi\u00f3n en el comando docker, escribiendo mysql:5.7.18 . Podemos comprobar que el contenedor est\u00e1 funcionando con el comando docker container ls : 1 2 3 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7c1bed0b5b7e mysql docker-entrypoint... 6 seconds ago Up 4 seconds 0.0.0.0:3316- 3306/tcp play-mysql Para parar y volver a poner en marcha el contenedor mysql puedes usar los comandos docker stop container-id y docker start container-id . Los datos a\u00f1adidos en la base de datos se mantendr\u00e1n mientras que el contenedor no se borre. El comando docker container ls lista los contenedores en marcha, y con la opci\u00f3n -a tambi\u00e9n los parados. 1 2 3 4 5 6 7 8 9 10 11 $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 30 minutes ago Up 22 minutes 33060/tcp, 0.0.0.0:3316- 3306/tcp play-mysql $ docker container stop bd057639b6ac $ docker container ls -a CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 31 minutes ago Exited (0) 7 seconds ago play-mysql $ docker container start bd057639b6ac $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 32 minutes ago Up 5 seconds 33060/tcp, 0.0.0.0:3316- 3306/tcp play-mysql Podemos usar el identificador o el nombre del contenedor para pararlo: 1 $ docker container stop play-mysql Para borrar un contenedor debe estar parado y debemos usar el comando docker container rm container-id .","title":"Base de datos MySQL con Docker"},{"location":"01-introduccion-play/intro-play-teoria/#ejecucion-de-la-aplicacion-usando-la-base-de-datos-mysql","text":"","title":"Ejecuci\u00f3n de la aplicaci\u00f3n usando la base de datos MySQL"},{"location":"01-introduccion-play/intro-play-teoria/#desde-docker","text":"Lanzamos la aplicaci\u00f3n con Docker, definiendo en variables de entorno la URL, el usuario y la contrase\u00f1a con la que debe conectarse la aplicaci\u00f3n a la base de datos. Usamos la opci\u00f3n link de docker para definir el nombre l\u00f3gico del contenedor al que debe conectarse la aplicaci\u00f3n. 1 2 3 $ docker run --link play-mysql --rm -it -p 9000:9000 -e \\ DB_URL= jdbc:mysql://play-mysql:3306/mads -e DB_USER_NAME= root -e \\ DB_USER_PASSWD= mads -v ${PWD}:/code domingogallardo/playframework Y desde la consola sbt modificamos la preferencia config.file para que la aplicaci\u00f3n utilice la configuraci\u00f3n definida en el fichero conf/develop-mysql.conf (lo explicamos m\u00e1s adelante). 1 2 [mads-todolist-2018] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-2018] $ run","title":"Desde Docker"},{"location":"01-introduccion-play/intro-play-teoria/#desde-el-rundebug-de-intellij","text":"Tambi\u00e9n es posible definir una configuraci\u00f3n de run/debug en IntelliJ en la que se inicialice la preferencia config.file y las variables de entorno para conectarse con la base de datos, en el puerto del host en el que est\u00e1 escuchando (3331, si hemos lanzado el servicio de base de datos usando Docker como hemos visto anteriormente): Cuidado : Si est\u00e1s lanzando MySQL usando Docker Toolbox debes modificar la DB_URL indicando el host al que conectarse (no ser\u00e1 localhost ). La direcci\u00f3n IP ser\u00e1 la que aparece en la consola de docker al arrancar. Por ejemplo jdbd:mysql://192.168.99.100/mads .","title":"Desde el run/debug de IntelliJ"},{"location":"01-introduccion-play/intro-play-teoria/#panel-database-de-intellij","text":"Desde el panel Database de IntelliJ (en la esquina superior derecha) es posible crear una conexi\u00f3n a la base de datos que nos permitir\u00e1 verificar c\u00f3mo se guardan los datos de la aplicaci\u00f3n. Hay que a\u00f1adir una base de datos de tipo MySQL y configurarla con los siguientes par\u00e1metros: Cuidado : Igual que en el apartado anterior, si est\u00e1s lanzando MySQL usando Docker Toolbox debes indicar el host al que conectarse (no ser\u00e1 localhost ) escribiendo la direcci\u00f3n IP que aparece en la consola de docker al arrancar. Es posible examinar el esquema de la base de datos: Y examinar tablas en concreto:","title":"Panel Database de IntelliJ"},{"location":"01-introduccion-play/intro-play-teoria/#configuracion-de-la-aplicacion","text":"Los distintos par\u00e1metros de la aplicaci\u00f3n Play se configuran en un fichero de propiedades.","title":"Configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"01-introduccion-play/intro-play-teoria/#configuracion-por-defecto","text":"El fichero de configuraci\u00f3n que carga la aplicaci\u00f3n por defecto es conf/application.conf . Por ejemplo, las propiedades relacionadas con la definici\u00f3n de la base de datos que se definen en el fichero son las siguientes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Default persistenceUnit for JPA jpa.default = develop db { # You can declare as many datasources as you want. # By convention, the default datasource is named `default` # https://www.playframework.com/documentation/latest/Developing-with-the-H2-Database # Memory H2 database default.driver = org.h2.Driver default.url = jdbc:h2:mem:play;MODE=MYSQL #default.username = sa #default.password = # Definiemos el nombre JNDI de la BD que va a usar la aplicaci\u00f3n default.jndiName=DBTodoList # You can turn on SQL logging for any datasource # https://www.playframework.com/documentation/latest/Highlights25#Logging-SQL-statements # default.logSql=true } En el fichero por defecto se define una conexi\u00f3n con la base de datos de memoria H2 en la fuente de datos llamada default (la fuente de datos que usa por defecto la aplicaci\u00f3n). Se definen las siguientes propiedades: jpa.default : Nombre de la unidad de persistencia JPA que se usar\u00e1 en la aplicaci\u00f3n. db.default.driver : Driver de la base de datos. db.default.url : URL de conexi\u00f3n a la base de datos. db.default.jndiName : Nombre l\u00f3gico JNDI que se asigna a la base de datos. db.default.logSql : Si se descomenta se mostrar\u00e1 en la consola el log de todas las operaciones sobre la base de datos.","title":"Configuraci\u00f3n por defecto"},{"location":"01-introduccion-play/intro-play-teoria/#otras-configuraciones","text":"Como ya hemos visto, modificando la propiedad del sistema Java config.file podemos definir un fichero de configuraci\u00f3n distinto. Se definen tambi\u00e9n los siguientes ficheros adicionales que se usar\u00e1n para lanzar la aplicaci\u00f3n en distintas configuraciones: develop-mysql.conf : configuraci\u00f3n de desarrollo con base de datos externa. La aplicaci\u00f3n trabaja sobre una base de datos MySQL externa cuyo esquema se actualiza autom\u00e1ticamente al modificar y a\u00f1adir nuevas entidades a la aplicaci\u00f3n. production.conf : configuraci\u00f3n de producci\u00f3n. La aplicaci\u00f3n trabaja sobre una base de datos MySQL externa, cuyo esquema es validado para que se corresponda con las entidades de la aplicaci\u00f3n. Fichero conf/develop-mysql.conf : 1 2 3 4 5 6 include application.conf db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Fichero conf/production.conf : 1 2 3 4 5 6 7 8 9 10 include application.conf play.crypto.secret= abcdefghijkl jpa.default = production db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Los dos ficheros de configuraci\u00f3n incluyen el fichero application.conf y despu\u00e9s modifican las propiedades necesarias. Los valores de los par\u00e1metros de configuraci\u00f3n de la base de datos url , username y password se obtienen de las variables de entorno.","title":"Otras configuraciones"},{"location":"01-introduccion-play/intro-play-teoria/#gestion-de-persistencia-con-jpa","text":"Para la gesti\u00f3n de la persistencia de los datos en una aplicaci\u00f3n Play usaremos JPA ( Java Persistence API ), en concreto la implementaci\u00f3n 5.2.5 de Hibernate.","title":"Gesti\u00f3n de persistencia con JPA"},{"location":"01-introduccion-play/intro-play-teoria/#definicion-del-modelo-de-datos","text":"El framework JPA permite definir el esquema de la base de datos usando anotaciones en las clases denominadas de entidad. Para cada clase de entidad se define una tabla en la base de datos, con columnas que se mapean con sus atributos. Por ejemplo, la clase Usuario define una tabla Usuario en la base de datos. Los distintos atributos ( login , email , ...) se corresponden con las columnas de la tabla. El atributo id se corresponde con la clave primaria de la tabla. JPA define varias estrategias para obtener esa clave primera, y se ha escogido la estrategia AUTO . Cuando un usuario creado en memoria se haga persistente en la base de datos, este atributo se actualizar\u00e1 con el valor obtenido por Hibernate. La estrategia AUTO se basa en obtener el valor de la clave primaria usando una tabla auxiliar hibernate_sequence que guarda el siguiente valor a asignar a una nueva clave primaria. Adem\u00e1s de los atributos, en la clase se define un constructor con los atributos obligatorios para definir un usuario, unos getters y setters y los m\u00e9todos equals y hashCode para comparar usuarios. Fichero models/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @Entity public class Usuario { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; private String login ; private String email ; private String password ; private String nombre ; private String apellidos ; @Temporal ( TemporalType . DATE ) private Date fechaNacimiento ; // Relaci\u00f3n uno-a-muchos entre usuario y tarea @OneToMany ( mappedBy = usuario , fetch = FetchType . EAGER ) private Set Tarea tareas = new HashSet (); @ManyToMany ( mappedBy = usuarios , fetch = FetchType . EAGER ) private Set Equipo equipos = new HashSet (); // Un constructor vac\u00edo necesario para JPA public Usuario () { } // El constructor principal con los campos obligatorios public Usuario ( String login , String email ) { this . login = login ; this . email = email ; } // Getters y setters necesarios para JPA ... // Funci\u00f3n para imprimr los datos de un usuario public String toString () { String fechaStr = null ; if ( fechaNacimiento != null ) { SimpleDateFormat formateador = new SimpleDateFormat ( dd-MM-yyyy ); fechaStr = formateador . format ( fechaNacimiento ); } return String . format ( Usuario id: %s login: %s password: %s nombre: %s + apellidos: %s e-mail: %s fechaNacimiento: %s , id , login , password , nombre , apellidos , email , fechaNacimiento ); } // Funciones hashCode y equals para poder comparar usuarios y // necesarias para poder crear un Set de usuarios @Override public int hashCode () { // Devolvemos el hash de los campos obligatorios return Objects . hash ( login , email ); } // Si el usuario tiene un ID (se ha obtenido de la BD) // la comparaci\u00f3n se basa en ese ID. Si el ID no existe (el usuario // se ha creado en memoria y todav\u00eda no se ha sincronizado con la BD) // la comparaci\u00f3n se basa en los atributos obligatorios. @Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( getClass () != obj . getClass ()) return false ; Usuario other = ( Usuario ) obj ; if ( id != null other . id != null ) { // Si tenemos los ID, comparamos por ID return ( id == other . id ); } // sino comparamos por campos obligatorios else { if ( login == null ) { if ( other . login != null ) return false ; } else if (! login . equals ( other . login )) return false ; if ( email == null ) { if ( other . email != null ) return false ; } else if (! email . equals ( other . email )) return false ; } return true ; } } En la definici\u00f3n de la entidad tambi\u00e9n se incluyen relaciones con otras entidades. En este caso un Usuario tiene muchas Tarea s (una relaci\u00f3n una-a-muchos) y puede participar en Equipo s (relaci\u00f3n muchos-a-muchos). La relaci\u00f3n uno-a-muchos se representa en la base de datos con una clave ajena. El atributo mappedBy indica que la clave ajena se va a guardar en la columna correspondiente con el atributo usuario de la entidad Tarea . La relaci\u00f3n muchos-a-muchos se representa en la base de datos con una tabla auxiliar con dos claves ajenas. El atributo mappedBy indica que la definici\u00f3n de esa tabla se encuentra en el atributo usuario de la entidad Equipo . Las definiciones de Tarea y Equipo son las siguientes: Fichero models/Tarea.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Entity public class Tarea { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; private String titulo ; // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = usuarioId ) public Usuario usuario ; public Tarea () { } // Constructor, getters y setters, equals y hashCode } Fichero models/Equipo.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Entity public class Equipo { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; private String nombre ; @ManyToMany @JoinTable ( name = Equipo_Usuario , joinColumns = { @JoinColumn ( name = fk_equipo ) }, inverseJoinColumns = { @JoinColumn ( name = fk_usuario )}) private Set Usuario usuarios = new HashSet (); // Un constructor vac\u00edo necesario para JPA public Equipo () { } // Constructor, getters y setters, equals y hashCode // M\u00e9todos de actualizaci\u00f3n de la relaci\u00f3n muchos-a-muchos con usuario public void addUsuario ( Usuario usuario ) { usuarios . add ( usuario ); usuario . getEquipos (). add ( this ); } public void removeUsuario ( Usuario usuario ) { usuarios . remove ( usuario ); usuario . getEquipos (). remove ( this ); } }","title":"Definici\u00f3n del modelo de datos"},{"location":"01-introduccion-play/intro-play-teoria/#actualizacion-de-los-datos","text":"Se definen clases repository que definen m\u00e9todos para actualizar las entidades y realizar queries sobre ellas. Para dejar abierta la posibilidad de cambiar la implementaci\u00f3n, se definen con interfaces. Fichero models/UsuarioRepository.java : 1 2 3 4 5 6 7 public interface UsuarioRepository { Usuario add ( Usuario usuario ); // Queries Usuario findById ( Long id ); Usuario findByLogin ( String login ); } Fichero models/TareaRepository.java : 1 2 3 4 5 6 7 8 public interface TareaRepository { Tarea add ( Tarea tarea ); Tarea update ( Tarea tarea ); void delete ( Tarea tarea ); // Queries Tarea findById ( Long idTarea ); } Fichero models/EquipoRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 public interface EquipoRepository { Equipo add ( Equipo equipo ); Equipo update ( Equipo equipo ); void delete ( Equipo equipo ); void addUsuarioEquipo ( Usuario usuario , Equipo equipo ); void deleteUsuarioEquipo ( Usuario usuario , Equipo equipo ); // Queries Equipo findById ( Long idEquipo ); Equipo findByNombre ( String nombre ); List Equipo findAll (); List Usuario findUsuariosEquipo ( String nombreEquipo ); } La implementaci\u00f3n utiliza JPA para realizar las actualizaciones y consultas sobre las entidades. Cada m\u00e9todo abre y cierra una transacci\u00f3n en la que se propaga el cambio a la base de datos. Para trabajar con JPA en Play se debe usar un objeto JPAApi que se obtiene por inyecci\u00f3n de dependencias. Play guarda en la variable jpaApi una instancia con la que podemos, entre otras cosas, abrir y cerrar transacciones. Por ejemplo, la implementaci\u00f3n de la parte de la interfaz EquipoRepository que trata de la actualizaci\u00f3n de la entidad en la base de datos es la siguiente: Fichero models/JPAEquipoRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public class JPAEquipoRepository implements EquipoRepository { JPAApi jpaApi ; @Inject public JPAEquipoRepository ( JPAApi api ) { this . jpaApi = api ; } @Override public Equipo add ( Equipo equipo ) { return jpaApi . withTransaction ( entityManager - { entityManager . persist ( equipo ); entityManager . flush (); entityManager . refresh ( equipo ); return equipo ; }); } @Override public Equipo update ( Equipo equipo ) { return jpaApi . withTransaction ( entityManager - { return entityManager . merge ( equipo ); }); } @Override public void delete ( Equipo equipo ) { jpaApi . withTransaction ( () - { EntityManager entityManager = jpaApi . em (); Equipo equipoBD = entityManager . getReference ( Equipo . class , equipo . getId ()); entityManager . remove ( equipoBD ); }); } @Override public void addUsuarioEquipo ( Usuario usuario , Equipo equipo ) { jpaApi . withTransaction ( () - { EntityManager entityManager = jpaApi . em (); Equipo equipoBD = entityManager . merge ( equipo ); Usuario usuarioBD = entityManager . merge ( usuario ); equipoBD . addUsuario ( usuarioBD ); }); } @Override public void deleteUsuarioEquipo ( Usuario usuario , Equipo equipo ) { jpaApi . withTransaction ( () - { EntityManager entityManager = jpaApi . em (); Equipo equipoBD = entityManager . merge ( equipo ); Usuario usuarioBD = entityManager . merge ( usuario ); equipoBD . removeUsuario ( usuarioBD ); }); } Todos los m\u00e9todos trabajan con un EntityManager , que es la clase de JPA que gestiona las actualizaciones y queries sobre la base de datos. Y las queries se implementan de la siguiente manera: Fichero models/JPAEquipoRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @Override public Equipo findById ( Long idEquipo ) { return jpaApi . withTransaction ( entityManager - { return entityManager . find ( Equipo . class , idEquipo ); }); } @Override public Equipo findByNombre ( String nombre ) { return jpaApi . withTransaction ( entityManager - { TypedQuery Equipo query = entityManager . createQuery ( select e from Equipo e where e.nombre = :nombre , Equipo . class ); try { Equipo equipo = query . setParameter ( nombre , nombre ). getSingleResult (); return equipo ; } catch ( NoResultException ex ) { return null ; } }); } @Override public List Equipo findAll () { return jpaApi . withTransaction ( entityManager - { TypedQuery Equipo query = entityManager . createQuery ( select e from Equipo e , Equipo . class ); return query . getResultList (); }); } public List Usuario findUsuariosEquipo ( String nombreEquipo ) { return jpaApi . withTransaction ( entityManager - { TypedQuery Usuario query = entityManager . createQuery ( select u from Usuario u join u.equipos e where e.nombre = :nombreEquipo , Usuario . class ); try { return query . setParameter ( nombreEquipo , nombreEquipo ). getResultList (); } catch ( NoResultException ex ) { return null ; } }); } }","title":"Actualizaci\u00f3n de los datos"},{"location":"01-introduccion-play/intro-play-teoria/#servicios","text":"La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es obtener o crear los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas. Fichero services/UsuarioService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class UsuarioService { UsuarioRepository repository ; // Play proporcionar\u00e1 autom\u00e1ticamente el UsuarioRepository necesario // usando inyecci\u00f3n de dependencias @Inject public UsuarioService ( UsuarioRepository repository ) { this . repository = repository ; } public Usuario creaUsuario ( String login , String email , String password ) { if ( repository . findByLogin ( login ) != null ) { throw new UsuarioServiceException ( Login ya existente ); } Usuario usuario = new Usuario ( login , email ); usuario . setPassword ( password ); return repository . add ( usuario ); } public Usuario findUsuarioPorLogin ( String login ) { return repository . findByLogin ( login ); } public Usuario findUsuarioPorId ( Long id ) { return repository . findById ( id ); } public Usuario login ( String login , String password ) { Usuario usuario = repository . findByLogin ( login ); if ( usuario != null usuario . getPassword (). equals ( password )) { return usuario ; } else { return null ; } } } Fichero services/UsuarioServiceException.java : 1 2 3 4 5 6 7 8 9 public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException () { } public UsuarioServiceException ( String message ) { super ( message ); } }","title":"Servicios"},{"location":"01-introduccion-play/intro-play-teoria/#controllers_1","text":"Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen tres clases controller: UsuarioController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. EquipoController : con m\u00e9todos para crear, a\u00f1adir usuarios y listar equipos. Por ejemplo, la clase EquipoController define las acciones relacionadas con crear equipos de usuarios. En este controlador se obtienen los datos del formulario de la petici\u00f3n HTTP usando un DynamicForm que contiene todos los valores (Strings) asociados a los datos del formulario. Tambi\u00e9n es posible realizar un mapping autom\u00e1tico entre los datos de un formulario y un objeto Java usando un objeto Form . En el UsuarioController se puede ver un ejemplo que usa las clases Login y Registro . En este caso es posible definir restricciones en los atributos y realizar una validaci\u00f3n en el servidor. Fichero controllers/EquipoController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package controllers ; public class EquipoController extends Controller { @Inject FormFactory formFactory ; @Inject EquipoService equipoService ; @Security.Authenticated ( ActionAuthenticator . class ) public Result formularioNuevoEquipo () { return ok ( formNuevoEquipo . render ( )); } @Security.Authenticated ( ActionAuthenticator . class ) public Result creaNuevoEquipo () { DynamicForm requestData = formFactory . form (). bindFromRequest (); String nombre = requestData . get ( nombre ); if ( nombre == null || nombre . equals ( )) { return badRequest ( formNuevoEquipo . render ( Debes rellenar el nombre )); } equipoService . addEquipo ( nombre ); return ok ( Equipo + nombre + a\u00f1adido correctamente ); } public Result listaEquipos () { List Equipo equipos = equipoService . allEquipos (); return ok ( listaEquipos . render ( equipos )); } @Security.Authenticated ( ActionAuthenticator . class ) public Result formularioAddUsuarioEquipo () { return ok ( formEquipoUsuario . render ()); } @Security.Authenticated ( ActionAuthenticator . class ) public Result addUsuarioEquipo () { DynamicForm requestData = formFactory . form (). bindFromRequest (); String equipo = requestData . get ( equipo ); String usuario = requestData . get ( usuario ); try { equipoService . addUsuarioEquipo ( usuario , equipo ); return ok ( Usuario + usuario + a\u00f1adido al equipo + equipo ); } catch ( EquipoServiceException exception ) { return notFound ( No existe usuario / equipo ); } } } La clase UsuarioController se encarga de las acciones de registro y login. Fichero controllers/UsuarioController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 package controllers ; public class UsuarioController extends Controller { @Inject FormFactory formFactory ; // Play injecta un usuarioService junto con todas las dependencias necesarias: // UsuarioRepository y JPAApi @Inject UsuarioService usuarioService ; public Result saludo ( String mensaje ) { return ok ( saludo . render ( El mensaje que he recibido es: + mensaje )); } public Result formularioRegistro () { return ok ( formRegistro . render ( formFactory . form ( Registro . class ), )); } public Result registroUsuario () { Form Registro form = formFactory . form ( Registro . class ). bindFromRequest (); if ( form . hasErrors ()) { return badRequest ( formRegistro . render ( form , Hay errores en el formulario )); } Registro datosRegistro = form . get (); if ( usuarioService . findUsuarioPorLogin ( datosRegistro . login ) != null ) { return badRequest ( formRegistro . render ( form , Login ya existente: escoge otro )); } if (! datosRegistro . password . equals ( datosRegistro . confirmacion )) { return badRequest ( formRegistro . render ( form , No coinciden la contrase\u00f1a y la confirmaci\u00f3n )); } Usuario usuario = usuarioService . creaUsuario ( datosRegistro . login , datosRegistro . email , datosRegistro . password ); return redirect ( controllers . routes . UsuarioController . formularioLogin ()); } public Result formularioLogin () { return ok ( formLogin . render ( formFactory . form ( Login . class ), )); } public Result loginUsuario () { Form Login form = formFactory . form ( Login . class ). bindFromRequest (); if ( form . hasErrors ()) { return badRequest ( formLogin . render ( form , Hay errores en el formulario )); } Login login = form . get (); Usuario usuario = usuarioService . login ( login . username , login . password ); if ( usuario == null ) { return notFound ( formLogin . render ( form , Login y contrase\u00f1a no existentes )); } else { // A\u00f1adimos el id del usuario a la clave `connected` de // la sesi\u00f3n de Play // https://www.playframework.com/documentation/2.5.x/JavaSessionFlash // Esa clave es la usada en la autenticaci\u00f3n session ( connected , usuario . getId (). toString ()); return redirect ( controllers . routes . TareasController . listaTareas ( usuario . getId ())); } } // Comprobamos si hay alguien logeado con @Security.Authenticated(ActionAuthenticator.class) // https://alexgaribay.com/2014/06/15/authentication-in-play-framework-using-java/ @Security.Authenticated ( ActionAuthenticator . class ) public Result logout () { session (). remove ( connected ); return redirect ( controllers . routes . UsuarioController . loginUsuario ()); } @Security.Authenticated ( ActionAuthenticator . class ) public Result detalleUsuario ( Long id ) { String connectedUserStr = session ( connected ); Long connectedUser = Long . valueOf ( connectedUserStr ); if ( connectedUser != id ) { return unauthorized ( Lo siento, no est\u00e1s autorizado ); } else { Usuario usuario = usuarioService . findUsuarioPorId ( id ); if ( usuario == null ) { return notFound ( Usuario no encontrado ); } else { Logger . debug ( Encontrado usuario + usuario . getId () + : + usuario . getLogin ()); return ok ( detalleUsuario . render ( usuario )); } } } } Para mapear los datos de los formularios se usan las clases Login y Registro . Fichero controllers/Login.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package controllers ; import play.data.validation.Constraints ; public class Login { @Constraints.Required public String username ; @Constraints.Required public String password ; public String getUsername () { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } } Fichero controllers/Registro.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package controllers ; import play.data.validation.Constraints ; public class Registro { @Constraints.Required public String login ; @Constraints.Required @Constraints.Email public String email ; @Constraints.Required public String password ; @Constraints.Required public String confirmacion ; public String getLogin () { return login ; } public void setLogin ( String login ) { this . login = login ; } public String getEmail () { return email ; } public void setEmail ( String email ) { this . email = email ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getConfirmacion () { return confirmacion ; } public void setConfirmacion ( String confirmacion ) { this . confirmacion = confirmacion ; } }","title":"Controllers"},{"location":"01-introduccion-play/intro-play-teoria/#vistas_1","text":"Todas las vistas de la aplicaci\u00f3n usan como plantilla base la vista main.scala.html , en la que se carga el framework CSS Bootstrap y la librer\u00eda JavaScript JQuery . Ambos se encuentran en el directorio public , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Play. Es importante hacer notar que se obtiene la ruta absoluta a los ficheros est\u00e1ticos llamando a routes.Assets.versioned con su ruta relativa. De esta forma se modificar el directorio por defecto en el que se guardan los recursos est\u00e1ticos sin afectar a la aplicaci\u00f3n. A la plantilla main se le pasa el t\u00edtulo de la p\u00e1gina, scripts JavaScript (por defecto vac\u00edo) y un contenido HTML que se inserta en el cuerpo principal. Fichero views/main.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @* * This template is called from the `index` template. This template * handles the rendering of the page header and body tags. It takes * two arguments, a `String` for the title of the page and an `Html` * object to insert into the body of the page. *@ @(title: String, scripts: Html = Html( ))(content: Html) !DOCTYPE html html lang = en head @* Here s where we render the page title `String`. *@ title @title / title link href = @routes.Assets.versioned( bootstrap / css / bootstrap . min . css ) rel = stylesheet media = screen link rel = stylesheet media = screen href = @routes.Assets.versioned( stylesheets / main . css ) link rel = shortcut icon type = image/png href = @routes.Assets.versioned( images / favicon . png ) script src = @routes.Assets.versioned( javascripts / hello . js ) type = text/javascript / script / head body div class = container @content / div script src = @routes.Assets.versioned( javascripts / jquery . min . js ) type = text/javascript / script script src = @routes.Assets.versioned( bootstrap / js / bootstrap . min . js ) type = text/javascript / script @scripts / body / html Un ejemplo del uso de esta plantilla es la plantilla principal del listado de tareas. Se trata de una plantilla compleja, con bastantes ejemplos de c\u00f3mo usar los distintos elementos de Play: La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n for para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se usan enlaces a las URLs definidas por rutas inversas. Fichero views/listaTareas.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @(tareas: List[Tarea], usuario: Usuario, mensaje: String) @scripts = { script type = text/javascript function del ( urlBorrar ) { $ . ajax ({ url : urlBorrar , type : DELETE , success : function ( results ) { //refresh the page location . reload (); } }); } / script } @main( Tareas del usuario @usuario.getLogin() , scripts) { h2 Listado de tareas de @usuario.getLogin() / h2 table class = table table-striped tr th Tareas / th th Acci\u00f3n / th / tr @for(tarea - tareas ) { tr td @tarea.getTitulo() / td td a href = @routes.TareasController.formularioEditaTarea(tarea.getId()) span class = glyphicon glyphicon-pencil / span nbsp; / a a onmouseover = style = cursor: pointer; onclick = del( @routes.TareasController.borraTarea(tarea.getId()) ) span class = glyphicon glyphicon-trash aria-hidden = true / span / a / td / tr } tr td a href = @routes.TareasController.formularioNuevaTarea(usuario.getId()) span class = glyphicon glyphicon-plus / / a / td td a href = @routes.UsuarioController.logout() Salir / a / td / tr / table @if(mensaje != null) { div class = alert alert-success role = alert button type = button class = close data-dismiss = alert aria-label = Close span aria-hidden = true times; / span / button @mensaje / div } }","title":"Vistas"},{"location":"01-introduccion-play/intro-play-teoria/#tests_1","text":"La mayor\u00eda de los tests que contiene la aplicaci\u00f3n son tests de integraci\u00f3n, en los que no se usan mocks , sino que se comprueba el funcionamiento de la capa de servicio y la de repositorio. Como framework de testing se usa JUnit . Los datos de prueba en las tablas de la base de datos se definen y se cargan usando DBUnit . Por ejemplo, la clase models.EquipoTest contiene tests para el modelo Equipo y el EquipoRepository . Los tests se realizar\u00e1n utilizando la base de datos definida en el fichero de configuraci\u00f3n. En el fichero de configuraci\u00f3n por defecto ( conf/application.conf ) se define la base de datos de memoria H2 .","title":"Tests"},{"location":"01-introduccion-play/intro-play-teoria/#tests-con-la-base-de-datos-de-memoria-h2","text":"Ejemplo de ejecuci\u00f3n de los tests sobre la base de datos de memoria: 1 2 3 4 5 6 $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework [mads-todolist-inicial] $ test .. [info] Test run finished: 0 failed, 0 ignored, 5 total, 1.753s [info] Passed: Total 36, Failed 0, Errors 0, Passed 36 [success] Total time: 51 s, completed Aug 21, 2018 10:56:42 AM Podemos lanzar una clase de test en concreto: 1 2 3 4 5 [mads-todolist-inicial] $ testOnly models.EquipoTest ... [info] Test run finished: 0 failed, 0 ignored, 6 total, 11.377s [info] Passed: Total 6, Failed 0, Errors 0, Passed 6 [success] Total time: 38 s, completed Aug 22, 2018 7:41:09 AM","title":"Tests con la base de datos de memoria H2"},{"location":"01-introduccion-play/intro-play-teoria/#tests-con-la-base-de-datos-mysql","text":"La otra configuraci\u00f3n que vamos a usar en los tests es conf/develop-mysql.conf , en la que se utiliza una base de datos MySQL. Como ya vimos anteriormente, para utilizar esta configuraci\u00f3n hay que lanzar el servicio de MySQL usando docker y definir en la ejecuci\u00f3n del contenedor de Play las variables de entorno DB_URL , DB_USER_NAME y DB_USER_PASSWD con los datos correctos para acceder a la base de datos MySQL. 1 2 3 4 5 6 7 8 9 $ docker run -d --rm -p 3306:3306 --name play-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql $ docker run --link play-mysql --rm -it -p 9000:9000 -e \\ DB_URL= jdbc:mysql://play-mysql:3306/mads -e DB_USER_NAME= root -e \\ DB_USER_PASSWD= mads -v ${PWD}:/code domingogallardo/playframework [mads-todolist-inicial] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-inicial] $ test ... [success] Total time: 44 s, completed Aug 22, 2018 7:48:32 AM [mads-todolist-inicial] $","title":"Tests con la base de datos MySQL"},{"location":"01-introduccion-play/intro-play-teoria/#ejemplos-de-tests-de-la-aplicacion","text":"En la aplicaci\u00f3n se definen tests sobre los modelos (clases entidad y clases repositorio) y sobre los servicios. Como hemos mencionado antes se tratan de unos tests de integraci\u00f3n que se prueban directamente sobre la base de datos activa en el fichero de configuraci\u00f3n. Aunque Play proporciona facilidades para el uso de mocks no los hemos utilizado por simplificar la realizaci\u00f3n de los tests. Se utiliza DBUnit para rellenar las tablas con los datos de pruebas. El m\u00e9todo initData() limpia las tablas e inicializa estos datos con los existentes en test/resources/test_dataset.xml comienzo de la ejecuci\u00f3n de cada test. DBUnit rellena las tablas f\u00edsicas de la base de datos, no usa JPA. Hay que utilizar los nombres de las tablas y de las columnas de la propia base de datos, no los de las entidades JPA. Hay que incluir en el fichero de dataset todas las tablas de la aplicaci\u00f3n, incluyendo las tablas auxiliares de las relaciones muchos-a-muchos, para que se vac\u00eden de datos (por ejemplo, la tabla Equipo_Usuario ). Por \u00faltimo, se debe tener cuidado con las claves ajenas. No es posible borrar una tabla si hay claves ajenas que referencian a algunos de sus elementos. Para esto hay que considerar que DBUnit inserta los datos de arriba a abajo y los borra de abajo a arriba. Fichero test/resources/test_dataset.xml : 1 2 3 4 5 6 7 8 9 10 11 12 ?xml version= 1.0 encoding= UTF-8 ? dataset Usuario id= 1000 login= juangutierrez nombre= Juan apellidos= Gutierrez password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / Usuario id= 1005 login= anagarcia nombre= Ana apellidos= Garcia password= 123456789 eMail= ana.garcia@gmail.com fechaNacimiento= 1993-02-08 / Tarea id= 1001 titulo= Renovar DNI usuarioId= 1000 / Tarea id= 1002 titulo= Pr\u00e1ctica 1 MADS usuarioId= 1000 / Equipo id= 1003 nombre= Equipo A / Equipo id= 1004 nombre= Equipo B / Equipo_Usuario/ /dataset En cuanto a los tests propiamente dichos hay que resaltar algunos puntos. Los objetos definidos con inyecci\u00f3n de dependencias (la anotaci\u00f3n @Inject ) se instancian mediante el Injector de la aplicaci\u00f3n Play. La aplicaci\u00f3n se construye leyendo el fichero de configuraci\u00f3n por defecto (se puede modificar con la variable config.file de las opciones Java al lanzar el test). De esta forma los objetos instanciados utilizar\u00e1n la fuente de datos definida en la configuraci\u00f3n de la aplicaci\u00f3n (H2 o MySQL). Los tests sobre los modelos contienen pruebas sobre las entidades (por ejemplo, se comprueba el m\u00e9todo equal con entidades con y sin identificador) y sobre el repositorio del modelo, en los que se comprueba que las operaciones sobre la base de datos funcionan correctamente. Los tests sobre los servicios contienen pruebas sobre los m\u00e9todos de negocio de la clase servicio, incluyendo comprobaciones de que se lanzan excepciones si hay alg\u00fan error. Fichero test/Models/EquipoTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 package models ; public class EquipoTest { static Database db ; static private Injector injector ; // Se ejecuta s\u00f3lo una vez, al principio de todos los tests @BeforeClass static public void initApplication () { // Creamos la aplicaci\u00f3n a partir del fichero de configuraci\u00f3n. // El fichero de configuraci\u00f3n se puede cambiar en el comando // para lanzar sbt y los tests: // sbt ; set javaOptions += -Dconfig.file=conf/develop-mysql.conf ; testOnly models.EquipoTest GuiceApplicationBuilder guiceApplicationBuilder = new GuiceApplicationBuilder (). in ( Environment . simple ()); injector = guiceApplicationBuilder . injector (); // Obtenemos la base de datos utilizada por la aplicaci\u00f3n db = injector . instanceOf ( Database . class ); // Necesario para inicializar JPA injector . instanceOf ( JPAApi . class ); } @Before public void initData () throws Exception { // Creamos la base de datos de test y le asignamos el nombre JNDI DBTodoList JndiDatabaseTester databaseTester = new JndiDatabaseTester ( DBTodoList ); IDataSet initialDataSet = new FlatXmlDataSetBuilder (). build ( new FileInputStream ( test/resources/test_dataset.xml )); databaseTester . setDataSet ( initialDataSet ); databaseTester . setSetUpOperation ( DatabaseOperation . CLEAN_INSERT ); databaseTester . onSetup (); } @Test public void testEqualsEquiposConId () { Equipo equipo1 = new Equipo ( Equipo A ); Equipo equipo2 = new Equipo ( Equipo B ); Equipo equipo3 = new Equipo ( Equipo C ); equipo1 . setId ( 1L ); equipo2 . setId ( 1L ); equipo3 . setId ( 2L ); assertEquals ( equipo1 , equipo2 ); assertNotEquals ( equipo1 , equipo3 ); } @Test public void testEqualsEquiposSinId () { Equipo equipo1 = new Equipo ( Equipo A ); Equipo equipo2 = new Equipo ( Equipo A ); Equipo equipo3 = new Equipo ( Equipo B ); assertEquals ( equipo1 , equipo2 ); assertNotEquals ( equipo1 , equipo3 ); } @Test public void testAddEquipoJPARepositoryInsertsEquipoDatabase () { EquipoRepository equipoRepository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = new Equipo ( Equipo A ); equipo = equipoRepository . add ( equipo ); Logger . info ( N\u00famero de tarea: + Long . toString ( equipo . getId ())); assertNotNull ( equipo . getId ()); assertEquals ( Equipo A , getNombreFromEquipoDB ( equipo . getId ())); } private String getNombreFromEquipoDB ( Long equipoId ) { String titulo = db . withConnection ( connection - { String selectStatement = SELECT NOMBRE FROM Equipo WHERE ID = ? ; PreparedStatement prepStmt = connection . prepareStatement ( selectStatement ); prepStmt . setLong ( 1 , equipoId ); ResultSet rs = prepStmt . executeQuery (); rs . next (); return rs . getString ( NOMBRE ); }); return titulo ; } @Test public void testFindEquipoPorId () { EquipoRepository repository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = repository . findById ( 1003L ); assertEquals ( Equipo A , equipo . getNombre ()); } @Test public void testUpdateEquipo () { EquipoRepository repository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = new Equipo ( Equipo B ); equipo . setId ( 1003L ); repository . update ( equipo ); Equipo equipoActualizado = repository . findById ( 1003L ); assertEquals ( Equipo B , equipo . getNombre ()); } @Test public void testDeleteEquipo () { EquipoRepository repository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = repository . findById ( 1003L ); repository . delete ( equipo ); equipo = repository . findById ( 1003L ); assertNull ( equipo ); } } Fichero test/services/EquipoService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package services ; public class EquipoServiceTest { static private Injector injector ; @BeforeClass static public void initApplication () { GuiceApplicationBuilder guiceApplicationBuilder = new GuiceApplicationBuilder (). in ( Environment . simple ()); injector = guiceApplicationBuilder . injector (); injector . instanceOf ( JPAApi . class ); } @Before public void initData () throws Exception { JndiDatabaseTester databaseTester = new JndiDatabaseTester ( DBTodoList ); IDataSet initialDataSet = new FlatXmlDataSetBuilder (). build ( new FileInputStream ( test/resources/test_dataset.xml )); databaseTester . setDataSet ( initialDataSet ); databaseTester . setSetUpOperation ( DatabaseOperation . CLEAN_INSERT ); databaseTester . onSetup (); } @Test ( expected = EquipoServiceException . class ) public void addEquipoNombreRepetido () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); equipoService . addEquipo ( Equipo A ); } @Test public void listaEquipos () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); List Equipo equipos = equipoService . allEquipos (); assertEquals ( 2 , equipos . size ()); } @Test public void addUsuarioEquipo () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); UsuarioService usuarioService = injector . instanceOf ( UsuarioService . class ); equipoService . addUsuarioEquipo ( juangutierrez , Equipo A ); Usuario usuario = usuarioService . findUsuarioPorLogin ( juangutierrez ); List Equipo equipos = new ArrayList ( usuario . getEquipos ()); assertEquals ( 1 , equipos . size ()); assertEquals ( Equipo A , equipos . get ( 0 ). getNombre ()); } @Test public void getUsuariosEquipo () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); UsuarioService usuarioService = injector . instanceOf ( UsuarioService . class ); equipoService . addUsuarioEquipo ( juangutierrez , Equipo A ); equipoService . addUsuarioEquipo ( anagarcia , Equipo A ); List Usuario usuarios = equipoService . findUsuariosEquipo ( Equipo A ); assertEquals ( 2 , usuarios . size ()); Usuario usuario = usuarioService . findUsuarioPorLogin ( juangutierrez ); assertEquals ( 1 , usuario . getEquipos (). size ()); } @Test public void deleteUsuarioEquipo () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); UsuarioService usuarioService = injector . instanceOf ( UsuarioService . class ); equipoService . addUsuarioEquipo ( juangutierrez , Equipo A ); equipoService . addUsuarioEquipo ( anagarcia , Equipo A ); equipoService . deleteUsuarioEquipo ( juangutierrez , Equipo A ); List Usuario usuarios = equipoService . findUsuariosEquipo ( Equipo A ); assertEquals ( 1 , usuarios . size ()); Usuario usuario = usuarioService . findUsuarioPorLogin ( juangutierrez ); assertEquals ( 0 , usuario . getEquipos (). size ()); } }","title":"Ejemplos de tests de la aplicaci\u00f3n"},{"location":"01-introduccion-play/intro-play-teoria/#tecnologias-usadas","text":"","title":"Tecnolog\u00edas usadas"},{"location":"01-introduccion-play/intro-play-teoria/#play-framework","text":"Play Framework es un framework de desarrollo r\u00e1pido de aplicaciones web disponible en los lenguajes Java y Scala. Vamos a utilizar la versi\u00f3n Java. El framework proporciona un soporte de ejecuci\u00f3n que tiene como base el servidor Netty . Con este soporte es posible dise\u00f1ar y poner en marcha distintos tipos de aplicaciones: servicios HTTP, servicios HTTP as\u00edncronos basados en websockets, aplicaciones as\u00edncronas basadas en eventos, etc. Nosotros vamos a implementar una aplicaci\u00f3n tradicional que implementa un servicio HTTP. Vamos a utilizar la versi\u00f3n 2.5 en Java . Para entender el funcionamiento de esta primera pr\u00e1ctica es necesario consultar la siguiente documentaci\u00f3n del framework: Sobre el funcionamiento de Play: Using the Play console Anatomy of a Play application Sobre peticiones y respuestas HTTP: Actions, Controllers and Results HTTP routing Session and Flash scope Sobre plantillas: The template engine Common template use cases Sobre env\u00edo de datos de formularios: Handling form submission Rendering an element Sobre el acceso a base de datos y JPA Acceso a base de datos SQL Integrating with JPA Sobre la inyecci\u00f3n de dependencias Dependency Injection Sobre los tests en Play: Testing your application Sobre la configuraci\u00f3n de la aplicaci\u00f3n Play: Configuraci\u00f3n","title":"Play Framework"},{"location":"01-introduccion-play/intro-play-teoria/#java-persistence-api-jpa","text":"JPA es el API que utilizaremos para acceder a bases de datos y gestionar entidades persistentes usando un modelo ORM ( Object Relational Mapping ). Est\u00e1 integrado en Play, no es necesario instalar ninguna librer\u00eda adicional. JPA tambi\u00e9n es conocido por el nombre de una de sus implementaciones m\u00e1s populares, Hibernate. Es una tecnolog\u00eda muy usada y madura en el mundo Java. Permite gestionar la persistencia directamente con el modelo de objetos de la aplicaci\u00f3n (se denominan entidades ), independiz\u00e1ndola del modelo relacional basado en tablas y registros. La implementaci\u00f3n de JPA ObjectDB tiene unos tutoriales muy completos y accesibles: JPA Quick tour Entity classes Using JPA JPA Queries No es necesario estudiar todos los tutoriales. El objetivo de las pr\u00e1cticas no es aprender JPA, sino desarrollar de forma \u00e1gil una aplicaci\u00f3n. Vamos a utilizar lo m\u00e1s b\u00e1sico de JPA y en la mayor\u00eda de las ocasiones se va a proporcionar el c\u00f3digo necesario. Adem\u00e1s, en caso de duda, siempre podr\u00e1s realizar preguntas sobre c\u00f3mo implementar una determinada funcionalidad en el foro de Moodle. La implementaci\u00f3n de JPA que se utiliza en PlayFramework 2.5 es Hibernate 5.1.0.Final. Puedes encontrar toda la informaci\u00f3n sobre esta implementaci\u00f3n en la gu\u00eda de usuario: Hibernate ORM 5.1 User Guide","title":"Java Persistence API (JPA)"},{"location":"01-introduccion-play/intro-play-teoria/#bootstrap","text":"Para hacer m\u00e1s atractivo el dise\u00f1o de las p\u00e1ginas HTML vamos a usuar el framework CSS Bootstrap . Es conveniente tener a mano su documentaci\u00f3n, en concreto la lista de componentes: Bootstrap components","title":"Bootstrap"},{"location":"01-introduccion-play/introduccion-play/","text":"Pr\u00e1ctica 1: Primera aplicaci\u00f3n Play Framework Java 1. Objetivos 1.1. Aplicaci\u00f3n a desarrollar 1.2. Metodolog\u00eda de desarrollo 2. Entorno para realizar la pr\u00e1ctica 3. Antes de empezar la pr\u00e1ctica 4. Desarrollo de la pr\u00e1ctica 5. Entrega y evaluaci\u00f3n 1. Objetivos En la primera pr\u00e1ctica de la asignatura vamos a tomar contacto con el framework de desarrollo de aplicaciones web en Java Play Framework , trabajando sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . La pr\u00e1ctica tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando la wiki del proyecto. Antes de comenzar la pr\u00e1ctica debes leer la introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS . 1.1. Aplicaci\u00f3n inicial La aplicaci\u00f3n inicial es una aplicaci\u00f3n para gestionar listas de tareas pendientes de los empleados de una empresa. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. Tambi\u00e9n tiene unas funcionalidades iniciales b\u00e1sicas relacionadas con la gesti\u00f3n de equipos de usuarios, de las que s\u00f3lo se ha implementado el esqueleto, sin apenas interfaz de usuario. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es ToDo List . 1.2. Metodolog\u00eda de desarrollo En cuanto a la metodolog\u00eda de desarrollo, en esta primera pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues , labels , milestones , etc. JUnit y DBUnit para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Algunos ejemplos de repositorios en GitHub: CartoDB Vapor Guice Play Framework swift-nio Git Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos ( Getting Started ) y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto. Flujo de trabajo Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos todos los instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: feature , bug y technical . Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama master haciendo un pull request . Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama master haciendo un pull request . Cuando se mezcle el PR en master el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues y pull requests de ese milestone ). Tablero de proyecto : Un tablero de proyecto nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue o PR: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar project boards . Wiki : Por \u00faltimo, GitHub ofrece una wiki en que utilizaremos para documentar las nuevas features (tambi\u00e9n llamadas funcionalidades o historias de usuario) a implementar. Consultar documenting your projects on GitHub . La documentaci\u00f3n en la Wiki, en los issues , en los PRs y en el propio README.md del proyecto hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack , Confluence o incluso Trello . Pero lo que nos ofrece GitHub es suficiente para lo que vamos a realizar en la asignatura y tiene la ventaja de estar integrado en una misma plataforma. 2. Entorno para realizar la pr\u00e1ctica Software necesario: Git Docker , para ejecutar la imagen (similar a una m\u00e1quina virtual) que contiene Java y Play Framework. En esta primera pr\u00e1ctica se utiliza para compilar y ejecutar los proyectos Play y para lanzar el servicio de base de datos MySQL. Como entorno de desarrollo proporcionamos dos opciones: Visual Studio Code : IDE para trabajar en el desarrollo del proyecto si no es posible usar IntelliJ. No tiene las funcionalidades de IntelliJ de autocompletar c\u00f3digo, depuraci\u00f3n, etc. IntelliJ IDEA : IDE recomendado para trabajar en el desarrollo del proyecto. Debes descargar la versi\u00f3n Ultimate . Es de pago, pero puedes conseguir una licencia educativa en https://www.jetbrains.com/student/ . Es necesario disponer del JDK Java 8 . En la instalaci\u00f3n se debe instalar el plugin de Scala . Docker Docker es una tecnolog\u00eda que ha tenido una gran expansi\u00f3n en los \u00faltimos a\u00f1os. Permite construir m\u00e1quinas virtuales ligeras que utilizan el mismo sistema operativo de la m\u00e1quina host. Estas m\u00e1quinas virtuales se denominan contenedores y, al compartir el propio sistema operativo en el que se est\u00e1n ejecutando, su gesti\u00f3n (construcci\u00f3n, arranque, parada, etc.) es much\u00edsimo m\u00e1s r\u00e1pida que las m\u00e1quinas virtuales tradicionales. Utilizaremos la imagen Docker domingogallardo/playframework , que lanza el comando sbt sobre el directorio actual necesario para compilar y ejecutar aplicaciones Play. Cada m\u00e1quina docker se define con un fichero Dockerfile . Puedes mirar el fichero Dockerfile de la imagen de la asignatura en este enlace . M\u00e1s adelante en la asignatura estudiaremos m\u00e1s sobre Docker. Tal y como hemos explicado en la introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS para lanzar esta imagen tenemos que ejecutar el siguiente comando, estando en el directorio de la aplicaci\u00f3n Play: 1 2 $ cd /path/to/my/play/project $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework El comando docker run buscar\u00e1 la imagen domingogallardo/playframework en local y la descargar\u00e1 si no la encuentra. Despu\u00e9s la ejecutar\u00e1 montando el directorio actual en el directorio /code y mapeando el puerto 80 de la m\u00e1quina host en el puerto 9000 del contenedor. La imagen est\u00e1 configurada para lanzar el comando sbt sobre el directorio code . Como en este directorio est\u00e1 montado el directorio de la m\u00e1quina host en donde tienes el proyecto, podr\u00e1s editar y modificar los ficheros en la propia m\u00e1quina host y compilarlos y ejecutarlos desde el comando sbt en el contenedor. En la configuraci\u00f3n por defecto (fichero conf/application.conf ) la aplicaci\u00f3n trabaja con la base de datos en memoria. Existe otra configuraci\u00f3n ( conf/develop-mysql.conf ) para que la aplicaci\u00f3n trabaje con una base de datos MySQL. La utilizaremos tambi\u00e9n en la pr\u00e1ctica. Entorno de trabajo Es importante que el entorno de trabajo permita realizar con facilidad tanto el desarrollo de la aplicaci\u00f3n como las pruebas. Pruebas manuales y autom\u00e1ticas Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que hemos a\u00f1adido funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre la base de datos real MySQL . De esta forma podemos introducir datos y reutilizarlos en posteriores pruebas manuales. Tambi\u00e9n durante el desarrollo hay que implementar y lanzar tests autom\u00e1ticos . Recomendamos en este caso usar la base de datos de memoria , en lugar de la base de datos MySQL, para que la ejecuci\u00f3n de los tests tenga m\u00e1s velocidad y para que no se borren los datos introducidos en las pruebas manuales. Debemos configurar el entorno de trabajo para que sea posible realizar los dos tipos de pruebas, manuales y autom\u00e1ticas, simult\u00e1neamente. Dependiendo de si utilizamos o no IntelliJ lo haremos de forma distinta. Configuraci\u00f3n de trabajo usando Visual Studio Code Si tu ordenador no tiene prestaciones suficientes para trabajar con IntelliJ IDEA puedes usar un editor como Visual Studio Code. Recomendamos trabajar con tres pesta\u00f1as de terminal abiertas en el editor: Terminal 1 : ejecuci\u00f3n de la aplicaci\u00f3n para hacer pruebas manuales sobre base de datos MySQL. Lanzamos en el shell el comando docker para lanzar la aplicaci\u00f3n usando la base de datos MySQL. text $ docker run --link play-mysql --rm -it -p 9000:9000 -e \\ DB_URL=\"jdbc:mysql://play-mysql:3306/mads\" -e DB_USER_NAME=\"root\" -e \\ DB_USER_PASSWD=\"mads\" -v \"${PWD}:/code\" domingogallardo/playframework Y desde la consola sbt modificamos la preferencia config.file para que la aplicaci\u00f3n utilice la configuraci\u00f3n definida en el fichero conf/develop-mysql.conf text [mads-todolist-dgallardo] $ set javaOptions += \"-Dconfig.file=conf/develop-mysql.conf\" [mads-todolist-dgallardo] $ run Terminal 2 : pruebas autom\u00e1ticas sobre la base de datos de memoria. Lanzamos en el shell el comando docker para lanzar sbt. No hace falta exportar el puerto 9000 porque s\u00f3lo se va a usar el contenedor para lanzar los tests: text $ docker run --rm -it -v \"${PWD}:/code\" domingogallardo/playframework [mads-todolist-dgallardo] $ test Terminal 3 : shell en el que usaremos git: ```text $ git status On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean ``` Configuraci\u00f3n de trabajo usando IntelliJ Si tenemos un ordenador con suficiente capacidad es recomendable usar IntelliJ IDEA como entorno de desarrollo. Recomendamos la siguiente configuraci\u00f3n: Pruebas manuales : para lanzar la aplicaci\u00f3n y poder realizar pruebas manuales usando la base de datos MySQL debemos crear una configuraci\u00f3n de run/debug que trabaje sobre MySQL y lanzar la ejecuci\u00f3n. Pruebas autom\u00e1ticas : se lanza sbt desde la propia pesta\u00f1a de IntelliJ o desde un terminal con el comando docker run . Como hemos comentado anteriormente, no es necesario mapear el puerto 9000 porque el contenedor s\u00f3lo se va a usar para lanzar los tests: text $ docker run --rm -it -v \"${PWD}:/code\" domingogallardo/playframework [mads-todolist-dgallardo] $ Y se lanza el comando test . Shell de git : es recomendable tener abierta una ventana de terminal adicional para trabajar con git. Cuidado : En las m\u00e1quinas virtuales Ubuntu de la EPS, la aplicaci\u00f3n Docker se ejecuta con el usuario root . Si se lanza una ejecuci\u00f3n de la m\u00e1quina de docker con el directorio del proyecto antes de haberlo compilado con IntelliJ, se crear\u00e1n directorios de trabajo propiedad de root . Esto provocar\u00e1 un error de permisos cuando vayamos a compilar desde IntelliJ y har\u00e1 imposible la compilaci\u00f3n desde el IDE. Una posible soluci\u00f3n es lanzar IntelliJ con sudo para que se ejecute tambi\u00e9n con el usuario root : 1 $ sudo bin/idea.sh 3. Antes de empezar la pr\u00e1ctica Descarga e instala el software indicado en el apartado anterior. Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. text $ git config --global user.name \"Pepe Perez\" $ git config --global user.email pepe.perez@example.com Descarga la imagen de Docker para poder compilar y ejecutar los proyectos Play: text $ docker pull domingogallardo/playframework $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE domingogallardo/playframework latest 95c1eb17ecb4 5 weeks ago 530MB Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings Profile y actualizando el campo Name . Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente el repositorio todolist-2018- usuario en la organizaci\u00f3n mads-ua-18 . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base Play (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas: Tambi\u00e9n el profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua-18 . Descarga el proyecto y comprueba que se compila y ejecuta correctamente con la imagen de Docker y usando la base de datos de memoria (muy \u00fatil para pruebas y lanzar los tests). text $ git clone https://github.com/mads-ua/todolist-2018-usuario.git $ cd todolist-2018-usuario $ docker run --rm -it -v \"${PWD}:/code\" -p 9000:9000 domingogallardo/playframework [info] Loading project definition from /code/project [info] Updating {file:/code/project/}code-build... [info] Resolving org.fusesource.jansi#jansi;1.4 ... [info] Done updating. [info] Set current project to play-java (in build file:/code/) [mads-todolist-inicial] $ test ... [info] Passed: Total 35, Failed 0, Errors 0, Passed 35 [success] Total time: 35 s, completed Sep 4, 2018 9:34:04 AM [mads-todolist-inicial] $ run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:9000 en la m\u00e1quina host. Para salir del comando run de sbt debemos hacer CTRL+d . Podemos lanzar cualquier otro comando de sbt (consultar Using the SBT console . Para salir del contenedor podemos escribir el comando exit o hacer CTRL+c . Prueba que la aplicaci\u00f3n funciona correctamente trabajando con la base de datos MySQL (el funcionamiento real de la aplicaci\u00f3n y para hacer pruebas de integraci\u00f3n). Lanza MySQL con Docker: text $ docker run -d -p 3316:3306 --name play-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql:5 Importante En los laboratorios de la EPS est\u00e1 instalada la imagen Docker 5.7.18 de MySQL. Hay que definir expl\u00edcitamente esa versi\u00f3n en el comando docker, escribiendo mysql:5.7.18 . Para parar y volver a poner en marcha el contenedor mysql puedes usar los comandos docker stop y docker start . Los datos a\u00f1adidos en la base de datos se mantendr\u00e1n mientras que el contenedor no se borre. El comando docker container ls -a lista todos los contenedores existentes (parados y en marcha): text $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 30 minutes ago Up 22 minutes 33060/tcp, 0.0.0.0:3316- 3306/tcp play-mysql $ docker container stop bd057639b6ac CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 31 minutes ago Exited (0) 7 seconds ago play-mysql $ docker container start bd057639b6ac CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 32 minutes ago Up 5 seconds 33060/tcp, 0.0.0.0:3316- 3306/tcp play-mysql Ahora ya podemos lanzar la aplicaci\u00f3n con docker para que trabaje con la base de datos del contenedor, definiendo ahora en variables de entorno la URL, el usuario y la contrase\u00f1a con la que debe conectarse la aplicaci\u00f3n a la base de datos. Usamos la opci\u00f3n link de docker para definir el nombre l\u00f3gico del contenedor al que debe conectarse la aplicaci\u00f3n. text $ docker run --link play-mysql --rm -it -p 9000:9000 -e \\ DB_URL=\"jdbc:mysql://play-mysql:3306/mads\" -e DB_USER_NAME=\"root\" -e \\ DB_USER_PASSWD=\"mads\" -v \"${PWD}:/code\" domingogallardo/playframework Y desde la consola sbt modificamos la preferencia config.file para que la aplicaci\u00f3n utilice la configuraci\u00f3n definida en el fichero conf/develop-mysql.conf . text [mads-todolist-inicial] $ set javaOptions += \"-Dconfig.file=conf/develop-mysql.conf\" [mads-todolist-inicial] $ run Prueba que la aplicaci\u00f3n funciona correctamente. Puedes comprobar las tablas y los datos almacenados en la base de datos conect\u00e1ndote a la base de datos en el puerto 3316 desde cualquier cliente MySQL: En los laboratorios de la EPS, usando MySQL Workbench . En IntelliJ IDEA puedes usar la consola MySQL: Es posible examinar el esquema de la base de datos: Y examinar tablas en concreto: Con todo lo hecho hasta ahora ya hemos comprobado que la aplicaci\u00f3n se compila correctamente y se ejecuta sin problema en las dos configuraciones m\u00e1s importantes con las que trabajaremos: base de datos en memoria y base de datos MySQL. Para el desarrollo de la pr\u00e1ctica que viene a continuaci\u00f3n es fundamental que entiendas el funcionamiento de Play Framework. Lo explicaremos r\u00e1pidamente en la clase de teor\u00eda usando el documento introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS . Pero es imprescindible que hagas t\u00fa un esfuerzo descargando, probando y modificando las dos aplicaciones: domingogallardo/play-proyecto-inicial y domingogallardo/mads-todolist-inicial (es la aplicaci\u00f3n que se ha copiado en tu repositorio). Puedes trabajar en estos proyectos sin miedo de estropearlos. Es m\u00e1s, cuanto m\u00e1s los estropees mejor, porque es la forma de aprender. No deber\u00e1s entregar nada de estos proyectos. 4. Desarrollo de la pr\u00e1ctica En esta primera pr\u00e1ctica vamos a desarrollar las siguientes dos historias de usuario o features : P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de equipos P\u00e1gina descripci\u00f3n de equipo La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : wiki, issues , pull requests (con sus commits en los que se desarrolla paso a paso cada issue ) y tablero del proyecto. Haremos paso a paso la primera caracter\u00edstica, creando la primera versi\u00f3n 1.0.0 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0. 4.1. Versi\u00f3n 1.0.0 La versi\u00f3n 1.0.0 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de . 4.1.1. Wiki Utilizaremos la Wiki del proyecto GitHub para documentar las caracter\u00edsticas a desarrollar en la aplicaci\u00f3n. Deber\u00e1 haber una p\u00e1gina para cada caracter\u00edstica. La p\u00e1gina principal de la Wiki ser\u00e1 el backlog del proyecto y deber\u00e1 tener los enlaces a todas las caracter\u00edsticas desarrolladas y pendientes de desarrollar. A\u00f1ade la p\u00e1gina principal, en la que organizar\u00e1s el listado de features desarrolladas en proyecto. Un posible ejemplo de organizaci\u00f3n es el siguiente: A\u00f1ade una p\u00e1gina con la descripci\u00f3n de la caracter\u00edstica P\u00e1gina Acerca de : 4.1.2. Tablero del proyecto Configura el tablero del proyecto, poniendo como nombre ToDoList y seleccionando como plantilla Automated kanban . Elimina las tarjetas en la columna To do y a\u00f1ade la columna In pull request entre In progress y Done . En las columnas deber\u00e1n aparecer los issues y pull requests del proyecto. GitHub permite automatizar el movimiento de las tarjetas de una columna a otra. A continuaci\u00f3n mostramos la configuraci\u00f3n que usaremos: Deberemos mover manualmente las tarjetas en alg\u00fan caso, porque GitHub no podr\u00e1 detectar las condiciones. En resumen, las condiciones de las fichas que habr\u00e1 en cada columna son las siguientes: Columna To do : Nuevos issues a\u00f1adidos al proyecto. Cuando a\u00f1adimos el proyecto al issue (en la p\u00e1gina del issue ) GitHub lo coloca autom\u00e1ticamente en esta columna. Columna In progress : Issues que se han comenzado a implementar (se ha creado una rama su desarrollo). Manual. Columna In pull request : Pull request creados. Cuando a\u00f1adimos el proyecto al pull request (en la p\u00e1gina del pull request ) GitHub lo coloca autom\u00e1ticamente en esta columna. Archivaremos el issue implementado por el pull request manualmente. Columna Done : Pull requests cerrados. GitHub lo detecta autom\u00e1ticamente. 4.1.3. Issues A\u00f1ade el primer issue , correspondiente a la feature a desarrollar P\u00e1gina Acerca de . A\u00f1ade las etiquetas que inicialmente vamos a usar (ver la imagen) y el milestone 1.0.0. A\u00f1ade el issue al tablero (desde la p\u00e1gina del issue ) y autom\u00e1ticamente se a\u00f1adir\u00e1 en la columna To do . 4.1.4. Desarrollo Para desarrollar el issue abriremos una rama en Git, realizaremos commits sobre ella hasta estar terminado y despu\u00e9s crearemos un pull request en GitHub para realizar la integraci\u00f3n con la rama master . Mueve en el tablero la tarjeta con el issue a la columna In progress . Empezamos el desarrollo importando el proyecto en IntelliJ y creando dos pesta\u00f1as en el panel Terminal : una para lanzar el proyecto con Docker y trabajar con Sbt y la otra para trabajar con Git. Creamos la rama en la que desarrollaremos la feature y la subimos a GitHub (en el panel Git ): 1 2 3 4 5 6 7 8 9 $ git checkout -b acerca-de Switched to a new branch acerca-de $ git push -u origin acerca-de Username for https://github.com : domingogallardo2 Password for https://domingogallardo2@github.com : Total 0 (delta 0), reused 0 (delta 0) To https://github.com/mads-ua-18/todolist-2018-domingogallardo2.git * [new branch] acerca-de - acerca-de Branch acerca-de set up to track remote branch acerca-de from origin . Primer commit Hacemos un primer commit. Cambia en build.sbt el nombre del proyecto a mads-todolist- tu-nombre y la versi\u00f3n a 1.0.0-SNAPSHOT . El sufijo SNAPSHOT indica en desarrollo . Cuando hagamos el release de la versi\u00f3n 1.0.0 eliminaremos el sufijo. Realiza el commit y s\u00fabelo a GitHub: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ git add build.sbt $ git status On branch acerca-de Your branch is up to date with origin/acerca-de . Changes to be committed: (use git reset HEAD file ... to unstage) modified: build.sbt $ git commit -m Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 [acerca-de f6180cc] Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 1 file changed, 2 insertions(+), 2 deletions(-) $ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 367 bytes | 367.00 KiB/s, done. Total 3 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 2 local objects. To https://github.com/mads-ua-18/todolist-2018-domingogallardo2.git 6767016..a332017 acerca-de - acerca-de Consulta en GitHub que el commit se ha subido en GitHub: De esta forma habr\u00e1s comprobado que tienes permiso de escritura en el repositorio y que ya puedes comenzar a realizar la pr\u00e1ctica. Si ahora vuelves a lanzar la m\u00e1quina Docker en el proyecto, ver\u00e1s que ha cambiado el nombre del proyecto (en el panel Sbt ): 1 2 3 4 $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework [info] Loading project definition from /code/project [info] Set current project to mads-todolist-dgallardo (in build file:/code/) [mads-todolist-dgallardo] $ Segundo commit En el segundo commit incluiremos el desarrollo de los elementos necesarios para la p\u00e1gina acerca de : Ruta Acci\u00f3n en controller Vista Realiza los siguientes cambios. Fichero conf/routes : 1 2 3 4 5 6 7 GET /equipos/addUsuario controllers.EquipoController.formularioAddUsuarioEquipo() POST /equipos/addUsuario controllers.EquipoController.addUsuarioEquipo() + GET /about controllers.HomeController.about() # Map static resources from the /public folder to the /assets URL path GET /assets/*file controllers.Assets.versioned(path= /public , file: Asset) Fichero app/controllers/HomeController.java : 1 2 3 4 5 6 7 8 public Result index() { return ok(index.render( Your new application is ready. )); } + public Result about() { + return ok(about.render()); + } } Fichero app/views/about.scala.html : 1 2 3 4 5 6 7 8 9 10 +@main( Acerca de ) { + div class= container-fluid + h1 ToDo List /h1 + ul + li Desarrollada por Domingo Gallardo /li + li Versi\u00f3n 1.0.0 (en desarrollo) /li + li Fecha de release: pendiente de release /li + /ul + /div +} Prueba la p\u00e1gina accediendo a la url http://localhost:9000/about . Por \u00faltimo, confirma el commit en la rama y s\u00fabelo a GitHub. En el panel Git : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ git add . $ git status On branch acerca-de Your branch is up to date with origin/acerca-de . Changes to be committed: (use git reset HEAD file ... to unstage) modified: app/controllers/HomeController.java new file: app/views/about.scala.html modified: conf/routes $ git commit -m A\u00f1adida ruta, vista y controller about [acerca-de 2831312] A\u00f1adida ruta, vista y controller about 3 files changed, 14 insertions(+) create mode 100644 app/views/about.scala.html $ git push Tercer commit En el tercer commit pondremos un enlace a la p\u00e1gina acerca de en la p\u00e1gina de login de la aplicaci\u00f3n. Realiza el siguiente cambio: Fichero app/views/formLogin.scala.html : 1 2 3 4 a class= btn btn-link href= @routes.UsuarioController.registroUsuario() Ir a registro /a /p + p a class= btn btn-link href= @routes.HomeController.about() Acerca de /a /p } Prueba que funciona correctamente, haz el commit y s\u00fabelo a GitHub: 1 2 3 4 $ git commit -am A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login [acerca-de 672c28f] A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login 1 file changed, 1 insertion(+) $ git push 4.1.5. Pull request Una vez terminada la implementaci\u00f3n de la feature en la rama, creamos un pull request en GitHub para indicar que estamos listos para mezclar la rama con la feature con la rama principal de desarrollo ( master ). M\u00e1s adelante a\u00f1adiremos al pull request una comprobaci\u00f3n autom\u00e1tica de las pruebas y una revisi\u00f3n de c\u00f3digo por parte de compa\u00f1eros del equipo. Por ahora haremos nosotros ambas tareas. Vamos a verlo paso a paso. Empezamos por mezclar la rama de forma local con master , antes de hacer el pull request en GitHub, para probar que no se ha roto nada (todos los tests deben seguir pasando) y que los tests que hemos a\u00f1adido tambi\u00e9n funcionan correctamente (en este caso no hemos a\u00f1adido ninguno). En el panel Git : 1 2 3 4 5 6 7 8 9 10 11 12 13 $ git checkout master Switched to branch master Your branch is up to date with origin/master . $ git merge acerca-de Updating 6767016..672c28f Fast-forward app/controllers/HomeController.java | 4 ++++ app/views/about.scala.html | 8 ++++++++ app/views/formLogin.scala.html | 1 + build.sbt | 4 ++-- conf/routes | 2 ++ 5 files changed, 17 insertions(+), 2 deletions(-) create mode 100644 app/views/about.scala.html En el panel Sbt : 1 2 3 4 5 [mads-todolist-dgallardo] $ test ... [info] Passed: Total 35, Failed 0, Errors 0, Passed 35 [success] Total time: 71 s, completed Sep 6, 2018 10:04:55 AM [mads-todolist-dgallardo] $ Una vez que hemos comprobado que todo funciona bien, deshacemos el merge que acabamos de realizar en la rama master , ya que actualizaremos despu\u00e9s la rama con el resultado del pull request en GitHub: 1 2 3 4 5 $ git reset --hard origin/master HEAD is now at 6767016 Commit inicial $ git checkout acerca-de Switched to branch acerca-de Your branch is up to date with origin/acerca-de . Ya podemos crear el pull request en GitHub. Accede a la rama y comprueba que est\u00e1n todos los cambios pulsando Compare . Pulsa despu\u00e9s el bot\u00f3n New pull request para crear el pull request . Introduce el nombre del pull request , el comentario, el milestone y la etiqueta. Copia los datos del issue , y en el comentario escribe 1 Closes #1 De esta forma, cuando se cierre el pull request se cerrar\u00e1 autom\u00e1ticamente el issue . El n\u00famero #1 lo convierte GitHub en un enlace al issue correspondiente. De esta forma podemos examinar el issue resuelto por el PR. A\u00f1ade tambi\u00e9n el PR al tablero del proyecto. Se colocar\u00e1 autom\u00e1ticamente la columna In pull request . Entra en el proyecto y archiva la tarjeta con el issue , ya que la actividad de desarrollar la feature queda representada por el pull request . En este momento se deber\u00eda hacer una revisi\u00f3n del c\u00f3digo del pull request y comprobar de forma autom\u00e1tica que la integraci\u00f3n con master no introduce errores en los tests. Lo haremos en siguientes pr\u00e1cticas. GitHub informa de que no hay conflictos con la rama master y que es posible hacer el merge. Pulsa el bot\u00f3n de Merge y conf\u00edrmalo. Borra la rama en GitHub, pulsando el bot\u00f3n correspondiente. Por \u00faltimo, este merge lo has hecho en GitHub, debes integrarlo en tu repositorio local. En la pesta\u00f1a de Git: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 $ git checkout master $ git fetch remote: Counting objects: 1, done. remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (1/1), done. From https://github.com/mads-ua-18/todolist-2018-domingogallardo2 6767016..9527ae2 master - origin/master $ git pull Updating 6767016..9527ae2 Fast-forward app/controllers/HomeController.java | 4 ++++ app/views/about.scala.html | 8 ++++++++ app/views/formLogin.scala.html | 1 + build.sbt | 4 ++-- conf/routes | 2 ++ 5 files changed, 17 insertions(+), 2 deletions(-) create mode 100644 app/views/about.scala.html $ git branch -d acerca-de Deleted branch acerca-de (was 672c28f). $ git remote prune origin Pruning origin URL: https://github.com/mads-ua-18/todolist-2018-domingogallardo2.git * [pruned] origin/acerca-de $ git log --oneline --graph --all * 9527ae2 (HEAD - master, origin/master, origin/HEAD) Merge pull request #2 from mads-ua-18/acerca-de |\\ | * 672c28f A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login | * 3fdfb83 A\u00f1adida ruta, vista y controller about | * a332017 Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 |/ * 6767016 Commit inicial Comprobamos tambi\u00e9n la historia de commits en GitHub. Aparecer\u00e1 el commit de merge introducido por el pull request . De esta forma hemos cerrado el PR e integrado su c\u00f3digo en la rama principal de desarrollo. En el tablero de proyecto debe haber cambiado la tarjeta con el PR a la columna Done . 4.1.6. Versi\u00f3n 1.0.0 Por \u00faltimo creamos el release 1.0.0. Haremos un commit directamente sobre la rama master (m\u00e1s adelante explicaremos una forma m\u00e1s elaborada de hacer un release , cuando expliquemos el flujo de trabajo de GitFlow). Crea un commit con la confirmaci\u00f3n del n\u00famero de versi\u00f3n y fecha en los ficheros build.sbt y about.scala.html Fichero build.sbt : 1 2 3 4 5 6 name := mads-todolist-dgallardo -version := 1.0.0-SNAPSHOT +version := 1.0.0 lazy val root = (project in file( . )).enablePlugins(PlayJava) Fichero app/views/about.scala.html : 1 2 3 4 5 6 7 8 9 h1 ToDo List /h1 ul li Desarrollada por Domingo Gallardo /li - li Versi\u00f3n 1.0.0 (en desarrollo) /li - li Fecha de release: pendiente de release /li + li Versi\u00f3n 1.0.0 /li + li Fecha de release: 6/9/2018 /li /ul } A\u00f1adimos el commit y lo subimos a GitHub 1 2 3 4 5 $ git add . $ git commit -m Cambio de versi\u00f3n a 1.0.0 [master 61d4ac8] Cambio de versi\u00f3n a 1.0.0 2 files changed, 3 insertions(+), 3 deletions(-) $ git push Y, por \u00faltimo, creamos la versi\u00f3n 1.0.0 en GitHub pulsando en el enlace release en la p\u00e1gina principal (pesta\u00f1a Code ). Un release en GitHub se guarda como una una etiqueta Git, junto con informaci\u00f3n asociada. Se suelen indicar las nuevas features a\u00f1adidas en el release mediante enlaces a los pull requests a\u00f1adidos. Tambi\u00e9n a\u00f1adiremos enlaces a la p\u00e1gina de la Wiki en la que se describe la caracter\u00edstica. El resultado ser\u00e1: 4.2. Versi\u00f3n 1.1.0 El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 2 opcionales: Barra de men\u00fa, obligatoria. P\u00e1gina de equipos de un usuario, obligatoria. P\u00e1gina de descripci\u00f3n de un equipo con el listado de usuarios que participan en \u00e9l, obligatoria. (Opcional) Usuario administrador que gestiona los equipos Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio. Barra de men\u00fa La aplicaci\u00f3n deber\u00e1 tener una barra de men\u00fa com\u00fan a todas sus p\u00e1ginas, menos en las p\u00e1ginas de login y registro. La barra de men\u00fa estar\u00e1 situada en la parte superior de la p\u00e1gina y ser\u00e1 un Navbar . de Bootstrap. La barra de men\u00fa tendr\u00e1 como m\u00ednimo los siguientes elementos (de izquierda a derecha): ToDoList : enlace a la p\u00e1gina acerca de . Tareas : enlace a la p\u00e1gina de tareas, con la lista de tareas pendientes del usuario. Equipos : enlace a la p\u00e1gina de equipos, con el listado de equipos al que pertenece el usuario. Nombre usuario : A la derecha de la p\u00e1gina. Desplegable con las opciones: Cuenta : Futura p\u00e1gina para gestionar la cuenta Cerrar sesi\u00f3n nombre usuario : cierra la sesi\u00f3n y lleva a la p\u00e1gina de login. Equipos de un usuario Cuando el usuario pinche en la opci\u00f3n Equipos del men\u00fa ir\u00e1 a una p\u00e1gina con un listado del equipo a los que pertenece. El listado de equipos ser\u00e1 una tabla similar al listado de tareas, pero sin acciones. La ruta para obtener el listado de los equipos de un usuario ser\u00e1 /usuarios/:id/equipos . Al igual que el listado de tareas, la ruta estar\u00e1 protegida para que s\u00f3lo pueda acceder un usuario logeado y siendo el usuario logeado el mismo que el id . Descripci\u00f3n de equipo En la lista de equipos de un usuario los equipos tendr\u00e1n un enlace para acceder a su descripci\u00f3n. En la descripci\u00f3n de un equipo aparecer\u00e1: su nombre y el listado de personas del equipo. La ruta para obtener la descripci\u00f3n de un equipo ser\u00e1 /equipos/:id . La ruta estar\u00e1 protegida para que s\u00f3lo pueda acceder un usuario logeado. Usuario administrador (opcional) Al realizar el registro ser\u00e1 posible darse de alta como usuario administrador. Para darse de alta como administrador se deber\u00e1 activar un check box en la p\u00e1gina de registro. S\u00f3lo puede haber un administrador. Si ya existe un administrador, no debe aparecer el check box en la p\u00e1gina de registro. El usuario administrador tendr\u00e1 una barra de men\u00fa en la que se a\u00f1adir\u00e1 la opci\u00f3n vac\u00eda Administraci\u00f3n (que iremos cambiando conforme a\u00f1adamos funcionalidades a realizar por el administrador). Gesti\u00f3n equipos por usuario administrador (opcional) El usuario administrador podr\u00e1 gestionar los equipos: a\u00f1adir y editar equipos (la opci\u00f3n de borrar la dejamos para m\u00e1s adelante). El administrador tendr\u00e1 una opci\u00f3n adicional del men\u00fa llamada Administraci\u00f3n de la que se desplegar\u00e1n la opci\u00f3n Equipos . En la administraci\u00f3n de equipos se entrar\u00e1 en una p\u00e1gina donde se mostrar\u00e1 un listado de todos los equipos existentes (como el listado de tareas) y se dar\u00e1 la opci\u00f3n de a\u00f1adir y editar. En la p\u00e1gina de edici\u00f3n de un equipo se podr\u00e1 modificar su nombre y aparecer\u00e1 una tabla con todos los usuarios. Se podr\u00e1 eliminar usuarios del equipo o a\u00f1adir nuevos usuarios al mismo. Los usuarios a a\u00f1adir se escoger\u00e1n de un desplegable en el que se mostrar\u00e1n todos los usuarios no pertenecientes a un equipo. 5. Entrega y evaluaci\u00f3n La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 9 de octubre. La parte obligatoria punt\u00faa sobre 7 y la opcional sobre 3 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 9% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un clean . Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Enunciado"},{"location":"01-introduccion-play/introduccion-play/#practica-1-primera-aplicacion-play-framework-java","text":"1. Objetivos 1.1. Aplicaci\u00f3n a desarrollar 1.2. Metodolog\u00eda de desarrollo 2. Entorno para realizar la pr\u00e1ctica 3. Antes de empezar la pr\u00e1ctica 4. Desarrollo de la pr\u00e1ctica 5. Entrega y evaluaci\u00f3n","title":"Pr\u00e1ctica 1: Primera aplicaci\u00f3n Play Framework Java"},{"location":"01-introduccion-play/introduccion-play/#1-objetivos","text":"En la primera pr\u00e1ctica de la asignatura vamos a tomar contacto con el framework de desarrollo de aplicaciones web en Java Play Framework , trabajando sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . La pr\u00e1ctica tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando la wiki del proyecto. Antes de comenzar la pr\u00e1ctica debes leer la introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS .","title":"1. Objetivos"},{"location":"01-introduccion-play/introduccion-play/#11-aplicacion-inicial","text":"La aplicaci\u00f3n inicial es una aplicaci\u00f3n para gestionar listas de tareas pendientes de los empleados de una empresa. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. Tambi\u00e9n tiene unas funcionalidades iniciales b\u00e1sicas relacionadas con la gesti\u00f3n de equipos de usuarios, de las que s\u00f3lo se ha implementado el esqueleto, sin apenas interfaz de usuario. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es ToDo List .","title":"1.1. Aplicaci\u00f3n inicial"},{"location":"01-introduccion-play/introduccion-play/#12-metodologia-de-desarrollo","text":"En cuanto a la metodolog\u00eda de desarrollo, en esta primera pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues , labels , milestones , etc. JUnit y DBUnit para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Algunos ejemplos de repositorios en GitHub: CartoDB Vapor Guice Play Framework swift-nio","title":"1.2. Metodolog\u00eda de desarrollo"},{"location":"01-introduccion-play/introduccion-play/#git","text":"Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos ( Getting Started ) y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto.","title":"Git"},{"location":"01-introduccion-play/introduccion-play/#flujo-de-trabajo","text":"Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos todos los instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: feature , bug y technical . Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama master haciendo un pull request . Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama master haciendo un pull request . Cuando se mezcle el PR en master el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues y pull requests de ese milestone ). Tablero de proyecto : Un tablero de proyecto nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue o PR: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar project boards . Wiki : Por \u00faltimo, GitHub ofrece una wiki en que utilizaremos para documentar las nuevas features (tambi\u00e9n llamadas funcionalidades o historias de usuario) a implementar. Consultar documenting your projects on GitHub . La documentaci\u00f3n en la Wiki, en los issues , en los PRs y en el propio README.md del proyecto hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack , Confluence o incluso Trello . Pero lo que nos ofrece GitHub es suficiente para lo que vamos a realizar en la asignatura y tiene la ventaja de estar integrado en una misma plataforma.","title":"Flujo de trabajo"},{"location":"01-introduccion-play/introduccion-play/#2-entorno-para-realizar-la-practica","text":"Software necesario: Git Docker , para ejecutar la imagen (similar a una m\u00e1quina virtual) que contiene Java y Play Framework. En esta primera pr\u00e1ctica se utiliza para compilar y ejecutar los proyectos Play y para lanzar el servicio de base de datos MySQL. Como entorno de desarrollo proporcionamos dos opciones: Visual Studio Code : IDE para trabajar en el desarrollo del proyecto si no es posible usar IntelliJ. No tiene las funcionalidades de IntelliJ de autocompletar c\u00f3digo, depuraci\u00f3n, etc. IntelliJ IDEA : IDE recomendado para trabajar en el desarrollo del proyecto. Debes descargar la versi\u00f3n Ultimate . Es de pago, pero puedes conseguir una licencia educativa en https://www.jetbrains.com/student/ . Es necesario disponer del JDK Java 8 . En la instalaci\u00f3n se debe instalar el plugin de Scala .","title":"2. Entorno para realizar la pr\u00e1ctica"},{"location":"01-introduccion-play/introduccion-play/#docker","text":"Docker es una tecnolog\u00eda que ha tenido una gran expansi\u00f3n en los \u00faltimos a\u00f1os. Permite construir m\u00e1quinas virtuales ligeras que utilizan el mismo sistema operativo de la m\u00e1quina host. Estas m\u00e1quinas virtuales se denominan contenedores y, al compartir el propio sistema operativo en el que se est\u00e1n ejecutando, su gesti\u00f3n (construcci\u00f3n, arranque, parada, etc.) es much\u00edsimo m\u00e1s r\u00e1pida que las m\u00e1quinas virtuales tradicionales. Utilizaremos la imagen Docker domingogallardo/playframework , que lanza el comando sbt sobre el directorio actual necesario para compilar y ejecutar aplicaciones Play. Cada m\u00e1quina docker se define con un fichero Dockerfile . Puedes mirar el fichero Dockerfile de la imagen de la asignatura en este enlace . M\u00e1s adelante en la asignatura estudiaremos m\u00e1s sobre Docker. Tal y como hemos explicado en la introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS para lanzar esta imagen tenemos que ejecutar el siguiente comando, estando en el directorio de la aplicaci\u00f3n Play: 1 2 $ cd /path/to/my/play/project $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework El comando docker run buscar\u00e1 la imagen domingogallardo/playframework en local y la descargar\u00e1 si no la encuentra. Despu\u00e9s la ejecutar\u00e1 montando el directorio actual en el directorio /code y mapeando el puerto 80 de la m\u00e1quina host en el puerto 9000 del contenedor. La imagen est\u00e1 configurada para lanzar el comando sbt sobre el directorio code . Como en este directorio est\u00e1 montado el directorio de la m\u00e1quina host en donde tienes el proyecto, podr\u00e1s editar y modificar los ficheros en la propia m\u00e1quina host y compilarlos y ejecutarlos desde el comando sbt en el contenedor. En la configuraci\u00f3n por defecto (fichero conf/application.conf ) la aplicaci\u00f3n trabaja con la base de datos en memoria. Existe otra configuraci\u00f3n ( conf/develop-mysql.conf ) para que la aplicaci\u00f3n trabaje con una base de datos MySQL. La utilizaremos tambi\u00e9n en la pr\u00e1ctica.","title":"Docker"},{"location":"01-introduccion-play/introduccion-play/#entorno-de-trabajo","text":"Es importante que el entorno de trabajo permita realizar con facilidad tanto el desarrollo de la aplicaci\u00f3n como las pruebas.","title":"Entorno de trabajo"},{"location":"01-introduccion-play/introduccion-play/#pruebas-manuales-y-automaticas","text":"Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que hemos a\u00f1adido funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre la base de datos real MySQL . De esta forma podemos introducir datos y reutilizarlos en posteriores pruebas manuales. Tambi\u00e9n durante el desarrollo hay que implementar y lanzar tests autom\u00e1ticos . Recomendamos en este caso usar la base de datos de memoria , en lugar de la base de datos MySQL, para que la ejecuci\u00f3n de los tests tenga m\u00e1s velocidad y para que no se borren los datos introducidos en las pruebas manuales. Debemos configurar el entorno de trabajo para que sea posible realizar los dos tipos de pruebas, manuales y autom\u00e1ticas, simult\u00e1neamente. Dependiendo de si utilizamos o no IntelliJ lo haremos de forma distinta.","title":"Pruebas manuales y autom\u00e1ticas"},{"location":"01-introduccion-play/introduccion-play/#configuracion-de-trabajo-usando-visual-studio-code","text":"Si tu ordenador no tiene prestaciones suficientes para trabajar con IntelliJ IDEA puedes usar un editor como Visual Studio Code. Recomendamos trabajar con tres pesta\u00f1as de terminal abiertas en el editor: Terminal 1 : ejecuci\u00f3n de la aplicaci\u00f3n para hacer pruebas manuales sobre base de datos MySQL. Lanzamos en el shell el comando docker para lanzar la aplicaci\u00f3n usando la base de datos MySQL. text $ docker run --link play-mysql --rm -it -p 9000:9000 -e \\ DB_URL=\"jdbc:mysql://play-mysql:3306/mads\" -e DB_USER_NAME=\"root\" -e \\ DB_USER_PASSWD=\"mads\" -v \"${PWD}:/code\" domingogallardo/playframework Y desde la consola sbt modificamos la preferencia config.file para que la aplicaci\u00f3n utilice la configuraci\u00f3n definida en el fichero conf/develop-mysql.conf text [mads-todolist-dgallardo] $ set javaOptions += \"-Dconfig.file=conf/develop-mysql.conf\" [mads-todolist-dgallardo] $ run Terminal 2 : pruebas autom\u00e1ticas sobre la base de datos de memoria. Lanzamos en el shell el comando docker para lanzar sbt. No hace falta exportar el puerto 9000 porque s\u00f3lo se va a usar el contenedor para lanzar los tests: text $ docker run --rm -it -v \"${PWD}:/code\" domingogallardo/playframework [mads-todolist-dgallardo] $ test Terminal 3 : shell en el que usaremos git: ```text $ git status On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean ```","title":"Configuraci\u00f3n de trabajo usando Visual Studio Code"},{"location":"01-introduccion-play/introduccion-play/#configuracion-de-trabajo-usando-intellij","text":"Si tenemos un ordenador con suficiente capacidad es recomendable usar IntelliJ IDEA como entorno de desarrollo. Recomendamos la siguiente configuraci\u00f3n: Pruebas manuales : para lanzar la aplicaci\u00f3n y poder realizar pruebas manuales usando la base de datos MySQL debemos crear una configuraci\u00f3n de run/debug que trabaje sobre MySQL y lanzar la ejecuci\u00f3n. Pruebas autom\u00e1ticas : se lanza sbt desde la propia pesta\u00f1a de IntelliJ o desde un terminal con el comando docker run . Como hemos comentado anteriormente, no es necesario mapear el puerto 9000 porque el contenedor s\u00f3lo se va a usar para lanzar los tests: text $ docker run --rm -it -v \"${PWD}:/code\" domingogallardo/playframework [mads-todolist-dgallardo] $ Y se lanza el comando test . Shell de git : es recomendable tener abierta una ventana de terminal adicional para trabajar con git. Cuidado : En las m\u00e1quinas virtuales Ubuntu de la EPS, la aplicaci\u00f3n Docker se ejecuta con el usuario root . Si se lanza una ejecuci\u00f3n de la m\u00e1quina de docker con el directorio del proyecto antes de haberlo compilado con IntelliJ, se crear\u00e1n directorios de trabajo propiedad de root . Esto provocar\u00e1 un error de permisos cuando vayamos a compilar desde IntelliJ y har\u00e1 imposible la compilaci\u00f3n desde el IDE. Una posible soluci\u00f3n es lanzar IntelliJ con sudo para que se ejecute tambi\u00e9n con el usuario root : 1 $ sudo bin/idea.sh","title":"Configuraci\u00f3n de trabajo usando IntelliJ"},{"location":"01-introduccion-play/introduccion-play/#3-antes-de-empezar-la-practica","text":"Descarga e instala el software indicado en el apartado anterior. Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. text $ git config --global user.name \"Pepe Perez\" $ git config --global user.email pepe.perez@example.com Descarga la imagen de Docker para poder compilar y ejecutar los proyectos Play: text $ docker pull domingogallardo/playframework $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE domingogallardo/playframework latest 95c1eb17ecb4 5 weeks ago 530MB Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings Profile y actualizando el campo Name . Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente el repositorio todolist-2018- usuario en la organizaci\u00f3n mads-ua-18 . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base Play (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas: Tambi\u00e9n el profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua-18 . Descarga el proyecto y comprueba que se compila y ejecuta correctamente con la imagen de Docker y usando la base de datos de memoria (muy \u00fatil para pruebas y lanzar los tests). text $ git clone https://github.com/mads-ua/todolist-2018-usuario.git $ cd todolist-2018-usuario $ docker run --rm -it -v \"${PWD}:/code\" -p 9000:9000 domingogallardo/playframework [info] Loading project definition from /code/project [info] Updating {file:/code/project/}code-build... [info] Resolving org.fusesource.jansi#jansi;1.4 ... [info] Done updating. [info] Set current project to play-java (in build file:/code/) [mads-todolist-inicial] $ test ... [info] Passed: Total 35, Failed 0, Errors 0, Passed 35 [success] Total time: 35 s, completed Sep 4, 2018 9:34:04 AM [mads-todolist-inicial] $ run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:9000 en la m\u00e1quina host. Para salir del comando run de sbt debemos hacer CTRL+d . Podemos lanzar cualquier otro comando de sbt (consultar Using the SBT console . Para salir del contenedor podemos escribir el comando exit o hacer CTRL+c . Prueba que la aplicaci\u00f3n funciona correctamente trabajando con la base de datos MySQL (el funcionamiento real de la aplicaci\u00f3n y para hacer pruebas de integraci\u00f3n). Lanza MySQL con Docker: text $ docker run -d -p 3316:3306 --name play-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql:5 Importante En los laboratorios de la EPS est\u00e1 instalada la imagen Docker 5.7.18 de MySQL. Hay que definir expl\u00edcitamente esa versi\u00f3n en el comando docker, escribiendo mysql:5.7.18 . Para parar y volver a poner en marcha el contenedor mysql puedes usar los comandos docker stop y docker start . Los datos a\u00f1adidos en la base de datos se mantendr\u00e1n mientras que el contenedor no se borre. El comando docker container ls -a lista todos los contenedores existentes (parados y en marcha): text $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 30 minutes ago Up 22 minutes 33060/tcp, 0.0.0.0:3316- 3306/tcp play-mysql $ docker container stop bd057639b6ac CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 31 minutes ago Exited (0) 7 seconds ago play-mysql $ docker container start bd057639b6ac CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 32 minutes ago Up 5 seconds 33060/tcp, 0.0.0.0:3316- 3306/tcp play-mysql Ahora ya podemos lanzar la aplicaci\u00f3n con docker para que trabaje con la base de datos del contenedor, definiendo ahora en variables de entorno la URL, el usuario y la contrase\u00f1a con la que debe conectarse la aplicaci\u00f3n a la base de datos. Usamos la opci\u00f3n link de docker para definir el nombre l\u00f3gico del contenedor al que debe conectarse la aplicaci\u00f3n. text $ docker run --link play-mysql --rm -it -p 9000:9000 -e \\ DB_URL=\"jdbc:mysql://play-mysql:3306/mads\" -e DB_USER_NAME=\"root\" -e \\ DB_USER_PASSWD=\"mads\" -v \"${PWD}:/code\" domingogallardo/playframework Y desde la consola sbt modificamos la preferencia config.file para que la aplicaci\u00f3n utilice la configuraci\u00f3n definida en el fichero conf/develop-mysql.conf . text [mads-todolist-inicial] $ set javaOptions += \"-Dconfig.file=conf/develop-mysql.conf\" [mads-todolist-inicial] $ run Prueba que la aplicaci\u00f3n funciona correctamente. Puedes comprobar las tablas y los datos almacenados en la base de datos conect\u00e1ndote a la base de datos en el puerto 3316 desde cualquier cliente MySQL: En los laboratorios de la EPS, usando MySQL Workbench . En IntelliJ IDEA puedes usar la consola MySQL: Es posible examinar el esquema de la base de datos: Y examinar tablas en concreto: Con todo lo hecho hasta ahora ya hemos comprobado que la aplicaci\u00f3n se compila correctamente y se ejecuta sin problema en las dos configuraciones m\u00e1s importantes con las que trabajaremos: base de datos en memoria y base de datos MySQL. Para el desarrollo de la pr\u00e1ctica que viene a continuaci\u00f3n es fundamental que entiendas el funcionamiento de Play Framework. Lo explicaremos r\u00e1pidamente en la clase de teor\u00eda usando el documento introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS . Pero es imprescindible que hagas t\u00fa un esfuerzo descargando, probando y modificando las dos aplicaciones: domingogallardo/play-proyecto-inicial y domingogallardo/mads-todolist-inicial (es la aplicaci\u00f3n que se ha copiado en tu repositorio). Puedes trabajar en estos proyectos sin miedo de estropearlos. Es m\u00e1s, cuanto m\u00e1s los estropees mejor, porque es la forma de aprender. No deber\u00e1s entregar nada de estos proyectos.","title":"3. Antes de empezar la pr\u00e1ctica"},{"location":"01-introduccion-play/introduccion-play/#4-desarrollo-de-la-practica","text":"En esta primera pr\u00e1ctica vamos a desarrollar las siguientes dos historias de usuario o features : P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de equipos P\u00e1gina descripci\u00f3n de equipo La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : wiki, issues , pull requests (con sus commits en los que se desarrolla paso a paso cada issue ) y tablero del proyecto. Haremos paso a paso la primera caracter\u00edstica, creando la primera versi\u00f3n 1.0.0 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0.","title":"4. Desarrollo de la pr\u00e1ctica"},{"location":"01-introduccion-play/introduccion-play/#41-version-100","text":"La versi\u00f3n 1.0.0 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de .","title":"4.1. Versi\u00f3n 1.0.0"},{"location":"01-introduccion-play/introduccion-play/#411-wiki","text":"Utilizaremos la Wiki del proyecto GitHub para documentar las caracter\u00edsticas a desarrollar en la aplicaci\u00f3n. Deber\u00e1 haber una p\u00e1gina para cada caracter\u00edstica. La p\u00e1gina principal de la Wiki ser\u00e1 el backlog del proyecto y deber\u00e1 tener los enlaces a todas las caracter\u00edsticas desarrolladas y pendientes de desarrollar. A\u00f1ade la p\u00e1gina principal, en la que organizar\u00e1s el listado de features desarrolladas en proyecto. Un posible ejemplo de organizaci\u00f3n es el siguiente: A\u00f1ade una p\u00e1gina con la descripci\u00f3n de la caracter\u00edstica P\u00e1gina Acerca de :","title":"4.1.1. Wiki"},{"location":"01-introduccion-play/introduccion-play/#412-tablero-del-proyecto","text":"Configura el tablero del proyecto, poniendo como nombre ToDoList y seleccionando como plantilla Automated kanban . Elimina las tarjetas en la columna To do y a\u00f1ade la columna In pull request entre In progress y Done . En las columnas deber\u00e1n aparecer los issues y pull requests del proyecto. GitHub permite automatizar el movimiento de las tarjetas de una columna a otra. A continuaci\u00f3n mostramos la configuraci\u00f3n que usaremos: Deberemos mover manualmente las tarjetas en alg\u00fan caso, porque GitHub no podr\u00e1 detectar las condiciones. En resumen, las condiciones de las fichas que habr\u00e1 en cada columna son las siguientes: Columna To do : Nuevos issues a\u00f1adidos al proyecto. Cuando a\u00f1adimos el proyecto al issue (en la p\u00e1gina del issue ) GitHub lo coloca autom\u00e1ticamente en esta columna. Columna In progress : Issues que se han comenzado a implementar (se ha creado una rama su desarrollo). Manual. Columna In pull request : Pull request creados. Cuando a\u00f1adimos el proyecto al pull request (en la p\u00e1gina del pull request ) GitHub lo coloca autom\u00e1ticamente en esta columna. Archivaremos el issue implementado por el pull request manualmente. Columna Done : Pull requests cerrados. GitHub lo detecta autom\u00e1ticamente.","title":"4.1.2. Tablero del proyecto"},{"location":"01-introduccion-play/introduccion-play/#413-issues","text":"A\u00f1ade el primer issue , correspondiente a la feature a desarrollar P\u00e1gina Acerca de . A\u00f1ade las etiquetas que inicialmente vamos a usar (ver la imagen) y el milestone 1.0.0. A\u00f1ade el issue al tablero (desde la p\u00e1gina del issue ) y autom\u00e1ticamente se a\u00f1adir\u00e1 en la columna To do .","title":"4.1.3. Issues"},{"location":"01-introduccion-play/introduccion-play/#414-desarrollo","text":"Para desarrollar el issue abriremos una rama en Git, realizaremos commits sobre ella hasta estar terminado y despu\u00e9s crearemos un pull request en GitHub para realizar la integraci\u00f3n con la rama master . Mueve en el tablero la tarjeta con el issue a la columna In progress . Empezamos el desarrollo importando el proyecto en IntelliJ y creando dos pesta\u00f1as en el panel Terminal : una para lanzar el proyecto con Docker y trabajar con Sbt y la otra para trabajar con Git. Creamos la rama en la que desarrollaremos la feature y la subimos a GitHub (en el panel Git ): 1 2 3 4 5 6 7 8 9 $ git checkout -b acerca-de Switched to a new branch acerca-de $ git push -u origin acerca-de Username for https://github.com : domingogallardo2 Password for https://domingogallardo2@github.com : Total 0 (delta 0), reused 0 (delta 0) To https://github.com/mads-ua-18/todolist-2018-domingogallardo2.git * [new branch] acerca-de - acerca-de Branch acerca-de set up to track remote branch acerca-de from origin .","title":"4.1.4. Desarrollo"},{"location":"01-introduccion-play/introduccion-play/#primer-commit","text":"Hacemos un primer commit. Cambia en build.sbt el nombre del proyecto a mads-todolist- tu-nombre y la versi\u00f3n a 1.0.0-SNAPSHOT . El sufijo SNAPSHOT indica en desarrollo . Cuando hagamos el release de la versi\u00f3n 1.0.0 eliminaremos el sufijo. Realiza el commit y s\u00fabelo a GitHub: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ git add build.sbt $ git status On branch acerca-de Your branch is up to date with origin/acerca-de . Changes to be committed: (use git reset HEAD file ... to unstage) modified: build.sbt $ git commit -m Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 [acerca-de f6180cc] Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 1 file changed, 2 insertions(+), 2 deletions(-) $ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 367 bytes | 367.00 KiB/s, done. Total 3 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 2 local objects. To https://github.com/mads-ua-18/todolist-2018-domingogallardo2.git 6767016..a332017 acerca-de - acerca-de Consulta en GitHub que el commit se ha subido en GitHub: De esta forma habr\u00e1s comprobado que tienes permiso de escritura en el repositorio y que ya puedes comenzar a realizar la pr\u00e1ctica. Si ahora vuelves a lanzar la m\u00e1quina Docker en el proyecto, ver\u00e1s que ha cambiado el nombre del proyecto (en el panel Sbt ): 1 2 3 4 $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework [info] Loading project definition from /code/project [info] Set current project to mads-todolist-dgallardo (in build file:/code/) [mads-todolist-dgallardo] $","title":"Primer commit"},{"location":"01-introduccion-play/introduccion-play/#segundo-commit","text":"En el segundo commit incluiremos el desarrollo de los elementos necesarios para la p\u00e1gina acerca de : Ruta Acci\u00f3n en controller Vista Realiza los siguientes cambios. Fichero conf/routes : 1 2 3 4 5 6 7 GET /equipos/addUsuario controllers.EquipoController.formularioAddUsuarioEquipo() POST /equipos/addUsuario controllers.EquipoController.addUsuarioEquipo() + GET /about controllers.HomeController.about() # Map static resources from the /public folder to the /assets URL path GET /assets/*file controllers.Assets.versioned(path= /public , file: Asset) Fichero app/controllers/HomeController.java : 1 2 3 4 5 6 7 8 public Result index() { return ok(index.render( Your new application is ready. )); } + public Result about() { + return ok(about.render()); + } } Fichero app/views/about.scala.html : 1 2 3 4 5 6 7 8 9 10 +@main( Acerca de ) { + div class= container-fluid + h1 ToDo List /h1 + ul + li Desarrollada por Domingo Gallardo /li + li Versi\u00f3n 1.0.0 (en desarrollo) /li + li Fecha de release: pendiente de release /li + /ul + /div +} Prueba la p\u00e1gina accediendo a la url http://localhost:9000/about . Por \u00faltimo, confirma el commit en la rama y s\u00fabelo a GitHub. En el panel Git : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ git add . $ git status On branch acerca-de Your branch is up to date with origin/acerca-de . Changes to be committed: (use git reset HEAD file ... to unstage) modified: app/controllers/HomeController.java new file: app/views/about.scala.html modified: conf/routes $ git commit -m A\u00f1adida ruta, vista y controller about [acerca-de 2831312] A\u00f1adida ruta, vista y controller about 3 files changed, 14 insertions(+) create mode 100644 app/views/about.scala.html $ git push","title":"Segundo commit"},{"location":"01-introduccion-play/introduccion-play/#tercer-commit","text":"En el tercer commit pondremos un enlace a la p\u00e1gina acerca de en la p\u00e1gina de login de la aplicaci\u00f3n. Realiza el siguiente cambio: Fichero app/views/formLogin.scala.html : 1 2 3 4 a class= btn btn-link href= @routes.UsuarioController.registroUsuario() Ir a registro /a /p + p a class= btn btn-link href= @routes.HomeController.about() Acerca de /a /p } Prueba que funciona correctamente, haz el commit y s\u00fabelo a GitHub: 1 2 3 4 $ git commit -am A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login [acerca-de 672c28f] A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login 1 file changed, 1 insertion(+) $ git push","title":"Tercer commit"},{"location":"01-introduccion-play/introduccion-play/#415-pull-request","text":"Una vez terminada la implementaci\u00f3n de la feature en la rama, creamos un pull request en GitHub para indicar que estamos listos para mezclar la rama con la feature con la rama principal de desarrollo ( master ). M\u00e1s adelante a\u00f1adiremos al pull request una comprobaci\u00f3n autom\u00e1tica de las pruebas y una revisi\u00f3n de c\u00f3digo por parte de compa\u00f1eros del equipo. Por ahora haremos nosotros ambas tareas. Vamos a verlo paso a paso. Empezamos por mezclar la rama de forma local con master , antes de hacer el pull request en GitHub, para probar que no se ha roto nada (todos los tests deben seguir pasando) y que los tests que hemos a\u00f1adido tambi\u00e9n funcionan correctamente (en este caso no hemos a\u00f1adido ninguno). En el panel Git : 1 2 3 4 5 6 7 8 9 10 11 12 13 $ git checkout master Switched to branch master Your branch is up to date with origin/master . $ git merge acerca-de Updating 6767016..672c28f Fast-forward app/controllers/HomeController.java | 4 ++++ app/views/about.scala.html | 8 ++++++++ app/views/formLogin.scala.html | 1 + build.sbt | 4 ++-- conf/routes | 2 ++ 5 files changed, 17 insertions(+), 2 deletions(-) create mode 100644 app/views/about.scala.html En el panel Sbt : 1 2 3 4 5 [mads-todolist-dgallardo] $ test ... [info] Passed: Total 35, Failed 0, Errors 0, Passed 35 [success] Total time: 71 s, completed Sep 6, 2018 10:04:55 AM [mads-todolist-dgallardo] $ Una vez que hemos comprobado que todo funciona bien, deshacemos el merge que acabamos de realizar en la rama master , ya que actualizaremos despu\u00e9s la rama con el resultado del pull request en GitHub: 1 2 3 4 5 $ git reset --hard origin/master HEAD is now at 6767016 Commit inicial $ git checkout acerca-de Switched to branch acerca-de Your branch is up to date with origin/acerca-de . Ya podemos crear el pull request en GitHub. Accede a la rama y comprueba que est\u00e1n todos los cambios pulsando Compare . Pulsa despu\u00e9s el bot\u00f3n New pull request para crear el pull request . Introduce el nombre del pull request , el comentario, el milestone y la etiqueta. Copia los datos del issue , y en el comentario escribe 1 Closes #1 De esta forma, cuando se cierre el pull request se cerrar\u00e1 autom\u00e1ticamente el issue . El n\u00famero #1 lo convierte GitHub en un enlace al issue correspondiente. De esta forma podemos examinar el issue resuelto por el PR. A\u00f1ade tambi\u00e9n el PR al tablero del proyecto. Se colocar\u00e1 autom\u00e1ticamente la columna In pull request . Entra en el proyecto y archiva la tarjeta con el issue , ya que la actividad de desarrollar la feature queda representada por el pull request . En este momento se deber\u00eda hacer una revisi\u00f3n del c\u00f3digo del pull request y comprobar de forma autom\u00e1tica que la integraci\u00f3n con master no introduce errores en los tests. Lo haremos en siguientes pr\u00e1cticas. GitHub informa de que no hay conflictos con la rama master y que es posible hacer el merge. Pulsa el bot\u00f3n de Merge y conf\u00edrmalo. Borra la rama en GitHub, pulsando el bot\u00f3n correspondiente. Por \u00faltimo, este merge lo has hecho en GitHub, debes integrarlo en tu repositorio local. En la pesta\u00f1a de Git: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 $ git checkout master $ git fetch remote: Counting objects: 1, done. remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (1/1), done. From https://github.com/mads-ua-18/todolist-2018-domingogallardo2 6767016..9527ae2 master - origin/master $ git pull Updating 6767016..9527ae2 Fast-forward app/controllers/HomeController.java | 4 ++++ app/views/about.scala.html | 8 ++++++++ app/views/formLogin.scala.html | 1 + build.sbt | 4 ++-- conf/routes | 2 ++ 5 files changed, 17 insertions(+), 2 deletions(-) create mode 100644 app/views/about.scala.html $ git branch -d acerca-de Deleted branch acerca-de (was 672c28f). $ git remote prune origin Pruning origin URL: https://github.com/mads-ua-18/todolist-2018-domingogallardo2.git * [pruned] origin/acerca-de $ git log --oneline --graph --all * 9527ae2 (HEAD - master, origin/master, origin/HEAD) Merge pull request #2 from mads-ua-18/acerca-de |\\ | * 672c28f A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login | * 3fdfb83 A\u00f1adida ruta, vista y controller about | * a332017 Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 |/ * 6767016 Commit inicial Comprobamos tambi\u00e9n la historia de commits en GitHub. Aparecer\u00e1 el commit de merge introducido por el pull request . De esta forma hemos cerrado el PR e integrado su c\u00f3digo en la rama principal de desarrollo. En el tablero de proyecto debe haber cambiado la tarjeta con el PR a la columna Done .","title":"4.1.5. Pull request"},{"location":"01-introduccion-play/introduccion-play/#416-version-100","text":"Por \u00faltimo creamos el release 1.0.0. Haremos un commit directamente sobre la rama master (m\u00e1s adelante explicaremos una forma m\u00e1s elaborada de hacer un release , cuando expliquemos el flujo de trabajo de GitFlow). Crea un commit con la confirmaci\u00f3n del n\u00famero de versi\u00f3n y fecha en los ficheros build.sbt y about.scala.html Fichero build.sbt : 1 2 3 4 5 6 name := mads-todolist-dgallardo -version := 1.0.0-SNAPSHOT +version := 1.0.0 lazy val root = (project in file( . )).enablePlugins(PlayJava) Fichero app/views/about.scala.html : 1 2 3 4 5 6 7 8 9 h1 ToDo List /h1 ul li Desarrollada por Domingo Gallardo /li - li Versi\u00f3n 1.0.0 (en desarrollo) /li - li Fecha de release: pendiente de release /li + li Versi\u00f3n 1.0.0 /li + li Fecha de release: 6/9/2018 /li /ul } A\u00f1adimos el commit y lo subimos a GitHub 1 2 3 4 5 $ git add . $ git commit -m Cambio de versi\u00f3n a 1.0.0 [master 61d4ac8] Cambio de versi\u00f3n a 1.0.0 2 files changed, 3 insertions(+), 3 deletions(-) $ git push Y, por \u00faltimo, creamos la versi\u00f3n 1.0.0 en GitHub pulsando en el enlace release en la p\u00e1gina principal (pesta\u00f1a Code ). Un release en GitHub se guarda como una una etiqueta Git, junto con informaci\u00f3n asociada. Se suelen indicar las nuevas features a\u00f1adidas en el release mediante enlaces a los pull requests a\u00f1adidos. Tambi\u00e9n a\u00f1adiremos enlaces a la p\u00e1gina de la Wiki en la que se describe la caracter\u00edstica. El resultado ser\u00e1:","title":"4.1.6. Versi\u00f3n 1.0.0"},{"location":"01-introduccion-play/introduccion-play/#42-version-110","text":"El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 2 opcionales: Barra de men\u00fa, obligatoria. P\u00e1gina de equipos de un usuario, obligatoria. P\u00e1gina de descripci\u00f3n de un equipo con el listado de usuarios que participan en \u00e9l, obligatoria. (Opcional) Usuario administrador que gestiona los equipos Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio.","title":"4.2. Versi\u00f3n 1.1.0"},{"location":"01-introduccion-play/introduccion-play/#barra-de-menu","text":"La aplicaci\u00f3n deber\u00e1 tener una barra de men\u00fa com\u00fan a todas sus p\u00e1ginas, menos en las p\u00e1ginas de login y registro. La barra de men\u00fa estar\u00e1 situada en la parte superior de la p\u00e1gina y ser\u00e1 un Navbar . de Bootstrap. La barra de men\u00fa tendr\u00e1 como m\u00ednimo los siguientes elementos (de izquierda a derecha): ToDoList : enlace a la p\u00e1gina acerca de . Tareas : enlace a la p\u00e1gina de tareas, con la lista de tareas pendientes del usuario. Equipos : enlace a la p\u00e1gina de equipos, con el listado de equipos al que pertenece el usuario. Nombre usuario : A la derecha de la p\u00e1gina. Desplegable con las opciones: Cuenta : Futura p\u00e1gina para gestionar la cuenta Cerrar sesi\u00f3n nombre usuario : cierra la sesi\u00f3n y lleva a la p\u00e1gina de login.","title":"Barra de men\u00fa"},{"location":"01-introduccion-play/introduccion-play/#equipos-de-un-usuario","text":"Cuando el usuario pinche en la opci\u00f3n Equipos del men\u00fa ir\u00e1 a una p\u00e1gina con un listado del equipo a los que pertenece. El listado de equipos ser\u00e1 una tabla similar al listado de tareas, pero sin acciones. La ruta para obtener el listado de los equipos de un usuario ser\u00e1 /usuarios/:id/equipos . Al igual que el listado de tareas, la ruta estar\u00e1 protegida para que s\u00f3lo pueda acceder un usuario logeado y siendo el usuario logeado el mismo que el id .","title":"Equipos de un usuario"},{"location":"01-introduccion-play/introduccion-play/#descripcion-de-equipo","text":"En la lista de equipos de un usuario los equipos tendr\u00e1n un enlace para acceder a su descripci\u00f3n. En la descripci\u00f3n de un equipo aparecer\u00e1: su nombre y el listado de personas del equipo. La ruta para obtener la descripci\u00f3n de un equipo ser\u00e1 /equipos/:id . La ruta estar\u00e1 protegida para que s\u00f3lo pueda acceder un usuario logeado.","title":"Descripci\u00f3n de equipo"},{"location":"01-introduccion-play/introduccion-play/#usuario-administrador-opcional","text":"Al realizar el registro ser\u00e1 posible darse de alta como usuario administrador. Para darse de alta como administrador se deber\u00e1 activar un check box en la p\u00e1gina de registro. S\u00f3lo puede haber un administrador. Si ya existe un administrador, no debe aparecer el check box en la p\u00e1gina de registro. El usuario administrador tendr\u00e1 una barra de men\u00fa en la que se a\u00f1adir\u00e1 la opci\u00f3n vac\u00eda Administraci\u00f3n (que iremos cambiando conforme a\u00f1adamos funcionalidades a realizar por el administrador).","title":"Usuario administrador (opcional)"},{"location":"01-introduccion-play/introduccion-play/#gestion-equipos-por-usuario-administrador-opcional","text":"El usuario administrador podr\u00e1 gestionar los equipos: a\u00f1adir y editar equipos (la opci\u00f3n de borrar la dejamos para m\u00e1s adelante). El administrador tendr\u00e1 una opci\u00f3n adicional del men\u00fa llamada Administraci\u00f3n de la que se desplegar\u00e1n la opci\u00f3n Equipos . En la administraci\u00f3n de equipos se entrar\u00e1 en una p\u00e1gina donde se mostrar\u00e1 un listado de todos los equipos existentes (como el listado de tareas) y se dar\u00e1 la opci\u00f3n de a\u00f1adir y editar. En la p\u00e1gina de edici\u00f3n de un equipo se podr\u00e1 modificar su nombre y aparecer\u00e1 una tabla con todos los usuarios. Se podr\u00e1 eliminar usuarios del equipo o a\u00f1adir nuevos usuarios al mismo. Los usuarios a a\u00f1adir se escoger\u00e1n de un desplegable en el que se mostrar\u00e1n todos los usuarios no pertenecientes a un equipo.","title":"Gesti\u00f3n equipos por usuario administrador (opcional)"},{"location":"01-introduccion-play/introduccion-play/#5-entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 9 de octubre. La parte obligatoria punt\u00faa sobre 7 y la opcional sobre 3 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 9% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un clean . Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"5. Entrega y evaluaci\u00f3n"},{"location":"02-pruebas-tdd/pruebas-tdd/","text":"Pr\u00e1ctica 2: Gesti\u00f3n de configuraciones y TDD con Play Framework 1. Objetivos 1.2. Refactorizaci\u00f3n de la obtenci\u00f3n de las tareas de usuario 2. Tests en Play Framework 2.1. JUnit 2.2. Tests con bases de datos y JPA 2.3. Nuevo issue con tests 3. Definici\u00f3n de configuraciones 3.1. Configuraci\u00f3n de pruebas de integraci\u00f3n 3.2. Configuraci\u00f3n de stage 4. Nueva historia de usuario: tableros (usando TDD) 4.1. Primer issue : Modelo de tablero y repositorio b\u00e1sico 4.2. Tests de integraci\u00f3n antes de cerrar el issue y confirmar el pull request 4.3. Resto de issues (parte obligatoria) 4.4 Resto de issues (parte opcional) 4.5. Finalizaci\u00f3n de la versi\u00f3n 0.2 5. Entrega y evaluaci\u00f3n 1. Objetivos Esta pr\u00e1ctica tiene dos objetivos principales: profundizar en las caracter\u00edsticas de Play Framework relacionadas con las pruebas y utilizar la metodolog\u00eda TDD para a\u00f1adir funcionalidades a nuestra aplicaci\u00f3n. Al igual que la primera pr\u00e1ctica, el desarrollo de esta pr\u00e1ctica ser\u00e1 individual. Tendr\u00e1 una duraci\u00f3n de 3 semanas, siendo la fecha l\u00edmite de entrega el 24 de octubre . Seguiremos trabajando en la aplicaci\u00f3n mads-todolist que has estado desarrollando en la primera pr\u00e1ctica. Continuaremos tambi\u00e9n trabajando con Git como sistema de control de versiones y GitHub como repositorio remoto. Intregraremos Git y TDD, haciendo que cada commit represente un incremento funcional en el desarrollo de la aplicaci\u00f3n y contenga y pase sus propios tests. 1.2. Refactorizaci\u00f3n de la obtenci\u00f3n de las tareas de usuario Antes de empezar la pr\u00e1ctica, vamos a hacer una refactorizaci\u00f3n de un c\u00f3digo mejorable introducido en la pr\u00e1ctica 1. Se trata del c\u00f3digo que recupera la lista de tareas de un usuario. La pod\u00e9is encontrar en el [PR 34](https://github.com/domingogallardo/mads-todolist-guia/pull/34), echadle un vistazo a los cambios y hacedlo tambi\u00e9n en vuestro proyecto. Un usuario tiene una relaci\u00f3n a-muchos con tareas. La refactorizaci\u00f3n consiste en hacer que al recuperar un usuario, JPA se traiga a memoria todas sus tareas y se queden guardadas en su atributo tareas . Para ello basta con poner en la entidad el atributo de JPA fetch=FetchType.EAGER . De esta forma evitamos el m\u00e9todo findAllTareas(usuarioId) en el TareaRepository . En t\u00e9rminos de Domain-Driven Design (un m\u00e9todo de dise\u00f1o muy interesante, que os recomiendo que aprend\u00e1is) estamos hablando de que Usuario y Tareas son entidades agregadas . Siempre tendremos en memoria en los objetos usuario su lista completa de tareas. Un libro muy recomendable para aprender sobre DDD es Patterns, Principles, and Practices of Domain-Driven Design . 2. Tests en Play Framework Play Framework en Java utiliza JUnit como framework de testing. Los siguientes enlaces proporcionan informaci\u00f3n inicial sobre testing en Play Framework. No vamos a entrar en profundidad en todas las posibilidades ( mocking , inyecci\u00f3n de dependencias, etc.), s\u00f3lo aprender lo necesario para definir algunos tests que sean \u00fatiles. A pesar que Play permite una gran flexibilidad a la hora de testear sus distintos elementos, s\u00f3lo vamos a realizar tests de la capa de persistencia (clases Repository) y de la capa de servicios . Testing your application Testing with databases Todos los tests se incluyen en el directorio tests . Podemos lanzar todos los tests desde la consola sbt 1 [mads-todolist-2017] $ test Y tambi\u00e9n podemos lanzar s\u00f3lo los tests definidos en una clase: 1 [mads-todolist-2017] $ testOnly TareaServiceTest O utilizar un comod\u00edn * para ejecutar s\u00f3lo un conjunto de tests cuyas clases comiencen por una cadena: 1 [mads-todolist-2017] $ testOnly Tarea* Y para lanzar s\u00f3lo los tests que han fallado: 1 [mads-todoslist] $ testQuick En Play es posible lanzar tests sobre ejecuciones de la aplicaci\u00f3n con la sentencia withApplication (aunque no lo vamos a hacer). De esta forma no es necesario crear mocks ni stubs (aunque es posible hacerlo, si queremos mejorar el rendimiento de la ejecuci\u00f3n de los tests o aislar el c\u00f3digo a probar del resto de componentes y recursos). 2.1. JUnit Los tests se construyen usando JUnit: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import static org.junit.Assert.* ; import org.junit.Test ; public class SimpleTest { @Test public void testSum () { int a = 1 + 1 ; assertEquals ( 2 , a ); } @Test public void testString () { String str = Hello world ; assertFalse ( str . isEmpty ()); } } 2.2. Tests con bases de datos y JPA Conexi\u00f3n de JPA con una base de datos en memoria Lo habitual para realizar tests unitarios que necesiten trabajar con una base de datos es, o bien mockear la base de datos, o bien utilizar una base de datos en memoria (como H2) para que los tests puedan ejecutarse mucho m\u00e1s r\u00e1pido sin necesidad de una base de datos real que trabaje sobre el disco duro. En la primera pr\u00e1ctica hemos utilizado el segundo enfoque. El problema de los tests tal y como est\u00e1n escritos en la primera pr\u00e1ctica es que la base de datos de prueba sobre la que trabajan no se puede definir en el fichero de configuraci\u00f3n, sino que est\u00e1 definida en su c\u00f3digo fuente. En concreto, la base de datos de memoria la creamos manualmente con la instrucci\u00f3n Databases.inMemoryWith() pasando un nombre JNDI con el que inicializarla ( DBTest ). Y despu\u00e9s obtenemos el JPAApi obteniendo la configuraci\u00f3n de JPA memoryPersistenceUnit . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class UsuarioServiceTest { static Database db ; static JPAApi jpaApi ; @BeforeClass static public void initDatabase () { // Inicializamos la BD en memoria y su nombre JNDI db = Databases . inMemoryWith ( jndiName , DBTest ); ... // Activamos en JPA la unidad de persistencia memoryPersistenceUnit // declarada en META-INF/persistence.xml y obtenemos el objeto // JPAApi jpaApi = JPA . createFor ( memoryPersistenceUnit ); } ... @Test public void crearNuevoUsuarioCorrectoTest (){ UsuarioRepository repository = new JPAUsuarioRepository ( jpaApi ); UsuarioService usuarioService = new UsuarioService ( repository ); Usuario usuario = usuarioService . creaUsuario ( luciaruiz , lucia.ruiz@gmail.com , 123456 ); assertNotNull ( usuario . getId ()); assertEquals ( luciaruiz , usuario . getLogin ()); assertEquals ( lucia.ruiz@gmail.com , usuario . getEmail ()); assertEquals ( 123456 , usuario . getPassword ()); } Recordemos que el perfil memoryPersistenceUnit est\u00e1 definido en el fichero conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 persistence-unit name= memoryPersistenceUnit transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTest /non-jta-data-source properties property name= hibernate.dialect value= org.hibernate.dialect.H2Dialect / property name= hibernate.hbm2ddl.auto value= update / /properties /persistence-unit La anotaci\u00f3n @BeforeClass hace que el m\u00e9todo est\u00e1tico initDatabase() se ejecute una \u00fanica vez antes de todos los tests y guarde en las variables de clase la base de datos y el JPAApi obtenido. Estas dos variables se utilizar\u00e1n m\u00e1s adelante. Inicializaci\u00f3n de la base de datos con DBUnit Para poder inicializar la base de datos con un conjunto de datos previos utilizamos la librer\u00eda DBUnit. La dependencia de la librer\u00eda se declara en el fichero build.sbt 1 2 3 4 5 6 7 8 ... libraryDependencies += javaJpa libraryDependencies += org.hibernate % hibernate-core % 5.2.5.Final libraryDependencies += mysql % mysql-connector-java % 5.1.18 libraryDependencies += org.dbunit % dbunit % 2.4.9 ... Los datos iniciales de la base de datos se definen en un fichero de configuraci\u00f3n XML. Fichero test/resources/usuarios_dataset.xml : 1 2 3 4 5 6 7 ?xml version= 1.0 encoding= UTF-8 ? dataset Usuario id= 1000 login= juangutierrez nombre= Juan apellidos= Gutierrez password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / Tarea id= 1000 titulo= Renovar DNI usuarioId= 1000 / Tarea id= 1001 titulo= Pr\u00e1ctica 1 MADS usuarioId= 1000 / /dataset Cada l\u00ednea XML define un dato en la tabla con el nombre indicado. Por ejemplo, en el fichero anterior se define un usuario y dos tareas. DbUnit se encarga de convertir los atributos en los tipos correspondientes a los definidos en las tablas cuando se realiza la inserci\u00f3n. Hay que hacer notar que en DBUnit hay que definir las fechas con el formato AAAA-MM-DD . Para realizar la inserci\u00f3n en la base de datos con la que van a trabajar los tests se ejecuta la siguiente funci\u00f3n: 1 2 3 4 5 6 7 8 @Before public void initData () throws Exception { JndiDatabaseTester databaseTester = new JndiDatabaseTester ( DBTest ); IDataSet initialDataSet = new FlatXmlDataSetBuilder (). build ( new FileInputStream ( test/resources/usuarios_dataset.xml )); databaseTester . setDataSet ( initialDataSet ); databaseTester . setSetUpOperation ( DatabaseOperation . CLEAN_INSERT ); databaseTester . onSetup (); } Se obtiene la base de datos a trav\u00e9s de su nombre JNDI. Y despu\u00e9s se cargan los datos realizando una operaci\u00f3n CLEAN_INSERT . En este tipo de operaci\u00f3n DbUnit borra todos los datos de todas las tablas que aparecen en el fichero XML y despu\u00e9s realiza la inserci\u00f3n. La etiqueta @Before hace que la funci\u00f3n se ejecute antes de cada test. 2.3. Nuevo issue con tests Crea un nuevo issue (y una rama, y despu\u00e9s un pull request para integrarlo con master, igual que en la pr\u00e1ctica 1) con la descripci\u00f3n Nuevos tests pr\u00e1ctica 2 . Puedes ponerle la etiqueta tech . Para completar el issue debes hacer lo siguiente: A\u00f1ade un usuario y una tarea en el fichero XML. Crea una nueva clase de tests el directorio test/practica2 con el nombre Practica2Test . A\u00f1ade en \u00e9l 4 nuevos tests que comprueben condiciones que no hemos comprobado en la pr\u00e1ctica 1. Ejemplos: Test que comprueba que el m\u00e9todo findUsuarioPorId de UsuarioService devuelve null si se le pasa un identificador no existente. Test que comprueba que el m\u00e9todo borraTarea de TareaService lanza una excepci\u00f3n si se le pasa un identificador de tarea no existente. 3. Definici\u00f3n de configuraciones Hemos comprobado en la pr\u00e1ctica 1 que el fichero application.conf sirve para definir la configuraci\u00f3n con la que se va ejecutar la aplicaci\u00f3n Play. Hemos definido en \u00e9l la base de datos en memoria H2 con la que se ejecuta la aplicaci\u00f3n. Esta configuraci\u00f3n es la que denominamos configuraci\u00f3n de desarrollo , que es la configuraci\u00f3n por defecto utilizada durante el desarrollo de la aplicaci\u00f3n. Vamos a ver en este apartado c\u00f3mo definir configuraciones alternativas en las que ejecutar los tests: Configuraci\u00f3n de integraci\u00f3n : configuraci\u00f3n que se utilizaremos en las pruebas de integraci\u00f3n. Estar\u00e1 constituida por una base de datos MySQL contendr\u00e1 los datos introducidos por los tests. El hecho de trabajar con MySQL en lugar de la base de datos de memoria har\u00e1 que esta configuraci\u00f3n sea m\u00e1s parecida a la que se utiliza en el despliegue real en producci\u00f3n de la aplicaci\u00f3n. Configuraci\u00f3n de stage : configuraci\u00f3n muy similar a la de producci\u00f3n en la que se realizar\u00e1n pruebas funcionales. Estar\u00e1 formada por una base de datos MySQL con datos estables que se ir\u00e1n a\u00f1adiendo en los tests funcionales, creando un entorno muy similar al de producci\u00f3n. Lanzaremos los tests en la configuraci\u00f3n de integraci\u00f3n. Y ejecutaremos la aplicaci\u00f3n para lanzar pruebas funcionales en la configuraci\u00f3n de stage . 3.1. Configuraci\u00f3n de pruebas de integraci\u00f3n Empezaremos solucionando un problema importante de los tests: conseguir que carguen el fichero de configuraci\u00f3n, en lugar de definir en el c\u00f3digo las conexiones a la base de datos. Despu\u00e9s a\u00f1adiremos un fichero de configuraci\u00f3n de conexi\u00f3n con una base de datos MySQL y veremos c\u00f3mo lanzar los tests para que usen esa configuraci\u00f3n. Nuevo issue: Configuraci\u00f3n entorno de integraci\u00f3n Debes crear un nuevo issue con la descripci\u00f3n Configuraci\u00f3n entorno de integraci\u00f3n en el que deber\u00e1s incluir los cambios que se indiquen los siguientes apartados. Puedes ponerle la etiqueta tech . Crea una rama en la que desarrolles este nuevo issue . Refactorizaci\u00f3n de los tests Vamos a ver c\u00f3mo refactorizar los tests para que se lancen sobre una base de datos definida en el fichero de configuraci\u00f3n. Problema: los tests no usan el fichero de configuraci\u00f3n El problema de los tests tal y como est\u00e1n escritos en la actualidad es que la base de datos de prueba sobre la que trabajan no se puede definir en el fichero de configuraci\u00f3n, sino que est\u00e1 definida en su c\u00f3digo fuente. Como hemos visto anteriormente, la base de datos se inicializa a mano, obteni\u00e9ndose el JPAApi usando una configuraci\u00f3n concreta: 1 2 3 4 5 6 7 8 9 @BeforeClass static public void initDatabase () { // Inicializamos la BD en memoria y su nombre JNDI db = Databases . inMemoryWith ( jndiName , DBTest ); ... // Activamos en JPA la unidad de persistencia memoryPersistenceUnit // declarada en META-INF/persistence.xml y obtenemos el objeto // JPAApi jpaApi = JPA . createFor ( memoryPersistenceUnit ); Despu\u00e9s, en cada test, usamos el jpaApi obtenido para construir un service o un repostory : 1 2 3 4 5 6 7 8 9 10 @Test public void crearNuevoUsuarioCorrectoTest (){ UsuarioRepository repository = new JPAUsuarioRepository ( jpaApi ); UsuarioService usuarioService = new UsuarioService ( repository ); Usuario usuario = usuarioService . creaUsuario ( luciaruiz , lucia.ruiz@gmail.com , 123456 ); assertNotNull ( usuario . getId ()); assertEquals ( luciaruiz , usuario . getLogin ()); assertEquals ( lucia.ruiz@gmail.com , usuario . getEmail ()); assertEquals ( 123456 , usuario . getPassword ()); } Este c\u00f3digo hace que los tests sean poco configurables ya que no estamos obteniendo la base de datos definida en el fichero de configuraci\u00f3n. Si queremos cambiar la base de datos sobre la que trabajan los tests hay que modificar el propio c\u00f3digo fuente. Refactorizaci\u00f3n de los tests Vamos a modificar el c\u00f3digo para que la base de datos que se utilice no est\u00e9 escrita a fuego en el c\u00f3digo, sino que sea la definida en el fichero de configuraci\u00f3n. De esta forma, modificando el fichero modificaremos tambi\u00e9n la configuraci\u00f3n de los tests. Para conseguirlo haremos en los tests igual que en la aplicaci\u00f3n: obteniendo la JPAApi mediante la inyecci\u00f3n de dependencias. El problema es que las anotaciones @inject no funcionan en los tests. Los tests son programas Java independientes que se ejecutan al margen de la aplicaci\u00f3n principal, que es donde se ejecuta el c\u00f3digo que inicializa los objetos inyectados. Tenemos nosotros que obtener a mano los objetos llamando expl\u00edcitamente a la librer\u00eda Guice que es la que gestiona la inyecci\u00f3n de dependencias. A continuaci\u00f3n vemos c\u00f3mo hacerlo en un test concreto, por ejemplo en el fichero UsuarioServiceTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class UsuarioServiceTest { static private Injector injector ; @BeforeClass static public void initApplication () { GuiceApplicationBuilder guiceApplicationBuilder = new GuiceApplicationBuilder (). in ( Environment . simple ()); injector = guiceApplicationBuilder . injector (); // Instanciamos un JPAApi para que inicializar JPA injector . instanceOf ( JPAApi . class ); } private UsuarioService newUsuarioService () { return injector . instanceOf ( UsuarioService . class ); } @Test public void crearNuevoUsuarioCorrectoTest (){ UsuarioService usuarioService = newUsuarioService (); Usuario usuario = usuarioService . creaUsuario ( luciaruiz , lucia.ruiz@gmail.com , 123456 ); assertNotNull ( usuario . getId ()); assertEquals ( luciaruiz , usuario . getLogin ()); assertEquals ( lucia.ruiz@gmail.com , usuario . getEmail ()); assertEquals ( 123456 , usuario . getPassword ()); } ... } En el c\u00f3digo anterior la creaci\u00f3n de un GuiceApplicationBuilder con un entorno simple realiza una inicializaci\u00f3n de la aplicaci\u00f3n Play con el fichero de configuraci\u00f3n por defecto. Despu\u00e9s se obtiene un objeto Injector que usamos para obtener instancias de clases mediante la inyecci\u00f3n de dependencias. En concreto, el m\u00e9todo newUsuarioService() obtiene del inyector una instancia de un UsuarioService . A este m\u00e9todo se llama en cada test para obtener un UsuarioService del que probar sus m\u00e9todos. Commit: Refactorizaci\u00f3n de los tests Debes crear un nuevo commit en la rama reci\u00e9n creada con la descripci\u00f3n Refactorizados tests en el que deber\u00e1s refactorizar todos los tests para que se obtengan los objetos necesarios usando inyecci\u00f3n de dependencias. Para ello realiza todos los cambios en los ficheros de tests que aparecen en el [PR 27](https://github.com/domingogallardo/mads-todolist-guia/pull/27/files) de la pr\u00e1ctica gu\u00eda. No modifiques por ahora el fichero de configuraci\u00f3n, ni crees nuevos tests (aunque son modificaciones que aparecen en el PR, no las debes hacer). Una vez hecho esto deber\u00e1s comprobar que los tests funcionan correctamente los tests con la configuraci\u00f3n original (base de datos en memoria H2 ) y a\u00f1adir en otro commit cambios para que los tests carguen una configuraci\u00f3n de base de datos alternativa, como una base de datos MySQL. En el siguiente apartado vemos c\u00f3mo hacerlo. Ejecuci\u00f3n de tests con base de datos MySQL Vamos a ver c\u00f3mo lanzar una base de datos MySQL y c\u00f3mo definir el fichero de configuraci\u00f3n para que la aplicaci\u00f3n Play se conecte a ella. Ejecuci\u00f3n de una base de datos MySQL con un contenedor Docker En primer lugar vamos a ver c\u00f3mo lanzar la base de datos MySQL. Podr\u00edamos realizar una instalaci\u00f3n de MySQL en nuestro ordenador, pero vamos a usar tambi\u00e9n Docker en lugar de ello. Utilizaremos la imagen MySQL . Para lanzar un contenedor con la imagen anterior ejecutamos el siguiente comando: 1 $ docker run -d --rm -p 3306:3306 --name play-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql Este comando lanza un contenedor que crea una base de datos llamada mads y con la contrase\u00f1a de root mads . Le da el nombre play-mysql que despu\u00e9s usaremos para enlazar con el contenedor de Play. La opci\u00f3n -p 3306:3306 permite acceder a la base de datos desde el host (lo veremos m\u00e1s adelante). Podemos comprobar que el contenedor est\u00e1 funcionando con el comando docker container ls : 1 2 3 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7c1bed0b5b7e mysql docker-entrypoint... 6 seconds ago Up 4 seconds 0.0.0.0:3306- 3306/tcp play-mysql El comando docker container ls lista los contenedores activos. Podemos usar el identificador o el nombre del contenedor para pararlo: 1 $ docker container stop play-mysql Una vez parado se borrar\u00e1 autom\u00e1ticamente por haber usado la opci\u00f3n --rm en su lanzamiento. (en el caso de no usar esta opci\u00f3n tendremos que borrarlo nosotros manualmente con el comando docker container rm play-mysql ). Ejecuci\u00f3n de los tests con la base de datos MySQL Para ejecutar los tests con la base de datos MySQL vamos a definir un nuevo fichero de configuraci\u00f3n que llamaremos integration.conf . Utilizaremos una caracter\u00edstica del sistema de configuraci\u00f3n de Play en la que podemos dar a las variables los valores definidos por variables de entorno usando la sintaxis: 1 variable = ${?VARIABLE_ENTORNO} El nuevo fichero de configuraci\u00f3n es el siguiente: Fichero conf/integration.conf 1 2 3 4 5 6 7 8 include application.conf jpa.default = mySqlPersistenceUnit db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} En primer lugar el fichero incluye la configuraci\u00f3n por defecto application.conf y despu\u00e9s modifica el valor de las variables que nos interesan. En concreto inicializamos la conexi\u00f3n JPA por defecto al perfil mySqlPersistenceUnit . Veremos m\u00e1s adelante la definici\u00f3n de este perfil en el fichero persistence.xml . Y despu\u00e9s definimos las variables necesarias para la conexi\u00f3n a una base de datos MySQL. Para que la configuraci\u00f3n sea flexible, obtenemos los valores de variables de entorno que estar\u00e1n definidas en el sistema en el que ejecutemos los tests de integraci\u00f3n. El fichero de configuraci\u00f3n de JPA debe quedar como sigue, a\u00f1adiendo el nuevo perfil de conexi\u00f3n con una base de datos MySQL (el perfil mySqlPersistenceUnit ): Fichero conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 persistence xmlns= http://xmlns.jcp.org/xml/ns/persistence xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd version= 2.1 !-- Memory persistence Unit -- persistence-unit name= memoryPersistenceUnit transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTest /non-jta-data-source properties property name= hibernate.dialect value= org.hibernate.dialect.H2Dialect / property name= hibernate.hbm2ddl.auto value= update / /properties /persistence-unit !-- MySQL Persistence Unit -- persistence-unit name= mySqlPersistenceUnit transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTest /non-jta-data-source properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= update / /properties /persistence-unit /persistence Cuando la aplicaci\u00f3n Play se conecte a la base de datos el esquema de datos de actualiza autom\u00e1ticamente debido al valor update en la propiedad hibernate.hbm2ddl.auto . Este valor indica que el esquema de datos de la base de datos se actualiza para ajustarse a las entidades definidas en la aplicaci\u00f3n. Por ejemplo, cuando se a\u00f1ade alg\u00fan atributo a alguna entidad, se a\u00f1ade autom\u00e1ticamente una columna m\u00e1s a la tabla correspondiente. Una vez realizados los cambios anteriores, y estando el contenedor docker MySQL en funcionamiento, podemos lanzar la aplicaci\u00f3n Play con el siguiente comando: 1 2 3 $ docker run --link play-mysql:mysql --rm -it -p 80:9000 -e \\ DB_URL= jdbc:mysql://play-mysql:3306/mads -e DB_USER_NAME= root -e \\ DB_USER_PASSWD= mads -v ${PWD}:/code domingogallardo/playframework /bin/bash La opci\u00f3n --link define el nombre del contenedor con el que enlazar en el que se est\u00e1 ejecutando MySQL y las opciones -e definen los valores de las variables de entorno que usar\u00e1 el fichero de configuraci\u00f3n. A\u00f1adimos /bin/bash al final para que sea este el comando que se ejecute en el contenedor, en lugar de sbt . Por ello el comando anterior lanzar\u00e1 un shell: 1 bash-4.3# Por \u00faltimo, s\u00f3lo nos falta llamar a sbt desde el shell para que cargue el nuevo fichero de configuraci\u00f3n y lance los tests: 1 bash-4.3# sbt ; set javaOptions += -Dconfig.file=conf/integration.conf ; test Tambi\u00e9n podr\u00edamos hacer un run o un testOnly : 1 2 $ sbt ; set javaOptions += -Dconfig.file=conf/integration.conf ; run $ sbt ; set javaOptions += -Dconfig.file=conf/integration.conf ; testOnly Integration* Una vez que compruebes que los tests funcionan correctamente con la base de datos MySQL puedes confirmar los cambios en un nuevo commit (puedes poner el mensaje A\u00f1adido integration.conf para conexi\u00f3n con BD Mysql ), sube el nuevo commit. Conexi\u00f3n a la base de datos desde el host Es posible conectarse al servicio en el hostname 127.0.0.1 y en el puerto 3306. Por ejemplo con el cliente MySQL desde el terminal: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ mysql -h 127.0.0.1 -u root -p ... mysql use mads; Database changed mysql show tables; +--------------------+ | Tables_in_mads | +--------------------+ | Tarea | | Usuario | | hibernate_sequence | +--------------------+ 3 rows in set (0,00 sec) mysql quit; O desde alguna herramienta como el MySQL Workbench , creando una conexi\u00f3n como muestra la siguiente imagen: Exportaci\u00f3n del esquema de datos Por \u00faltimo, vamos a terminar el issue a\u00f1adiendo al repositorio un fichero SQL con el esquema de datos. Una vez que hayas lanzado los tests JPA habr\u00e1 creado el esquema de datos en la base de datos MySQL que est\u00e1 corriendo en el contenedor play-mysql . Podemos entonces ejecutar el comando mysqldump dentro del contenedor: 1 $ docker exec play-mysql sh -c exec mysqldump --no-data mads -uroot -pmads schema.sql El comando anterior ejecuta el comando mysqldump en el contenedor docker que exporta el esquema de datos (sin los datos a\u00f1adidos) y lo graba el fichero schema.sql en el directorio actual. Ed\u00edtalo para eliminar el d\u00eda y la hora, ya que queremos que s\u00f3lo aparezca informaci\u00f3n estrictamente del esquema de la base de datos. Copia el fichero schema.sql en un nuevo directorio sql en la ra\u00edz del proyecto Play. De esta forma podremos comprobar m\u00e1s adelante las diferencias cuando modifiquemos la base de datos al evolucionar las entidades de la aplicaci\u00f3n. El fichero deber\u00eda ser parecido a este: Fichero sql/schema.sql : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 -- MySQL dump 10.13 Distrib 5.7.19, for Linux (x86_64) -- -- Host: localhost Database: mads -- ------------------------------------------------------ -- Server version 5.7.19 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */ ; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */ ; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */ ; /*!40101 SET NAMES utf8 */ ; /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */ ; /*!40103 SET TIME_ZONE= +00:00 */ ; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */ ; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */ ; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE= NO_AUTO_VALUE_ON_ZERO */ ; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */ ; -- -- Table structure for table `Tarea` -- DROP TABLE IF EXISTS ` Tarea ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Tarea ` ( ` id ` bigint ( 20 ) NOT NULL , ` titulo ` varchar ( 255 ) DEFAULT NULL , ` usuarioId ` bigint ( 20 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ), KEY ` FKepne2t52y8dmn8l9da0dd7l51 ` ( ` usuarioId ` ), CONSTRAINT ` FKepne2t52y8dmn8l9da0dd7l51 ` FOREIGN KEY ( ` usuarioId ` ) REFERENCES ` Usuario ` ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `Usuario` -- DROP TABLE IF EXISTS ` Usuario ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Usuario ` ( ` id ` bigint ( 20 ) NOT NULL , ` apellidos ` varchar ( 255 ) DEFAULT NULL , ` email ` varchar ( 255 ) DEFAULT NULL , ` fechaNacimiento ` date DEFAULT NULL , ` login ` varchar ( 255 ) DEFAULT NULL , ` nombre ` varchar ( 255 ) DEFAULT NULL , ` password ` varchar ( 255 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `hibernate_sequence` -- DROP TABLE IF EXISTS ` hibernate_sequence ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` hibernate_sequence ` ( ` next_val ` bigint ( 20 ) DEFAULT NULL ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; /*!40101 SET SQL_MODE=@OLD_SQL_MODE */ ; /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */ ; /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */ ; /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */ ; /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */ ; /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */ ; /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */ ; A\u00f1ade al final del fichero la inicializaci\u00f3n de la tabla de secuencias de Hibernate, necesaria para que Hibernate genere las claves primarias de las entidades: 1 2 3 4 5 6 7 8 9 10 -- -- Dumping data for table `hibernate_sequence` -- LOCK TABLES ` hibernate_sequence ` WRITE ; /*!40000 ALTER TABLE `hibernate_sequence` DISABLE KEYS */ ; INSERT INTO ` hibernate_sequence ` VALUES ( 1 ),( 1 ); /*!40000 ALTER TABLE `hibernate_sequence` ENABLE KEYS */ ; UNLOCK TABLES ; /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */ ; Realiza un \u00faltimo commit en el que se incluya el fichero schema.sql y cierra el issue con un pull request . 3.2. Configuraci\u00f3n de stage Una configuraci\u00f3n de stage es una configuraci\u00f3n de despliegue de la aplicaci\u00f3n preparada para que sea lo m\u00e1s similar posible al despliegue de producci\u00f3n. Se utiliza para realizar las pruebas funcionales y de rendimiento de la aplicaci\u00f3n. Una de las caracter\u00edsticas fundamentales de la configuraci\u00f3n de stage es que su gestor base de datos debe ser id\u00e9ntica al gestor de base de datos de producci\u00f3n, debe tener el mismo esquema de datos y contener datos similares (en cantidad y complejidad) a los que tiene la aplicaci\u00f3n en producci\u00f3n. Vamos a definir una configuraci\u00f3n de stage para nuestra aplicaci\u00f3n Play. Vamos a usar la misma imagen docker MySQL que en la configuraci\u00f3n de pruebas de integraci\u00f3n y una ejecuci\u00f3n de nuestra aplicaci\u00f3n Play en modo stage . Lo normal es definir la configuraci\u00f3n en un ordenador dedicado, y tenerla siempre en funcionamiento (de forma similar a como funciona la aplicaci\u00f3n en producci\u00f3n). En lugar de esto, para simplificar el proceso, vamos a hacer que la imagen MySQL cargue los datos que guardamos en cada nueva realizaci\u00f3n de pruebas funcionales. En cada ejecuci\u00f3n de pruebas funcionales se probar\u00e1n con los datos ya existentes y se a\u00f1adir\u00e1n nuevos datos para realizar nuevas pruebas. Al final de la sesi\u00f3n de pruebas funcionales grabaremos todos los datos en un fichero que volveremos a usar como datos iniciales la pr\u00f3xima vez que arranquemos la configuraci\u00f3n de stage . Tambi\u00e9n veremos c\u00f3mo usar sbt para desplegar y lanzar la aplicaci\u00f3n Play en modo stage . Nuevo issue: Configuraci\u00f3n entorno de stage Creamos un nuevo issue llamado Configuraci\u00f3n entorno stage . Puedes ponerle la etiqueta tech . Crea una rama en la que desarrolles este nuevo issue . Crea el fichero de conf/stage.conf : 1 2 3 4 5 6 7 8 9 10 include application.conf play.crypto.secret= abcdefghijkl jpa.default = mySqlPersistenceUnitProduction db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} A\u00f1ade en el fichero conf/META-INF/persistence.xml el nuevo perfil mySqlPersistenceUnitProduction . La \u00fanica diferencia (importante) con el perfil de integraci\u00f3n es que el hbm2ddl.auto est\u00e1 definido con el valor validate . Debido a ello, cuando arranquemos la aplicaci\u00f3n Play y se conecte a la base de datos lo primero que va a hacer JPA es comprobar que el esquema de datos (las tablas definidas en la base de datos) se corresponde con lo codificado en las entidades. En el caso en que no exista el esquema de datos o no se corresponda con el esquema definido por las entidades JPA lanzar\u00e1 un error y no funcionar\u00e1 el acceso a los datos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /properties /persistence-unit + !-- MySQL Persistence Unit - Production -- + + persistence-unit name= mySqlPersistenceUnitProduction transaction-type= RESOURCE_LOCAL + provider org.hibernate.jpa.HibernatePersistenceProvider /provider + non-jta-data-source DBTest /non-jta-data-source + class models.Usuario /class + class models.Tarea /class + properties + property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / + property name= hibernate.hbm2ddl.auto value= validate / + /properties + /persistence-unit + /persistence ``` #### Ejecuci\u00f3n de pruebas funcionales en el entorno _stage_ #### La diferencia de esta configuraci\u00f3n con la anterior es que en lugar de dejar que JPA cree las tablas de la base de datos, vamos nosotros a inicializar la base de datos MySQL con los esquemas y datos predefinidos, tal y como suceder\u00eda en producci\u00f3n. ##### Lanzamiento de MySQL ##### Para inicializar los datos de la imagen docker MySQL podemos utilizar su directorio `/docker-entrypoint-initdb.d`. Lo primero que hace la imagen es consultar ese directorio y ejecutar todos los ficheros con la extensi\u00f3n `.sql` que encuentre ah\u00ed. Los ejecuta en el orden alfab\u00e9tico del nombre de fichero. Vamos entonces a lanzar la configuraci\u00f3n de _stage_ por primera vez. Creamos un directorio `stage` fuera del repositorio git y copiamos ah\u00ed el fichero `schema.sql` del repositorio (el que contiene el esquema de base de datos actual): $ cd $ mkdir stage $ cd stage $ cp /sql/schema.sql . 1 2 Nos movemos a ese directorio y lanzamos el comando `docker run` montando el directorio actual en el directorio `/docker-entrypoint-initdb.d`: $ docker run -d --rm --name play-mysql -v ${PWD}:/docker-entrypoint-initdb.d -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql 1 2 3 4 5 6 7 8 De esta forma se lanza MySQL cargando el esquema de datos inicial (vac\u00edo). ##### Parada de MySQL ##### Cuando hayamos terminado de ejecutar las pruebas funcionales volcamos la base de datos a un fichero y paramos MySQL. Para simplificar podemos volcarlo para que sobreescriba el anterior fichero `schema.sql`: $ docker exec play-mysql sh -c 'exec mysqldump mads -uroot -pmads' schema.sql $ docker container stop play-mysql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Dejamos este fichero `schema.sql` en el directorio actual (`/stage`) para que la pr\u00f3xima vez que lancemos MySQL desde \u00e9l cargue los datos anteriormente salvados. De esta forma podemos simular que tenemos un servidor de stage en el que se mantienen los datos que se introducen en las pruebas. ##### Ejecuci\u00f3n de la aplicaci\u00f3n ##### Para ejecutar la aplicaci\u00f3n Play en modo producci\u00f3n lanzamos el contenedor play de la misma forma que hac\u00edamos para ejecutar los tests de integraci\u00f3n (definiendo las variables de entorno para que la configuraci\u00f3n se conecte con la BD y lanzando el shell bash). Y despu\u00e9s usamos el comando `stage` de sbt que crea un fichero ejecutable en el directorio `target/universal/bin/ proyecto `. Por \u00faltimo lanzamos el ejecutable generado cargando la configuraci\u00f3n `stage.conf`. $ cd $ docker run --link play-mysql:mysql --rm -it -p 80:9000 -e \\ DB_URL=\"jdbc:mysql://play-mysql:3306/mads\" -e DB_USER_NAME=\"root\" -e \\ DB_USER_PASSWD=\"mads\" -v${PWD}:/code domingogallardo/playframework /bin/bash bash-4.3# sbt clean stage bash-4.3# target/universal/stage/bin/mads-todolist-2017 -Dconfig.file=${PWD}/conf/stage.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 El ejecutable que se construye es similar al de producci\u00f3n. Sbt tiene un comando `dist` que permite generar un generar un binario listo para su distribuci\u00f3n. Puedes consultar c\u00f3mo hacerlo en [Deploying your application](https://www.playframework.com/documentation/2.5.x/Deploying). La aplicaci\u00f3n se lanza en modo producci\u00f3n y podemos abrir el navegador y realizar los tests funcionales. Ver\u00e1s que aparecen unos errores debido que el funcionamiento de la aplicaci\u00f3n en producci\u00f3n es ligeramente distinto al funcionamiento en desarrollo. En el repositorio con la gu\u00eda de la pr\u00e1ctica puedes encontrar los cambios a realizar, en el [PR #26](https://github.com/domingogallardo/mads-todolist-guia/pull/26): - A\u00f1adir getters y setters. - A\u00f1adir la declaraci\u00f3n de las clases de entidad todos los perfiles en el fichero `persistence.xml`. Arregla los errores, realiza un \u00faltimo commit y **cierra el _issue_ con un pull request**. ## 4. Nueva historia de usuario: tableros (usando TDD) ## La \u00faltima parte de la pr\u00e1ctica consiste en desarrollar, utilizando TDD (_Test Driven Design_) una nueva historia de usuario: **Creaci\u00f3n y asociaci\u00f3n a tableros**. kbd img src= imagenes/historias-usuario.png width= 600px / /kbd Definimos la descripci\u00f3n de la historia que se muestra en la siguiente imagen: kbd img src= imagenes/historia-tableros.png width= 600px / /kbd Implementaremos cada _issue_ de la capa de modelo o la capa de servicios utilizando el ciclo de desarrollo de TDD (el c\u00f3digo de la capa de vista y controlador tambi\u00e9n se deber\u00eda probar de esta forma, pero no lo vamos a hacer por falta de tiempo): 1. Escribir un test que falla. 2. Escribir el c\u00f3digo que hace que el test deje de fallar. 3. Refactorizar el c\u00f3digo de los tests y el c\u00f3digo escrito (sin a\u00f1adir nuevos tests, ni nuevas funcionalidades). 4. Volver al paso 1 Un resumen de lo que deber\u00e1s hacer en esta \u00faltima parte de la pr\u00e1ctica: - Desarrollar\u00e1s uno a uno los nuevos _issues_ de la historia de usuario. - Al igual que hicimos en la pr\u00e1ctica 1, cada _issue_ debe desarrollarse en una rama independiente. Despu\u00e9s crearemos un pull request y, tras pasar los tests de integraci\u00f3n, lo integraremos con master (consultar en el apartado 3.1 c\u00f3mo realizar los tests de integraci\u00f3n antes de aprobar el pull request). - Todos los ficheros de tests deber\u00e1n crearse en un directorio con el nombre de la historia de usuario. Por ejemplo `sg3-creacion-asociacion-tableros`. - Definir\u00e1s un fichero de test por cada _issue_, que contendr\u00e1 todos los tests necesarios para implementar el _issue_ y se denominar\u00e1 con un nombre similar. - Cada test, junto con el c\u00f3digo desarrollado para pasarlo, ir\u00e1 en un commit. - Es posible hacer commits con refactorizaciones (recuerda el ciclo de TDD: Test, Codigo y Refactorizaci\u00f3n). - Utilizar\u00e1s DBUnit para poder hacer pruebas con datos iniciales, a\u00f1adiendo nuevos datos en el fichero `usuarios_dataset.xml`. Veamos a continuaci\u00f3n como ejemplo el desarrollo completo del primer _issue_. ### 4.1. Primer _issue_: Modelo de tablero y repositorio b\u00e1sico En este _issue_ completaremos una clase b\u00e1sica de entidad `Tablero` con los atributos: - Nombre - Administrador (relaci\u00f3n a-uno con la entidad `Usuario`) Tambi\u00e9n crearemos la clase `TableroRepository` con un primer m\u00e9todo para crear tableros. Para implementar esta caracter\u00edstica usando TDD crearemos el fichero de test `test/sg3-creacion-asociacion-tableros/ModeloRepositorioTableroTest.java` en el que iremos a\u00f1adiendo los distintos tests que ir\u00e1n construyendo el c\u00f3digo. Abrimos una rama en la que iremos a\u00f1adiendo los commits del _issue_ (uno por cada test). $ git checkout -b modelo-tablero 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Empezamos ahora a usar TDD para implementar el _issue_. El primer test nos servir\u00e1 para definir los elementos b\u00e1sicos de la entidad `Tablero`. #### Commit 1: Primer test #### Empezamos con el test m\u00e1s sencillo: crear un tablero. Para crear un tablero necesitaremos pasar un usuario y un nombre de tablero. **Fichero `test/sg3-creacion-asociacion-tableros/ModeloRepositorioTableroTest.java`**: ```java import org.junit.*; import static org.junit.Assert.*; import models.Usuario; import models.Tablero; public class ModeloRepositorioTableroTest { @Test public void testCrearTablero() { Usuario usuario = new Usuario( juangutierrez , juangutierrez@gmail.com ); Tablero tablero = new Tablero(usuario, Tablero 1 ); assertEquals( juangutierrez , tablero.getAdministrador().getLogin()); assertEquals( juangutierrez@gmail.com , tablero.getAdministrador().getEmail()); assertEquals( Tablero 1 , tablero.getNombre()); } } Lanzamos los tests y, evidentemente, obtendremos errores de compilaci\u00f3n porque no existen las clases: 1 2 3 4 5 6 7 [mads-todolist-2017] $ testOnly [info] Compiling 6 Java sources to /code/target/scala-2.11/test-classes... [error] /code/test/models/TableroTest.java:5: cannot find symbol [error] symbol: class Tablero [error] location: package models ... [error] Total time: 15 s, completed Sep 30, 2017 3:30:33 PM Creamos las clases con solo el c\u00f3digo necesario para que el test pase : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import org.junit.* ; import static org.junit.Assert.* ; import models.Usuario ; import models.Tablero ; public class ModeloRepositorioTableroTest { @Test public void testCrearTablero () { Usuario usuario = new Usuario ( juangutierrez , juangutierrez@gmail.com ); Tablero tablero = new Tablero ( usuario , Tablero 1 ); assertEquals ( juangutierrez , tablero . getAdministrador (). getLogin ()); assertEquals ( juangutierrez@gmail.com , tablero . getAdministrador (). getEmail ()); assertEquals ( Tablero 1 , tablero . getNombre ()); } } Hacemos un commit con el test y el c\u00f3digo que hemos creado 1 2 3 $ git add . $ git status $ git commit -m Creada clase Tablero Commit 2: Segundo test Vamos con un segundo test en el que a\u00f1adimos otro peque\u00f1o incremento: creaci\u00f3n del JPATableroRepository y comprobaci\u00f3n de que se obtiene correctamente un objeto TableroRepository . Escribimos el test, a\u00f1adiendo el c\u00f3digo al fichero existente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import org.junit.*; import static org.junit.Assert.*; +import play.inject.guice.GuiceApplicationBuilder; +import play.inject.Injector; +import play.inject.guice.GuiceInjectorBuilder; +import play.Environment; + +import play.db.jpa.*; + import models.Usuario; import models.Tablero; +import models.TableroRepository; public class ModeloRepositorioTableroTest { + static private Injector injector; + + @BeforeClass + static public void initApplication() { + GuiceApplicationBuilder guiceApplicationBuilder = + new GuiceApplicationBuilder().in(Environment.simple()); + injector = guiceApplicationBuilder.injector(); + // Necesario para inicializar JPA + injector.instanceOf(JPAApi.class); + } @Test public void testCrearTablero() { ... assertEquals( juangutierrez@gmail.com , tablero.getAdministrador().getEmail()); assertEquals( Tablero 1 , tablero.getNombre()); } + + @Test + public void testObtenerTableroRepository() { + TableroRepository tableroRepository = injector.instanceOf(TableroRepository.class); + assertNotNull(tableroRepository); + } } Lanzamos el test y comprobamos que no funciona. Escribimos el c\u00f3digo m\u00ednimo para hacer que funcione: Fichero models/TableroRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package models ; import javax.inject.Inject ; import play.db.jpa.JPAApi ; import java.util.List ; import javax.persistence.EntityManager ; public class TableroRepository { JPAApi jpaApi ; @Inject public TableroRepository ( JPAApi api ) { this . jpaApi = api ; } } Comprobamos que el test funciona: 1 2 3 4 5 6 [mads-todolist-2017] $ testOnly ModeloRepositorio* [info] Test run started ... [info] Test ModeloRepositorioTableroTest.testObtenerTableroRepository started [info] Test run finished: 0 failed, 0 ignored, 2 total, 12.975s [info] Passed: Total 2, Failed 0, Errors 0, Passed 2 Una vez que el test pasa correctamente hacemos una refactorizaci\u00f3n , sin tocar el test, para convertir TableroRepository en una interfaz y definir una clase espec\u00edfica de la interfaz: JPATableroRepository : Fichero models/TableroRepository.java : 1 2 3 4 5 6 7 8 9 package models ; import com.google.inject.ImplementedBy ; import java.util.List ; @ImplementedBy ( JPATableroRepository . class ) public interface TableroRepository { } Fichero models/JPATableroRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package models ; import javax.inject.Inject ; import play.db.jpa.JPAApi ; import java.util.List ; import javax.persistence.EntityManager ; public class JPATableroRepository implements TableroRepository { JPAApi jpaApi ; @Inject public JPATableroRepository ( JPAApi api ) { this . jpaApi = api ; } } Terminamos haciendo el commit del segundo test: 1 2 3 $ git status $ git add . $ git commit -m Creado TableroRepository Commit 3: Tercer test En el tercer test vamos a comprobar si se crea la tabla TABLERO en la base de datos. Fallar\u00e1 y escribiremos el c\u00f3digo para que pase. El test consistir\u00e1 en buscar en los metadatos de la base de datos si existe esa tabla. Cambios en el fichero test/sg3-creacion-asociacion-tableros/ModeloRepositorioTableroTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import org.dbunit.dataset.xml.*; import org.dbunit.operation.*; import java.io.FileInputStream; +import play.db.Database; +import play.db.Databases; + +import java.sql.*; + import models.Usuario; ... + + @Test + public void testCrearTablaTableroEnBD() throws Exception { + Database db = injector.instanceOf(Database.class); + Connection connection = db.getConnection(); + DatabaseMetaData meta = connection.getMetaData(); + ResultSet res = meta.getTables(null, null, TABLERO , new String[] { TABLE }); + assertTrue(res.next()); + } } El test fallar\u00e1 porque la tabla TABLERO no se encuentra. Modificamos entonces el c\u00f3digo para solucionarlo, a\u00f1adiendo las anotaciones JPA a la clase Tablero : Cambios en el fichero models/Tablero.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 +import javax.persistence.*; + +@Entity public class Tablero { + @Id + @GeneratedValue(strategy=GenerationType.AUTO) + Long id; private String nombre; + @ManyToOne + @JoinColumn(name= administradorId ) private Usuario administrador; + public Tablero() {} + public Tablero(Usuario administrador, String nombre) { this.nombre = nombre; this.administrador = administrador; } + public Long getId() { + return id; + } + + public void setId(Long id) { + this.id = id; + } + public String getNombre() { return nombre; } + public void setNombre(String nombre) { + this.nombre = nombre; + } + public Usuario getAdministrador() { return administrador; } + + public void setAdministrador(Usuario usuario) { + this.administrador = administrador; + } } Y en el fichero persistence.xml debemos a\u00f1adir la nueva clase entidad: Cambios en el fichero conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 non-jta-data-source DBTest /non-jta-data-source class models.Usuario /class class models.Tarea /class + class models.Tablero /class properties property name= hibernate.dialect value= org.hibernate.dialect.H2Dialect / property name= hibernate.hbm2ddl.auto value= update / ... non-jta-data-source DBTest /non-jta-data-source class models.Usuario /class class models.Tarea /class + class models.Tablero /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= update / ... non-jta-data-source DBTest /non-jta-data-source class models.Usuario /class class models.Tarea /class + class models.Tablero /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= validate / Realiza los cambios, reflexionando sobre lo que hacen, y comprueba que el test pasa. Ya puedes cerrar el commit, llam\u00e1ndolo por ejemplo A\u00f1adida entidad Tablero : 1 2 $ git add . $ git commit -m A\u00f1adida entidad Tablero Commit 4: Cuarto test Este cuarto test va a servir para crear la funci\u00f3n add() en el TableroRepository . A\u00f1adimos el siguiente test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import models.TableroRepository; +import models.UsuarioRepository; public class ModeloRepositorioTableroTest { static private Injector injector; ... + @Test + public void testAddTableroInsertsDatabase() { + UsuarioRepository usuarioRepository = injector.instanceOf(UsuarioRepository.class); + TableroRepository tableroRepository = injector.instanceOf(TableroRepository.class); + Usuario administrador = new Usuario( juangutierrez , juangutierrez@gmail.com ); + administrador = usuarioRepository.add(administrador); + Tablero tablero = new Tablero(administrador, Tablero 1 ); + tablero = tableroRepository.add(tablero); + assertNotNull(tablero.getId()); + assertEquals( Tablero 1 , getNombreFromTableroDB(tablero.getId())); + } + private String getNombreFromTableroDB(Long tableroId) { + Database db = injector.instanceOf(Database.class); + String nombre = db.withConnection(connection - { + String selectStatement = SELECT Nombre FROM Tablero WHERE ID = ? ; + PreparedStatement prepStmt = connection.prepareStatement(selectStatement); + prepStmt.setLong(1, tableroId); + ResultSet rs = prepStmt.executeQuery(); + rs.next(); + return rs.getString( Nombre ); + }); + return nombre; + } } El test fallar\u00e1. Y escribimos el c\u00f3digo para que pase: Fichero models/JPATableroRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class JPATableroRepository implements TableroRepository { public JPATableroRepository(JPAApi api) { this.jpaApi = api; } + + public Tablero add(Tablero tablero) { + return jpaApi.withTransaction(entityManager - { + entityManager.persist(tablero); + entityManager.flush(); + entityManager.refresh(tablero); + return tablero; + }); + } } Fichero models/TableroRepository.java : 1 2 3 4 @ImplementedBy(JPATableroRepository.class) public interface TableroRepository { + public Tablero add(Tablero tablero); } Comprueba que el test pasa. Si lanzas todos los tests, ver\u00e1s que algunos fallan. Esto es debido a que el test anterior introduce en la base de datos un usuario nuevo y un tablero con una clave ajena que lo referencia. Cuando DbUnit intenta limpiar la tabla de usuarios en otros tests se provoca un error Referential integrity constraint violation porque existe un tablero que se quedar\u00eda sin usuario administrador. La forma m\u00e1s f\u00e1cil de solucionarlo es a\u00f1adir al data set de DbUnit un elemento Tablero/ para provocar que se borren todos los datos tambi\u00e9n de la tabla Tablero : Fichero test/resources/usuarios_dataset.xml : 1 2 3 4 5 6 7 dataset Usuario id= 1000 login= juangutierrez nombre= Juan apellidos= Gutierrez password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / Tarea id= 1000 titulo= Renovar DNI usuarioId= 1000 / Tarea id= 1001 titulo= Pr\u00e1ctica 1 MADS usuarioId= 1000 / + Tablero/ /dataset Por \u00faltimo, refactoriza el c\u00f3digo para eliminar duplicidad de la inicializaci\u00f3n de la variable db en dos tests. Mueve esa inicializaci\u00f3n al m\u00e9todo @BeforeClass . Realiza un nuevo commit: 1 2 $ git add . $ git commit -m A\u00f1adido m\u00e9todo add() en TableroRepository Commit 5: Refactorizaci\u00f3n Vamos ahora a hacer un commit en el que vamos a refactorizar el c\u00f3digo para arreglar un par de problemas. Los tests nos servir\u00e1n para comprobar que no se introduce ning\u00fan error. Transformaci\u00f3n List en Set En primer lugar vamos a arreglar un error que hemos cometido al definir las entidades. Realiza una refactorizaci\u00f3n en la que deber\u00e1s convertir el tipo del atributo tareas de Usuario de tipo List a tipo Set . Deber\u00e1 quedar como sigue: Fichero models/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 - import java.util.List; - import java.util.ArrayList; + import java.util.Set; + import java.util.HashSet; @Entity public class Usuario { ... private Date fechaNacimiento; // Relaci\u00f3n uno-a-muchos entre usuario y tarea @OneToMany(mappedBy= usuario , fetch=FetchType.EAGER) - public List Tarea tareas = new Tarea (); + public Set Tarea tareas = new HashSet Tarea (); ... La raz\u00f3n de la refactorizaci\u00f3n es que es m\u00e1s correcto definir las colecciones de los atributos de las entidades del tipo Set porque eso garantiza que no habr\u00e1 elementos repetidos en las colecciones. Realiza todos los cambios necesarios y aseg\u00farate de que se siguen pasando todos los tests. Conversi\u00f3n de Long a long Para corregir otro error que no han detectado los tests debemos realizar la siguiente refactorizaci\u00f3n: en los m\u00e9todos equals de Tarea y Usuario hacer una conversi\u00f3n de Long a long , para que realmente detecte como iguales dos identificadores iguales (el m\u00e9todo == compara referencias). Para comprobar que el c\u00f3digo ten\u00eda el error modificamos el test testEqualsTareasConId del fichero TareaTest.java : Fichero test/models/TareaTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Test #14: testEqualsTareasConId @Test public void testEqualsTareasConId() { Usuario usuario = new Usuario( juangutierrez , juangutierrez@gmail.com ); Tarea tarea1 = new Tarea(usuario, Pr\u00e1ctica 1 de MADS ); Tarea tarea2 = new Tarea(usuario, Renovar DNI ); Tarea tarea3 = new Tarea(usuario, Pagar el alquiler ); - tarea1.setId(1L); - tarea2.setId(1L); + tarea1.setId(1000L); + tarea2.setId(1000L); tarea3.setId(2L); assertEquals(tarea1, tarea2); assertNotEquals(tarea1, tarea3); } Si lanzamos el test comprobaremos que dos tareas que deber\u00edan ser iguales porque tienen el mismo identificador, son detectadas como distintas. Para conseguir hacer pasar el test debemos cambiar en el modelo Tarea.java el siguiente c\u00f3digo del m\u00e9todo equals: 1 2 3 4 5 // Si tenemos los ID, comparamos por ID if (id != null other.id != null) - return (id == other.id); + return ((long) id == (long) other.id); // sino comparamos por campos obligatorios Comprobamos que el test ahora s\u00ed que pasa correctamente. Hacemos el mismo cambio en la clase Usuario.java , que contiene el mismo error (aunque no lo hay ning\u00fan test que lo compruebe) y a\u00f1adimos el commit: 1 2 $ git add . $ git commit -m Refactorizados List y equals Commit 6: Quinto test Vamos a por el siguiente test, en el que haremos posible que un usuario pueda administrar varios tableros. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 } }); return nombre; } + + @Test + public void testUsuarioAdministraVariosTableros() { + UsuarioRepository usuarioRepository = injector.instanceOf(UsuarioRepository.class); + TableroRepository tableroRepository = injector.instanceOf(TableroRepository.class); + Usuario administrador = new Usuario( juangutierrez , juangutierrez@gmail.com ); + administrador = usuarioRepository.add(administrador); + Tablero tablero1 = new Tablero(administrador, Tablero 1 ); + tableroRepository.add(tablero1); + Tablero tablero2 = new Tablero(administrador, Tablero 2 ); + tableroRepository.add(tablero2); + // Recuperamos el administrador del repository + administrador = usuarioRepository.findById(administrador.getId()); + // Y comprobamos si tiene los tableros + assertEquals(2, administrador.getAdministrados().size()); + } } Y a\u00f1adimos el c\u00f3digo para conseguir que pase: Fichero models/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Usuario { // Relaci\u00f3n uno-a-muchos entre usuario y tarea @OneToMany(mappedBy= usuario , fetch=FetchType.EAGER) private Set Tarea tareas = new HashSet Tarea (); + @OneToMany(mappedBy= administrador , fetch=FetchType.EAGER) + private Set Tablero administrados = new HashSet Tablero (); // Un constructor vac\u00edo necesario para JPA public Usuario() {} ... public class Usuario { this.tareas = tareas; } + public Set Tablero getAdministrados() { + return administrados; + } + + public void setAdministrados(Set Tablero administrados) { + this.administrados = administrados; + } + Una vez que compruebes que el test funciona correctamente, debes confirmar los cambios: 1 2 $ git add . $ git commit -m Un usuario puede administrar varios tableros Commit 7: Sexto y \u00faltimo test Vamos por \u00faltimo a a\u00f1adir la funcionalidad de que los usuarios puedan participar en tableros y los tableros tienen varios participantes (adem\u00e1s del administrador). Empezamos con el siguiente test, en el que usamos DbUnit, para probar la posibilidad de que un usuario pueda tener varios tableros asociados: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.sql.*; +import java.util.Set; + +import play.db.jpa.*; + +import org.dbunit.*; +import org.dbunit.dataset.*; +import org.dbunit.dataset.xml.*; +import org.dbunit.operation.*; +import java.io.FileInputStream; ... + + private void initDataSet() throws Exception { + JndiDatabaseTester databaseTester = new JndiDatabaseTester( DBTest ); + IDataSet initialDataSet = new FlatXmlDataSetBuilder().build(new FileInputStream( test/resources/usuarios_dataset.xml )); + databaseTester.setDataSet(initialDataSet); + databaseTester.setSetUpOperation(DatabaseOperation.CLEAN_INSERT); + databaseTester.onSetup(); + } + + @Test + public void testUsuarioParticipaEnVariosTableros() throws Exception { + initDataSet(); + UsuarioRepository usuarioRepository = injector.instanceOf(UsuarioRepository.class); + TableroRepository tableroRepository = injector.instanceOf(TableroRepository.class); + Usuario admin = usuarioRepository.findById(1000L); + Usuario usuario = usuarioRepository.findById(1001L); + Set Tablero tableros = admin.getAdministrados(); + // Tras cargar los datos del dataset el usuario2 no tiene ning\u00fan + // tablero asociado y el usuario 1 tiene 2 tableros administrados + assertEquals(0, usuario.getTableros().size()); + assertEquals(2, tableros.size()); + for (Tablero tablero : tableros) { + // Actualizamos la relaci\u00f3n en memoria, a\u00f1adiendo el usuario + // al tablero + tablero.getParticipantes().add(usuario); + // Actualizamos la base de datos llamando al repository + tableroRepository.update(tablero); + } + // Comprobamos que se ha actualizado la relaci\u00f3n en la BD y + // el usuario pertenece a los dos tableros a los que le hemos a\u00f1adido + usuario = usuarioRepository.findById(1001L); + Set Tablero tablerosUsuario = usuario.getTableros(); + assertEquals(2, tablerosUsuario.size()); + for (Tablero tablero: tableros) { + assertTrue(tablerosUsuario.contains(tablero)); + } + } A\u00f1adimos en el data set de DbUnit lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 dataset Usuario id= 1000 login= juangutierrez nombre= Juan apellidos= Gutierrez password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / + Usuario id= 1001 login= juangutierrez2 nombre= Juan apellidos= Gutierrez Dos + password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / + Usuario id= 1002 login= juangutierrez3 nombre= Juan apellidos= Gutierrez Tres + password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / Tarea id= 1000 titulo= Renovar DNI usuarioId= 1000 / Tarea id= 1001 titulo= Pr\u00e1ctica 1 MADS usuarioId= 1000 / - Tablero/ + Tablero id= 1000 nombre= Tablero test 1 administradorId= 1000 / + Tablero id= 1001 nombre= Tablero test 2 administradorId= 1000 / /dataset Estamos a\u00f1adiendo dos usuarios nuevos y dos tableros, estos \u00faltimos administrados por el usuario 1000 ( juangutierrez ). Vamos a codificar lo necesario para que el test pase. El test anterior comprueba que un usuario pueda tener varios tableros y, aplicando TDD de forma estricta, s\u00f3lo deber\u00edamos codificar la relaci\u00f3n ONE_TO_MANY . Sin embargo, como es muy sencillo introducir directamente la relaci\u00f3n MANY_TO_MANY que necesitamos nos saltamos la regla de TDD de introducir un \u00fanico test y a\u00f1adimos el siguiente test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 + + @Test + public void testTableroTieneVariosUsuarios() throws Exception { + initDataSet(); + UsuarioRepository usuarioRepository = injector.instanceOf(UsuarioRepository.class); + TableroRepository tableroRepository = injector.instanceOf(TableroRepository.class); + // Obtenemos datos del dataset + Tablero tablero = tableroRepository.findById(1000L); + Usuario usuario1 = usuarioRepository.findById(1000L); + Usuario usuario2 = usuarioRepository.findById(1001L); + Usuario usuario3 = usuarioRepository.findById(1002L); + assertEquals(0, tablero.getParticipantes().size()); + assertEquals(0, usuario1.getTableros().size()); + // A\u00f1adimos los 3 usuarios al tablero + tablero.getParticipantes().add(usuario1); + tablero.getParticipantes().add(usuario2); + tablero.getParticipantes().add(usuario3); + tableroRepository.update(tablero); + // Comprobamos que los datos se han actualizado + tablero = tableroRepository.findById(1000L); + usuario1 = usuarioRepository.findById(1000L); + assertEquals(3, tablero.getParticipantes().size()); + assertEquals(1, usuario1.getTableros().size()); + assertTrue(tablero.getParticipantes().contains(usuario1)); + assertTrue(usuario1.getTableros().contains(tablero)); + } } En este test a\u00f1adimos tres usuarios a un tablero y despu\u00e9s comprobamos que los datos se han actualizado correctamente al recuperar el tablero del tableroRepository . Vamos entonces a escribir el c\u00f3digo que haga pasar estos dos tests. Empezamos por el modelo, a\u00f1adiendo la relaci\u00f3n MANY_TO_MANY en Usuario y Tablero : Fichero models/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private Date fechaNacimiento; // Relaci\u00f3n uno-a-muchos entre usuario y tarea @OneToMany(mappedBy= usuario , fetch=FetchType.EAGER) private Set Tarea tareas = new HashSet Tarea (); @OneToMany(mappedBy= administrador , fetch=FetchType.EAGER) private Set Tablero administrados = new HashSet Tablero (); + @ManyToMany(mappedBy= participantes , fetch=FetchType.EAGER) + private Set Tablero tableros = new HashSet Tablero (); // Un constructor vac\u00edo necesario para JPA public Usuario() {} ... this.administrados = administrados; } + public Set Tablero getTableros() { + return tableros; + } + + public void setTableros(Set Tablero tableros) { + this.tableros = tableros; + } + public String toString() { String fechaStr = null; if (fechaNacimiento != null) { En el modelo Tablero a\u00f1adimos la relaci\u00f3n y los m\u00e9todos hashCode y equals necesarios para comparar tableros y buscar tableros en colecciones (sin ese m\u00e9todo no funciona correctamente la llamada a contains del primer test): Fichero models/Tablero.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import javax.persistence.* ; + import java.util.Set ; + import java.util.HashSet ; + @Entity public class Tablero { @Id ... @ManyToOne @JoinColumn ( name = administradorId ) private Usuario administrador ; + @ManyToMany ( fetch = FetchType . EAGER ) + @JoinTable ( name = Persona_Tablero ) + private Set Usuario participantes = new HashSet Usuario (); public Tablero () {} ... public void setAdministrador ( Usuario usuario ) { this . administrador = administrador ; } + + public Set Usuario getParticipantes () { + return participantes ; + } + + public void setParticipantes ( Set Usuario participantes ) { + this . participantes = participantes ; + } + + @Override + public int hashCode () { + final int prime = 31 ; + int result = prime + (( nombre == null ) ? 0 : nombre . hashCode ()); + result = result + (( administrador == null ) ? 0 : administrador . hashCode ()); + return result ; + } + + @Override + public boolean equals ( Object obj ) { + if ( this == obj ) return true ; + if ( getClass () != obj . getClass ()) return false ; + Tablero other = ( Tablero ) obj ; + // Si tenemos los ID, comparamos por ID + if ( id != null other . id != null ) + return (( long ) id == ( long ) other . id ); + // sino comparamos por campos obligatorios + else { + if ( nombre == null ) { + if ( other . nombre != null ) return false ; + } else if (! nombre . equals ( other . nombre )) return false ; + if ( administrador == null ) { + if ( other . administrador != null ) return false ; + else if (! administrador . equals ( other . administrador )) return false ; + } + } + return true ; + } } Necesitamos tambi\u00e9n a\u00f1adir los m\u00e9todos update y findById en la interfaz TableroRepository : Fichero models/TableroRepository.java : 1 2 3 4 5 6 @ImplementedBy(JPATableroRepository.class) public interface TableroRepository { public Tablero add(Tablero tablero); + public Tablero update(Tablero tablero); + public Tablero findById(Long idTablero); } Y su implementaci\u00f3n en JPATableroRepository.java **: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 + + public Tablero update(Tablero tablero) { + return jpaApi.withTransaction(entityManager - { + Tablero actualizado = entityManager.merge(tablero); + return actualizado; + }); + } + + public Tablero findById(Long idTablero) { + return jpaApi.withTransaction(entityManager - { + return entityManager.find(Tablero.class, idTablero); + }); + } + } Lanzamos los tests y comprobamos que todo funciona correctamente. Antes de hacer el commit es necesario a\u00f1adir en el fichero usuarios_dataset.xml la l\u00ednea para limpiar la nueva tabla que genera la relaci\u00f3n MANY_TO_MANY . Si no se a\u00f1ade, fallar\u00e1n las siguientes ejecuciones de los tests. Fichero test/resources/usuarios_dataset.xml : 1 2 3 Tablero id= 1001 nombre= Tablero test 2 administradorId= 1000 / + Persona_Tablero/ /dataset Hacemos el commit y subimos la rama para crear el pull request: 1 2 3 $ git add . $ git commit -m Relaci\u00f3n muchos a muchos entre usuarios y tableros $ git push -u origin modelo-tablero En GitHub creamos el pull request con la rama. 4.2. Tests de integraci\u00f3n antes de cerrar el issue y confirmar el pull request Con los commits anteriores hemos terminado de codificar el issue . Una vez que hemos creado el pull request en GitHub, antes de aceptarlo, debemos comprobar que funciona correctamente la integraci\u00f3n con master . GitHub nos informa si el PR tiene alg\u00fan conflicto con master . En ese caso deber\u00edamos tambi\u00e9n resolverlos. Para ello debemos hacer lo siguiente: Hacer un merge de master en la rama del issue . En este merge pueden producirse conflictos que deberemos arreglar. Una vez realizado el merge comprobar que pasan los tests de integraci\u00f3n y de stage . Si el esquema de datos ha cambiado, obtener el nuevo esquema y aplicar los cambios en la base de datos de stage . Aceptar el pull request: subir los nuevos commits al pull request, confirmarlo para realizar la integraci\u00f3n con master en remoto y actualizar la rama master local. Merge con la rama master Mezclamos la rama master con la rama actual del issue . Pero antes de ello debemos actualizar master para descargar los cambios que se hayan podido subir a remoto. Aunque en este caso no habr\u00e1 ning\u00fan cambio, este paso es muy importante cuando estemos trabajando en equipo y haya m\u00faltiples issues integr\u00e1ndose simult\u00e1neamente. Una vez actualizado master volvemos a la rama modelo-tablero y realizamos el merge de master : 1 2 3 4 $ git checkout master $ git pull $ git checkout modelo-tablero $ git merge master Puede que no sea posible realizar el merge porque git detecta alg\u00fan conflicto. Aparecer\u00eda un mensaje como el siguiente: 1 2 3 4 5 $ git merge master Auto-merging app/services/TareaService.java CONFLICT (content): Merge conflict in app/services/TareaService.java Auto-merging app/models/Usuario.java CONFLICT (content): Merge conflict in app/models/Usuario.java Debes solucionarlo siguiendo las instrucciones que aparecen en el git status : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ git status On branch modelo-tablero Your branch is up-to-date with solucion/modelo-tablero . You have unmerged paths. (fix conflicts and run git commit ) (use git merge --abort to abort the merge) Changes to be committed: modified: test/models/TareaTest.java Unmerged paths: (use git add file ... to mark resolution) both modified: app/models/Usuario.java both modified: app/services/TareaService.java Debes editar los ficheros en los que haya conflicto. Ver\u00e1s que git ha modificado los ficheros incluyendo marcas que indican las l\u00edneas que est\u00e1n en conflicto. Edita las l\u00edneas para dejar el fichero como te interesa y s\u00e1lvalo. Una vez arreglados los conflictos hay que informar a git de esta resoluci\u00f3n. Como indica el git status debemos hacer un git add de los ficheros en los que hemos resuelto los conflictos: 1 2 $ git add app/models/Usuario.java $ git add app/services/TareaService.java Si hacemos ahora un git status git nos explica c\u00f3mo continuar: 1 2 3 4 5 6 7 8 9 10 $ git status On branch modelo-tablero Your branch is up-to-date with solucion/modelo-tablero2 . All conflicts fixed but you are still merging. (use git commit to conclude merge) Changes to be committed: modified: app/services/TareaService.java modified: test/models/TareaTest.java Nos dice que debemos hacer un commit para concluir el merge. Hacemos despu\u00e9s un push para subirlo a GitHub: 1 2 $ git commit -m Solucionados conflictos $ git push Veremos en GitHub que el pull request se actualiza con el nuevo commit y que ya no aparecen conflictos con master. En el caso en que no hayan aparecido conflictos no es necesario hacer un push a GitHub (no hay cambios a\u00f1adidos en la rama). Tests de integraci\u00f3n Una vez realizada la integraci\u00f3n de master en la rama del issue debes lanzar los tests de integraci\u00f3n tal y como se explica en el apartado 3.1. Si aparece alg\u00fan error debes solucionarlo, crear un nuevo commit y subirlo a GitHub. En nuestro caso uno de los errores que aparecer\u00e1n est\u00e1 relacionado con c\u00f3mo se almacenan los nombres de las tablas en la base de datos H2 (memoria) y MySQL. Una de las bases de datos las guarda en may\u00fasculas y la otra no. Debes modificar el test testCrearTableTableroEnBD para contemplar las dos posibilidades: 1 2 3 4 5 6 7 8 9 10 11 12 13 @Test public void testCrearTablaTableroEnBD() throws Exception { Database db = injector.instanceOf(Database.class); Connection connection = db.getConnection(); DatabaseMetaData meta = connection.getMetaData(); - ResultSet resH2 = meta.getTables(null, null, TABLERO , new String[] { TABLE }); + // En la BD H2 el nombre de las tablas se define con may\u00fascula y en + // MySQL con min\u00fascula + ResultSet resH2 = meta.getTables(null, null, TABLERO , new String[] { TABLE }); + ResultSet resMySQL = meta.getTables(null, null, Tablero , new String[] { TABLE }); + boolean existeTabla = resH2.next() || resMySQL.next(); assertTrue(existeTabla); } Una vez que los tests de integraci\u00f3n funcionan, generamos la tabla con el esquema de datos ( schema.sql ) tal y como se explica en el apartado 3.1 y la copiamos en el directorio correspondiente del proyecto ( sql/schema.sql ). Si hay alg\u00fan cambio en el esquema git los detectar\u00e1. Podemos comprobar los cambios haciendo un git diff : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 -- +-- Table structure for table `Persona_Tablero` +-- + +DROP TABLE IF EXISTS `Persona_Tablero`; +/*!40101 SET @saved_cs_client = @@character_set_client */; +/*!40101 SET character_set_client = utf8 */; +CREATE TABLE `Persona_Tablero` ( + `tableros_id` bigint(20) NOT NULL, + `participantes_id` bigint(20) NOT NULL, + KEY `FKnghbrhyh7eal30o78h3293n72` (`participantes_id`), + KEY `FKbpw5yq3ofgud0ra8a916kddjm` (`tableros_id`), + CONSTRAINT `FKbpw5yq3ofgud0ra8a916kddjm` FOREIGN KEY (`tableros_id`) REFERENCES `Tablero` (`id`), + CONSTRAINT `FKnghbrhyh7eal30o78h3293n72` FOREIGN KEY (`participantes_id`) REFERENCES `Usuario` (`id`) +) ENGINE=InnoDB DEFAULT CHARSET=latin1; +/*!40101 SET character_set_client = @saved_cs_client */; + +-- +-- Table structure for table `Tablero` +-- + +DROP TABLE IF EXISTS `Tablero`; +/*!40101 SET @saved_cs_client = @@character_set_client */; +/*!40101 SET character_set_client = utf8 */; +CREATE TABLE `Tablero` ( + `id` bigint(20) NOT NULL, + `nombre` varchar(255) DEFAULT NULL, + `administradorId` bigint(20) DEFAULT NULL, + PRIMARY KEY (`id`), + KEY `FKq82919iay2b8h77msdj8289p0` (`administradorId`), + CONSTRAINT `FKq82919iay2b8h77msdj8289p0` FOREIGN KEY (`administradorId`) REFERENCES `Usuario` (`id`) +) ENGINE=InnoDB DEFAULT CHARSET=latin1; +/*!40101 SET character_set_client = @saved_cs_client */; + +-- En este caso los cambios consisten en las dos tablas nuevas a\u00f1adidas. Una para la entidad Tablero y otra para mantener la relaci\u00f3n MANY_TO_MANY con Usuario . A\u00f1adimos los cambios del esquema con un commit y los subimos a GitHub: 1 2 3 $ git add sql/schema.sql $ git commit -m Cambios en el esquema SQL $ git push Tests de stage Si lanzamos ahora el entorno stage tal y como explicamos en el apartado 3.2 comprobaremos que la aplicaci\u00f3n no funciona, porque el esquema guardado no se corresponde con el de la aplicaci\u00f3n. Debemos crear un script de actualizaci\u00f3n de la base de datos a partir de los cambios observados en el apartado anterior. En nuestro caso el script consistir\u00e1 en las mismas sentencias SQL para crear las nuevas tablas. En otros casos tendr\u00e1s que hacer un ALTER TABLE para actualizar tablas ya existentes con nuevas columnas. Llamamos al fichero Upgrade.sql : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */ ; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */ ; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */ ; /*!40101 SET NAMES utf8 */ ; /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */ ; /*!40103 SET TIME_ZONE= +00:00 */ ; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */ ; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */ ; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE= NO_AUTO_VALUE_ON_ZERO */ ; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */ ; CREATE TABLE ` Persona_Tablero ` ( ` tableros_id ` bigint ( 20 ) NOT NULL , ` participantes_id ` bigint ( 20 ) NOT NULL , KEY ` FKnghbrhyh7eal30o78h3293n72 ` ( ` participantes_id ` ), KEY ` FKbpw5yq3ofgud0ra8a916kddjm ` ( ` tableros_id ` ), CONSTRAINT ` FKbpw5yq3ofgud0ra8a916kddjm ` FOREIGN KEY ( ` tableros_id ` ) REFERENCES ` Tablero ` ( ` id ` ), CONSTRAINT ` FKnghbrhyh7eal30o78h3293n72 ` FOREIGN KEY ( ` participantes_id ` ) REFERENCES ` Usuario ` ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; CREATE TABLE ` Tablero ` ( ` id ` bigint ( 20 ) NOT NULL , ` nombre ` varchar ( 255 ) DEFAULT NULL , ` administradorId ` bigint ( 20 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ), KEY ` FKq82919iay2b8h77msdj8289p0 ` ( ` administradorId ` ), CONSTRAINT ` FKq82919iay2b8h77msdj8289p0 ` FOREIGN KEY ( ` administradorId ` ) REFERENCES ` Usuario ` ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; La l\u00ednea 1 /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */ ; es importante porque le indica a MySQL que no chequee la existencia de claves ajenas al crear las tablas. De esta forma podemos crearlas en el orden en el que aparecen. Guardamos el fichero upgrade.sql en el mismo directorio stage en el que est\u00e1 el fichero schema.sql con el backup de los datos de anteriores ejecuciones de pruebas funcionales en el directorio. Al arrancar el contenedor docker MySQL de stage (ver apartado 3.2) se cargar\u00e1n los ficheros SQL en orden alfab\u00e9tico, de forma que primero se cargar\u00e1n los datos anteriores (fichero schema.sql ) y despu\u00e9s se realizar\u00e1 la actualizaci\u00f3n (fichero upgrade.sql ). Arrancamos la aplicaci\u00f3n Play en modo stage (ver apartado 3.2) y comprobamos que todo funciona correctamente. Por \u00faltimo a\u00f1adimos el fichero upgrade.sql al proyecto en el directorio SQL, llam\u00e1ndolo upgrade1.sql . De esta forma guardamos tambi\u00e9n los scripts de actualizaci\u00f3n en el control de versiones. 1 2 3 $ cp upgrade.sql DIR_PROYECTO/sql/upgrade1.sql $ git commit -m A\u00f1adido fichero actualizaci\u00f3n BD $ git push Confirmaci\u00f3n del pull request Por \u00faltimo confirmamos el pull request en GitHub y se hace la integraci\u00f3n en master remoto. Borramos la rama remota modelo-tablero . Actualizamos la mezcla en local y borramos tambi\u00e9n la rama local: 1 2 3 4 $ git checkout master $ git pull $ git branch -d modelo-tablero $ git remote prune origin 4.3. Resto de issues (parte obligatoria) Termina los issues 2 y 3 de la historia de usuario, realizando el primero tambi\u00e9n con TDD: M\u00e9todos de servicio para crear un tablero y para obtener el listado de tableros administrados por un usuario. Controlador, acci\u00f3n y vista para un listado de tableros administrados y posibilidad de a\u00f1adir nuevos tableros administrados. 4.4 Resto de issues (parte opcional) Termina los issues 4, 5, 6 y 7, haciendo con TDD todos los correspondientes a m\u00e9todos de servicio: M\u00e9todos de servicio para apuntarse a un tablero (como participante) y para obtener los siguientes listados: Listado de tableros en los que participa el usuario Listado de resto de tableros (en los que el usuario ni participa ni es administrador). Controlador, acci\u00f3n y modificaci\u00f3n de la vista con el listado de tableros para mostrar los listados anteriores y permitir apuntarse como participante a un tablero. M\u00e9todos de modelo y servicio para obtener descripci\u00f3n de un tablero (nombre, administrador y lista de participantes). Controlador y vista con descripci\u00f3n de un tablero y a\u00f1adir enlaces en el listado de tableros para que al pinchar se vaya a su descripci\u00f3n. 4.5. Finalizaci\u00f3n de la versi\u00f3n 0.2 Una vez terminada la pr\u00e1ctica, creamos un nuevo release . Cuando hayas integrado el \u00faltimo PR, haz un commit en master en el que modifiques la versi\u00f3n del proyecto en el fichero build.sbt: version := \"0.2\" Publica directamente el commit en master (sin hacer PR). A\u00f1ade en GitHub el tag con el n\u00famero de versi\u00f3n: Pincha enlace releases en la p\u00e1gina principal A\u00f1ade una nueva versi\u00f3n: v0.2 y pulsa el bot\u00f3n para publicar el release. Esto crear\u00e1 la etiqueta y la versi\u00f3n en GitHub. Por \u00faltimo, cambia la versi\u00f3n actual (en build.sbt en master ) a 0.3-SNAPSHOT haciendo y publicando un nuevo commit. De esta forma, indicamos que ahora en master se est\u00e1 desarrollando la versi\u00f3n 0.3. 5. Entrega y evaluaci\u00f3n La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y debe estar terminada el martes 24 de octubre. La parte obligatoria punt\u00faa sobre 7 y la opcional sobre 3 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 8% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un clean . Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 3 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Correcci\u00f3n del c\u00f3digo.","title":"Pr\u00e1ctica 2: Gesti\u00f3n de configuraciones y TDD con Play Framework"},{"location":"02-pruebas-tdd/pruebas-tdd/#practica-2-gestion-de-configuraciones-y-tdd-con-play-framework","text":"1. Objetivos 1.2. Refactorizaci\u00f3n de la obtenci\u00f3n de las tareas de usuario 2. Tests en Play Framework 2.1. JUnit 2.2. Tests con bases de datos y JPA 2.3. Nuevo issue con tests 3. Definici\u00f3n de configuraciones 3.1. Configuraci\u00f3n de pruebas de integraci\u00f3n 3.2. Configuraci\u00f3n de stage 4. Nueva historia de usuario: tableros (usando TDD) 4.1. Primer issue : Modelo de tablero y repositorio b\u00e1sico 4.2. Tests de integraci\u00f3n antes de cerrar el issue y confirmar el pull request 4.3. Resto de issues (parte obligatoria) 4.4 Resto de issues (parte opcional) 4.5. Finalizaci\u00f3n de la versi\u00f3n 0.2 5. Entrega y evaluaci\u00f3n","title":"Pr\u00e1ctica 2: Gesti\u00f3n de configuraciones y TDD con Play Framework"},{"location":"02-pruebas-tdd/pruebas-tdd/#1-objetivos","text":"Esta pr\u00e1ctica tiene dos objetivos principales: profundizar en las caracter\u00edsticas de Play Framework relacionadas con las pruebas y utilizar la metodolog\u00eda TDD para a\u00f1adir funcionalidades a nuestra aplicaci\u00f3n. Al igual que la primera pr\u00e1ctica, el desarrollo de esta pr\u00e1ctica ser\u00e1 individual. Tendr\u00e1 una duraci\u00f3n de 3 semanas, siendo la fecha l\u00edmite de entrega el 24 de octubre . Seguiremos trabajando en la aplicaci\u00f3n mads-todolist que has estado desarrollando en la primera pr\u00e1ctica. Continuaremos tambi\u00e9n trabajando con Git como sistema de control de versiones y GitHub como repositorio remoto. Intregraremos Git y TDD, haciendo que cada commit represente un incremento funcional en el desarrollo de la aplicaci\u00f3n y contenga y pase sus propios tests.","title":"1. Objetivos"},{"location":"02-pruebas-tdd/pruebas-tdd/#12-refactorizacion-de-la-obtencion-de-las-tareas-de-usuario","text":"Antes de empezar la pr\u00e1ctica, vamos a hacer una refactorizaci\u00f3n de un c\u00f3digo mejorable introducido en la pr\u00e1ctica 1. Se trata del c\u00f3digo que recupera la lista de tareas de un usuario. La pod\u00e9is encontrar en el [PR","title":"1.2. Refactorizaci\u00f3n de la obtenci\u00f3n de las tareas de usuario"},{"location":"02-pruebas-tdd/pruebas-tdd/#34httpsgithubcomdomingogallardomads-todolist-guiapull34","text":"echadle un vistazo a los cambios y hacedlo tambi\u00e9n en vuestro proyecto. Un usuario tiene una relaci\u00f3n a-muchos con tareas. La refactorizaci\u00f3n consiste en hacer que al recuperar un usuario, JPA se traiga a memoria todas sus tareas y se queden guardadas en su atributo tareas . Para ello basta con poner en la entidad el atributo de JPA fetch=FetchType.EAGER . De esta forma evitamos el m\u00e9todo findAllTareas(usuarioId) en el TareaRepository . En t\u00e9rminos de Domain-Driven Design (un m\u00e9todo de dise\u00f1o muy interesante, que os recomiendo que aprend\u00e1is) estamos hablando de que Usuario y Tareas son entidades agregadas . Siempre tendremos en memoria en los objetos usuario su lista completa de tareas. Un libro muy recomendable para aprender sobre DDD es Patterns, Principles, and Practices of Domain-Driven Design .","title":"34](https://github.com/domingogallardo/mads-todolist-guia/pull/34),"},{"location":"02-pruebas-tdd/pruebas-tdd/#2-tests-en-play-framework","text":"Play Framework en Java utiliza JUnit como framework de testing. Los siguientes enlaces proporcionan informaci\u00f3n inicial sobre testing en Play Framework. No vamos a entrar en profundidad en todas las posibilidades ( mocking , inyecci\u00f3n de dependencias, etc.), s\u00f3lo aprender lo necesario para definir algunos tests que sean \u00fatiles. A pesar que Play permite una gran flexibilidad a la hora de testear sus distintos elementos, s\u00f3lo vamos a realizar tests de la capa de persistencia (clases Repository) y de la capa de servicios . Testing your application Testing with databases Todos los tests se incluyen en el directorio tests . Podemos lanzar todos los tests desde la consola sbt 1 [mads-todolist-2017] $ test Y tambi\u00e9n podemos lanzar s\u00f3lo los tests definidos en una clase: 1 [mads-todolist-2017] $ testOnly TareaServiceTest O utilizar un comod\u00edn * para ejecutar s\u00f3lo un conjunto de tests cuyas clases comiencen por una cadena: 1 [mads-todolist-2017] $ testOnly Tarea* Y para lanzar s\u00f3lo los tests que han fallado: 1 [mads-todoslist] $ testQuick En Play es posible lanzar tests sobre ejecuciones de la aplicaci\u00f3n con la sentencia withApplication (aunque no lo vamos a hacer). De esta forma no es necesario crear mocks ni stubs (aunque es posible hacerlo, si queremos mejorar el rendimiento de la ejecuci\u00f3n de los tests o aislar el c\u00f3digo a probar del resto de componentes y recursos).","title":"2. Tests en Play Framework"},{"location":"02-pruebas-tdd/pruebas-tdd/#21-junit","text":"Los tests se construyen usando JUnit: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import static org.junit.Assert.* ; import org.junit.Test ; public class SimpleTest { @Test public void testSum () { int a = 1 + 1 ; assertEquals ( 2 , a ); } @Test public void testString () { String str = Hello world ; assertFalse ( str . isEmpty ()); } }","title":"2.1. JUnit"},{"location":"02-pruebas-tdd/pruebas-tdd/#22-tests-con-bases-de-datos-y-jpa","text":"","title":"2.2. Tests con bases de datos y JPA"},{"location":"02-pruebas-tdd/pruebas-tdd/#conexion-de-jpa-con-una-base-de-datos-en-memoria","text":"Lo habitual para realizar tests unitarios que necesiten trabajar con una base de datos es, o bien mockear la base de datos, o bien utilizar una base de datos en memoria (como H2) para que los tests puedan ejecutarse mucho m\u00e1s r\u00e1pido sin necesidad de una base de datos real que trabaje sobre el disco duro. En la primera pr\u00e1ctica hemos utilizado el segundo enfoque. El problema de los tests tal y como est\u00e1n escritos en la primera pr\u00e1ctica es que la base de datos de prueba sobre la que trabajan no se puede definir en el fichero de configuraci\u00f3n, sino que est\u00e1 definida en su c\u00f3digo fuente. En concreto, la base de datos de memoria la creamos manualmente con la instrucci\u00f3n Databases.inMemoryWith() pasando un nombre JNDI con el que inicializarla ( DBTest ). Y despu\u00e9s obtenemos el JPAApi obteniendo la configuraci\u00f3n de JPA memoryPersistenceUnit . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class UsuarioServiceTest { static Database db ; static JPAApi jpaApi ; @BeforeClass static public void initDatabase () { // Inicializamos la BD en memoria y su nombre JNDI db = Databases . inMemoryWith ( jndiName , DBTest ); ... // Activamos en JPA la unidad de persistencia memoryPersistenceUnit // declarada en META-INF/persistence.xml y obtenemos el objeto // JPAApi jpaApi = JPA . createFor ( memoryPersistenceUnit ); } ... @Test public void crearNuevoUsuarioCorrectoTest (){ UsuarioRepository repository = new JPAUsuarioRepository ( jpaApi ); UsuarioService usuarioService = new UsuarioService ( repository ); Usuario usuario = usuarioService . creaUsuario ( luciaruiz , lucia.ruiz@gmail.com , 123456 ); assertNotNull ( usuario . getId ()); assertEquals ( luciaruiz , usuario . getLogin ()); assertEquals ( lucia.ruiz@gmail.com , usuario . getEmail ()); assertEquals ( 123456 , usuario . getPassword ()); } Recordemos que el perfil memoryPersistenceUnit est\u00e1 definido en el fichero conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 persistence-unit name= memoryPersistenceUnit transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTest /non-jta-data-source properties property name= hibernate.dialect value= org.hibernate.dialect.H2Dialect / property name= hibernate.hbm2ddl.auto value= update / /properties /persistence-unit La anotaci\u00f3n @BeforeClass hace que el m\u00e9todo est\u00e1tico initDatabase() se ejecute una \u00fanica vez antes de todos los tests y guarde en las variables de clase la base de datos y el JPAApi obtenido. Estas dos variables se utilizar\u00e1n m\u00e1s adelante.","title":"Conexi\u00f3n de JPA con una base de datos en memoria"},{"location":"02-pruebas-tdd/pruebas-tdd/#inicializacion-de-la-base-de-datos-con-dbunit","text":"Para poder inicializar la base de datos con un conjunto de datos previos utilizamos la librer\u00eda DBUnit. La dependencia de la librer\u00eda se declara en el fichero build.sbt 1 2 3 4 5 6 7 8 ... libraryDependencies += javaJpa libraryDependencies += org.hibernate % hibernate-core % 5.2.5.Final libraryDependencies += mysql % mysql-connector-java % 5.1.18 libraryDependencies += org.dbunit % dbunit % 2.4.9 ... Los datos iniciales de la base de datos se definen en un fichero de configuraci\u00f3n XML. Fichero test/resources/usuarios_dataset.xml : 1 2 3 4 5 6 7 ?xml version= 1.0 encoding= UTF-8 ? dataset Usuario id= 1000 login= juangutierrez nombre= Juan apellidos= Gutierrez password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / Tarea id= 1000 titulo= Renovar DNI usuarioId= 1000 / Tarea id= 1001 titulo= Pr\u00e1ctica 1 MADS usuarioId= 1000 / /dataset Cada l\u00ednea XML define un dato en la tabla con el nombre indicado. Por ejemplo, en el fichero anterior se define un usuario y dos tareas. DbUnit se encarga de convertir los atributos en los tipos correspondientes a los definidos en las tablas cuando se realiza la inserci\u00f3n. Hay que hacer notar que en DBUnit hay que definir las fechas con el formato AAAA-MM-DD . Para realizar la inserci\u00f3n en la base de datos con la que van a trabajar los tests se ejecuta la siguiente funci\u00f3n: 1 2 3 4 5 6 7 8 @Before public void initData () throws Exception { JndiDatabaseTester databaseTester = new JndiDatabaseTester ( DBTest ); IDataSet initialDataSet = new FlatXmlDataSetBuilder (). build ( new FileInputStream ( test/resources/usuarios_dataset.xml )); databaseTester . setDataSet ( initialDataSet ); databaseTester . setSetUpOperation ( DatabaseOperation . CLEAN_INSERT ); databaseTester . onSetup (); } Se obtiene la base de datos a trav\u00e9s de su nombre JNDI. Y despu\u00e9s se cargan los datos realizando una operaci\u00f3n CLEAN_INSERT . En este tipo de operaci\u00f3n DbUnit borra todos los datos de todas las tablas que aparecen en el fichero XML y despu\u00e9s realiza la inserci\u00f3n. La etiqueta @Before hace que la funci\u00f3n se ejecute antes de cada test.","title":"Inicializaci\u00f3n de la base de datos con DBUnit"},{"location":"02-pruebas-tdd/pruebas-tdd/#23-nuevo-issue-con-tests","text":"Crea un nuevo issue (y una rama, y despu\u00e9s un pull request para integrarlo con master, igual que en la pr\u00e1ctica 1) con la descripci\u00f3n Nuevos tests pr\u00e1ctica 2 . Puedes ponerle la etiqueta tech . Para completar el issue debes hacer lo siguiente: A\u00f1ade un usuario y una tarea en el fichero XML. Crea una nueva clase de tests el directorio test/practica2 con el nombre Practica2Test . A\u00f1ade en \u00e9l 4 nuevos tests que comprueben condiciones que no hemos comprobado en la pr\u00e1ctica 1. Ejemplos: Test que comprueba que el m\u00e9todo findUsuarioPorId de UsuarioService devuelve null si se le pasa un identificador no existente. Test que comprueba que el m\u00e9todo borraTarea de TareaService lanza una excepci\u00f3n si se le pasa un identificador de tarea no existente.","title":"2.3. Nuevo issue con tests"},{"location":"02-pruebas-tdd/pruebas-tdd/#3-definicion-de-configuraciones","text":"Hemos comprobado en la pr\u00e1ctica 1 que el fichero application.conf sirve para definir la configuraci\u00f3n con la que se va ejecutar la aplicaci\u00f3n Play. Hemos definido en \u00e9l la base de datos en memoria H2 con la que se ejecuta la aplicaci\u00f3n. Esta configuraci\u00f3n es la que denominamos configuraci\u00f3n de desarrollo , que es la configuraci\u00f3n por defecto utilizada durante el desarrollo de la aplicaci\u00f3n. Vamos a ver en este apartado c\u00f3mo definir configuraciones alternativas en las que ejecutar los tests: Configuraci\u00f3n de integraci\u00f3n : configuraci\u00f3n que se utilizaremos en las pruebas de integraci\u00f3n. Estar\u00e1 constituida por una base de datos MySQL contendr\u00e1 los datos introducidos por los tests. El hecho de trabajar con MySQL en lugar de la base de datos de memoria har\u00e1 que esta configuraci\u00f3n sea m\u00e1s parecida a la que se utiliza en el despliegue real en producci\u00f3n de la aplicaci\u00f3n. Configuraci\u00f3n de stage : configuraci\u00f3n muy similar a la de producci\u00f3n en la que se realizar\u00e1n pruebas funcionales. Estar\u00e1 formada por una base de datos MySQL con datos estables que se ir\u00e1n a\u00f1adiendo en los tests funcionales, creando un entorno muy similar al de producci\u00f3n. Lanzaremos los tests en la configuraci\u00f3n de integraci\u00f3n. Y ejecutaremos la aplicaci\u00f3n para lanzar pruebas funcionales en la configuraci\u00f3n de stage .","title":"3. Definici\u00f3n de configuraciones"},{"location":"02-pruebas-tdd/pruebas-tdd/#31-configuracion-de-pruebas-de-integracion","text":"Empezaremos solucionando un problema importante de los tests: conseguir que carguen el fichero de configuraci\u00f3n, en lugar de definir en el c\u00f3digo las conexiones a la base de datos. Despu\u00e9s a\u00f1adiremos un fichero de configuraci\u00f3n de conexi\u00f3n con una base de datos MySQL y veremos c\u00f3mo lanzar los tests para que usen esa configuraci\u00f3n.","title":"3.1. Configuraci\u00f3n de pruebas de integraci\u00f3n"},{"location":"02-pruebas-tdd/pruebas-tdd/#nuevo-issue-configuracion-entorno-de-integracion","text":"Debes crear un nuevo issue con la descripci\u00f3n Configuraci\u00f3n entorno de integraci\u00f3n en el que deber\u00e1s incluir los cambios que se indiquen los siguientes apartados. Puedes ponerle la etiqueta tech . Crea una rama en la que desarrolles este nuevo issue .","title":"Nuevo issue: Configuraci\u00f3n entorno de integraci\u00f3n"},{"location":"02-pruebas-tdd/pruebas-tdd/#refactorizacion-de-los-tests","text":"Vamos a ver c\u00f3mo refactorizar los tests para que se lancen sobre una base de datos definida en el fichero de configuraci\u00f3n.","title":"Refactorizaci\u00f3n de los tests"},{"location":"02-pruebas-tdd/pruebas-tdd/#problema-los-tests-no-usan-el-fichero-de-configuracion","text":"El problema de los tests tal y como est\u00e1n escritos en la actualidad es que la base de datos de prueba sobre la que trabajan no se puede definir en el fichero de configuraci\u00f3n, sino que est\u00e1 definida en su c\u00f3digo fuente. Como hemos visto anteriormente, la base de datos se inicializa a mano, obteni\u00e9ndose el JPAApi usando una configuraci\u00f3n concreta: 1 2 3 4 5 6 7 8 9 @BeforeClass static public void initDatabase () { // Inicializamos la BD en memoria y su nombre JNDI db = Databases . inMemoryWith ( jndiName , DBTest ); ... // Activamos en JPA la unidad de persistencia memoryPersistenceUnit // declarada en META-INF/persistence.xml y obtenemos el objeto // JPAApi jpaApi = JPA . createFor ( memoryPersistenceUnit ); Despu\u00e9s, en cada test, usamos el jpaApi obtenido para construir un service o un repostory : 1 2 3 4 5 6 7 8 9 10 @Test public void crearNuevoUsuarioCorrectoTest (){ UsuarioRepository repository = new JPAUsuarioRepository ( jpaApi ); UsuarioService usuarioService = new UsuarioService ( repository ); Usuario usuario = usuarioService . creaUsuario ( luciaruiz , lucia.ruiz@gmail.com , 123456 ); assertNotNull ( usuario . getId ()); assertEquals ( luciaruiz , usuario . getLogin ()); assertEquals ( lucia.ruiz@gmail.com , usuario . getEmail ()); assertEquals ( 123456 , usuario . getPassword ()); } Este c\u00f3digo hace que los tests sean poco configurables ya que no estamos obteniendo la base de datos definida en el fichero de configuraci\u00f3n. Si queremos cambiar la base de datos sobre la que trabajan los tests hay que modificar el propio c\u00f3digo fuente.","title":"Problema: los tests no usan el fichero de configuraci\u00f3n"},{"location":"02-pruebas-tdd/pruebas-tdd/#refactorizacion-de-los-tests_1","text":"Vamos a modificar el c\u00f3digo para que la base de datos que se utilice no est\u00e9 escrita a fuego en el c\u00f3digo, sino que sea la definida en el fichero de configuraci\u00f3n. De esta forma, modificando el fichero modificaremos tambi\u00e9n la configuraci\u00f3n de los tests. Para conseguirlo haremos en los tests igual que en la aplicaci\u00f3n: obteniendo la JPAApi mediante la inyecci\u00f3n de dependencias. El problema es que las anotaciones @inject no funcionan en los tests. Los tests son programas Java independientes que se ejecutan al margen de la aplicaci\u00f3n principal, que es donde se ejecuta el c\u00f3digo que inicializa los objetos inyectados. Tenemos nosotros que obtener a mano los objetos llamando expl\u00edcitamente a la librer\u00eda Guice que es la que gestiona la inyecci\u00f3n de dependencias. A continuaci\u00f3n vemos c\u00f3mo hacerlo en un test concreto, por ejemplo en el fichero UsuarioServiceTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class UsuarioServiceTest { static private Injector injector ; @BeforeClass static public void initApplication () { GuiceApplicationBuilder guiceApplicationBuilder = new GuiceApplicationBuilder (). in ( Environment . simple ()); injector = guiceApplicationBuilder . injector (); // Instanciamos un JPAApi para que inicializar JPA injector . instanceOf ( JPAApi . class ); } private UsuarioService newUsuarioService () { return injector . instanceOf ( UsuarioService . class ); } @Test public void crearNuevoUsuarioCorrectoTest (){ UsuarioService usuarioService = newUsuarioService (); Usuario usuario = usuarioService . creaUsuario ( luciaruiz , lucia.ruiz@gmail.com , 123456 ); assertNotNull ( usuario . getId ()); assertEquals ( luciaruiz , usuario . getLogin ()); assertEquals ( lucia.ruiz@gmail.com , usuario . getEmail ()); assertEquals ( 123456 , usuario . getPassword ()); } ... } En el c\u00f3digo anterior la creaci\u00f3n de un GuiceApplicationBuilder con un entorno simple realiza una inicializaci\u00f3n de la aplicaci\u00f3n Play con el fichero de configuraci\u00f3n por defecto. Despu\u00e9s se obtiene un objeto Injector que usamos para obtener instancias de clases mediante la inyecci\u00f3n de dependencias. En concreto, el m\u00e9todo newUsuarioService() obtiene del inyector una instancia de un UsuarioService . A este m\u00e9todo se llama en cada test para obtener un UsuarioService del que probar sus m\u00e9todos.","title":"Refactorizaci\u00f3n de los tests"},{"location":"02-pruebas-tdd/pruebas-tdd/#commit-refactorizacion-de-los-tests","text":"Debes crear un nuevo commit en la rama reci\u00e9n creada con la descripci\u00f3n Refactorizados tests en el que deber\u00e1s refactorizar todos los tests para que se obtengan los objetos necesarios usando inyecci\u00f3n de dependencias. Para ello realiza todos los cambios en los ficheros de tests que aparecen en el [PR","title":"Commit: Refactorizaci\u00f3n de los tests"},{"location":"02-pruebas-tdd/pruebas-tdd/#27httpsgithubcomdomingogallardomads-todolist-guiapull27files","text":"de la pr\u00e1ctica gu\u00eda. No modifiques por ahora el fichero de configuraci\u00f3n, ni crees nuevos tests (aunque son modificaciones que aparecen en el PR, no las debes hacer). Una vez hecho esto deber\u00e1s comprobar que los tests funcionan correctamente los tests con la configuraci\u00f3n original (base de datos en memoria H2 ) y a\u00f1adir en otro commit cambios para que los tests carguen una configuraci\u00f3n de base de datos alternativa, como una base de datos MySQL. En el siguiente apartado vemos c\u00f3mo hacerlo.","title":"27](https://github.com/domingogallardo/mads-todolist-guia/pull/27/files)"},{"location":"02-pruebas-tdd/pruebas-tdd/#ejecucion-de-tests-con-base-de-datos-mysql","text":"Vamos a ver c\u00f3mo lanzar una base de datos MySQL y c\u00f3mo definir el fichero de configuraci\u00f3n para que la aplicaci\u00f3n Play se conecte a ella.","title":"Ejecuci\u00f3n de tests con base de datos MySQL"},{"location":"02-pruebas-tdd/pruebas-tdd/#ejecucion-de-una-base-de-datos-mysql-con-un-contenedor-docker","text":"En primer lugar vamos a ver c\u00f3mo lanzar la base de datos MySQL. Podr\u00edamos realizar una instalaci\u00f3n de MySQL en nuestro ordenador, pero vamos a usar tambi\u00e9n Docker en lugar de ello. Utilizaremos la imagen MySQL . Para lanzar un contenedor con la imagen anterior ejecutamos el siguiente comando: 1 $ docker run -d --rm -p 3306:3306 --name play-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql Este comando lanza un contenedor que crea una base de datos llamada mads y con la contrase\u00f1a de root mads . Le da el nombre play-mysql que despu\u00e9s usaremos para enlazar con el contenedor de Play. La opci\u00f3n -p 3306:3306 permite acceder a la base de datos desde el host (lo veremos m\u00e1s adelante). Podemos comprobar que el contenedor est\u00e1 funcionando con el comando docker container ls : 1 2 3 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7c1bed0b5b7e mysql docker-entrypoint... 6 seconds ago Up 4 seconds 0.0.0.0:3306- 3306/tcp play-mysql El comando docker container ls lista los contenedores activos. Podemos usar el identificador o el nombre del contenedor para pararlo: 1 $ docker container stop play-mysql Una vez parado se borrar\u00e1 autom\u00e1ticamente por haber usado la opci\u00f3n --rm en su lanzamiento. (en el caso de no usar esta opci\u00f3n tendremos que borrarlo nosotros manualmente con el comando docker container rm play-mysql ).","title":"Ejecuci\u00f3n de una base de datos MySQL con un contenedor Docker"},{"location":"02-pruebas-tdd/pruebas-tdd/#ejecucion-de-los-tests-con-la-base-de-datos-mysql","text":"Para ejecutar los tests con la base de datos MySQL vamos a definir un nuevo fichero de configuraci\u00f3n que llamaremos integration.conf . Utilizaremos una caracter\u00edstica del sistema de configuraci\u00f3n de Play en la que podemos dar a las variables los valores definidos por variables de entorno usando la sintaxis: 1 variable = ${?VARIABLE_ENTORNO} El nuevo fichero de configuraci\u00f3n es el siguiente: Fichero conf/integration.conf 1 2 3 4 5 6 7 8 include application.conf jpa.default = mySqlPersistenceUnit db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} En primer lugar el fichero incluye la configuraci\u00f3n por defecto application.conf y despu\u00e9s modifica el valor de las variables que nos interesan. En concreto inicializamos la conexi\u00f3n JPA por defecto al perfil mySqlPersistenceUnit . Veremos m\u00e1s adelante la definici\u00f3n de este perfil en el fichero persistence.xml . Y despu\u00e9s definimos las variables necesarias para la conexi\u00f3n a una base de datos MySQL. Para que la configuraci\u00f3n sea flexible, obtenemos los valores de variables de entorno que estar\u00e1n definidas en el sistema en el que ejecutemos los tests de integraci\u00f3n. El fichero de configuraci\u00f3n de JPA debe quedar como sigue, a\u00f1adiendo el nuevo perfil de conexi\u00f3n con una base de datos MySQL (el perfil mySqlPersistenceUnit ): Fichero conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 persistence xmlns= http://xmlns.jcp.org/xml/ns/persistence xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd version= 2.1 !-- Memory persistence Unit -- persistence-unit name= memoryPersistenceUnit transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTest /non-jta-data-source properties property name= hibernate.dialect value= org.hibernate.dialect.H2Dialect / property name= hibernate.hbm2ddl.auto value= update / /properties /persistence-unit !-- MySQL Persistence Unit -- persistence-unit name= mySqlPersistenceUnit transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTest /non-jta-data-source properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= update / /properties /persistence-unit /persistence Cuando la aplicaci\u00f3n Play se conecte a la base de datos el esquema de datos de actualiza autom\u00e1ticamente debido al valor update en la propiedad hibernate.hbm2ddl.auto . Este valor indica que el esquema de datos de la base de datos se actualiza para ajustarse a las entidades definidas en la aplicaci\u00f3n. Por ejemplo, cuando se a\u00f1ade alg\u00fan atributo a alguna entidad, se a\u00f1ade autom\u00e1ticamente una columna m\u00e1s a la tabla correspondiente. Una vez realizados los cambios anteriores, y estando el contenedor docker MySQL en funcionamiento, podemos lanzar la aplicaci\u00f3n Play con el siguiente comando: 1 2 3 $ docker run --link play-mysql:mysql --rm -it -p 80:9000 -e \\ DB_URL= jdbc:mysql://play-mysql:3306/mads -e DB_USER_NAME= root -e \\ DB_USER_PASSWD= mads -v ${PWD}:/code domingogallardo/playframework /bin/bash La opci\u00f3n --link define el nombre del contenedor con el que enlazar en el que se est\u00e1 ejecutando MySQL y las opciones -e definen los valores de las variables de entorno que usar\u00e1 el fichero de configuraci\u00f3n. A\u00f1adimos /bin/bash al final para que sea este el comando que se ejecute en el contenedor, en lugar de sbt . Por ello el comando anterior lanzar\u00e1 un shell: 1 bash-4.3# Por \u00faltimo, s\u00f3lo nos falta llamar a sbt desde el shell para que cargue el nuevo fichero de configuraci\u00f3n y lance los tests: 1 bash-4.3# sbt ; set javaOptions += -Dconfig.file=conf/integration.conf ; test Tambi\u00e9n podr\u00edamos hacer un run o un testOnly : 1 2 $ sbt ; set javaOptions += -Dconfig.file=conf/integration.conf ; run $ sbt ; set javaOptions += -Dconfig.file=conf/integration.conf ; testOnly Integration* Una vez que compruebes que los tests funcionan correctamente con la base de datos MySQL puedes confirmar los cambios en un nuevo commit (puedes poner el mensaje A\u00f1adido integration.conf para conexi\u00f3n con BD Mysql ), sube el nuevo commit.","title":"Ejecuci\u00f3n de los tests con la base de datos MySQL"},{"location":"02-pruebas-tdd/pruebas-tdd/#conexion-a-la-base-de-datos-desde-el-host","text":"Es posible conectarse al servicio en el hostname 127.0.0.1 y en el puerto 3306. Por ejemplo con el cliente MySQL desde el terminal: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ mysql -h 127.0.0.1 -u root -p ... mysql use mads; Database changed mysql show tables; +--------------------+ | Tables_in_mads | +--------------------+ | Tarea | | Usuario | | hibernate_sequence | +--------------------+ 3 rows in set (0,00 sec) mysql quit; O desde alguna herramienta como el MySQL Workbench , creando una conexi\u00f3n como muestra la siguiente imagen:","title":"Conexi\u00f3n a la base de datos desde el host"},{"location":"02-pruebas-tdd/pruebas-tdd/#exportacion-del-esquema-de-datos","text":"Por \u00faltimo, vamos a terminar el issue a\u00f1adiendo al repositorio un fichero SQL con el esquema de datos. Una vez que hayas lanzado los tests JPA habr\u00e1 creado el esquema de datos en la base de datos MySQL que est\u00e1 corriendo en el contenedor play-mysql . Podemos entonces ejecutar el comando mysqldump dentro del contenedor: 1 $ docker exec play-mysql sh -c exec mysqldump --no-data mads -uroot -pmads schema.sql El comando anterior ejecuta el comando mysqldump en el contenedor docker que exporta el esquema de datos (sin los datos a\u00f1adidos) y lo graba el fichero schema.sql en el directorio actual. Ed\u00edtalo para eliminar el d\u00eda y la hora, ya que queremos que s\u00f3lo aparezca informaci\u00f3n estrictamente del esquema de la base de datos. Copia el fichero schema.sql en un nuevo directorio sql en la ra\u00edz del proyecto Play. De esta forma podremos comprobar m\u00e1s adelante las diferencias cuando modifiquemos la base de datos al evolucionar las entidades de la aplicaci\u00f3n. El fichero deber\u00eda ser parecido a este: Fichero sql/schema.sql : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 -- MySQL dump 10.13 Distrib 5.7.19, for Linux (x86_64) -- -- Host: localhost Database: mads -- ------------------------------------------------------ -- Server version 5.7.19 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */ ; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */ ; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */ ; /*!40101 SET NAMES utf8 */ ; /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */ ; /*!40103 SET TIME_ZONE= +00:00 */ ; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */ ; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */ ; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE= NO_AUTO_VALUE_ON_ZERO */ ; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */ ; -- -- Table structure for table `Tarea` -- DROP TABLE IF EXISTS ` Tarea ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Tarea ` ( ` id ` bigint ( 20 ) NOT NULL , ` titulo ` varchar ( 255 ) DEFAULT NULL , ` usuarioId ` bigint ( 20 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ), KEY ` FKepne2t52y8dmn8l9da0dd7l51 ` ( ` usuarioId ` ), CONSTRAINT ` FKepne2t52y8dmn8l9da0dd7l51 ` FOREIGN KEY ( ` usuarioId ` ) REFERENCES ` Usuario ` ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `Usuario` -- DROP TABLE IF EXISTS ` Usuario ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Usuario ` ( ` id ` bigint ( 20 ) NOT NULL , ` apellidos ` varchar ( 255 ) DEFAULT NULL , ` email ` varchar ( 255 ) DEFAULT NULL , ` fechaNacimiento ` date DEFAULT NULL , ` login ` varchar ( 255 ) DEFAULT NULL , ` nombre ` varchar ( 255 ) DEFAULT NULL , ` password ` varchar ( 255 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `hibernate_sequence` -- DROP TABLE IF EXISTS ` hibernate_sequence ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` hibernate_sequence ` ( ` next_val ` bigint ( 20 ) DEFAULT NULL ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; /*!40101 SET SQL_MODE=@OLD_SQL_MODE */ ; /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */ ; /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */ ; /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */ ; /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */ ; /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */ ; /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */ ; A\u00f1ade al final del fichero la inicializaci\u00f3n de la tabla de secuencias de Hibernate, necesaria para que Hibernate genere las claves primarias de las entidades: 1 2 3 4 5 6 7 8 9 10 -- -- Dumping data for table `hibernate_sequence` -- LOCK TABLES ` hibernate_sequence ` WRITE ; /*!40000 ALTER TABLE `hibernate_sequence` DISABLE KEYS */ ; INSERT INTO ` hibernate_sequence ` VALUES ( 1 ),( 1 ); /*!40000 ALTER TABLE `hibernate_sequence` ENABLE KEYS */ ; UNLOCK TABLES ; /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */ ; Realiza un \u00faltimo commit en el que se incluya el fichero schema.sql y cierra el issue con un pull request .","title":"Exportaci\u00f3n del esquema de datos"},{"location":"02-pruebas-tdd/pruebas-tdd/#32-configuracion-de-stage","text":"Una configuraci\u00f3n de stage es una configuraci\u00f3n de despliegue de la aplicaci\u00f3n preparada para que sea lo m\u00e1s similar posible al despliegue de producci\u00f3n. Se utiliza para realizar las pruebas funcionales y de rendimiento de la aplicaci\u00f3n. Una de las caracter\u00edsticas fundamentales de la configuraci\u00f3n de stage es que su gestor base de datos debe ser id\u00e9ntica al gestor de base de datos de producci\u00f3n, debe tener el mismo esquema de datos y contener datos similares (en cantidad y complejidad) a los que tiene la aplicaci\u00f3n en producci\u00f3n. Vamos a definir una configuraci\u00f3n de stage para nuestra aplicaci\u00f3n Play. Vamos a usar la misma imagen docker MySQL que en la configuraci\u00f3n de pruebas de integraci\u00f3n y una ejecuci\u00f3n de nuestra aplicaci\u00f3n Play en modo stage . Lo normal es definir la configuraci\u00f3n en un ordenador dedicado, y tenerla siempre en funcionamiento (de forma similar a como funciona la aplicaci\u00f3n en producci\u00f3n). En lugar de esto, para simplificar el proceso, vamos a hacer que la imagen MySQL cargue los datos que guardamos en cada nueva realizaci\u00f3n de pruebas funcionales. En cada ejecuci\u00f3n de pruebas funcionales se probar\u00e1n con los datos ya existentes y se a\u00f1adir\u00e1n nuevos datos para realizar nuevas pruebas. Al final de la sesi\u00f3n de pruebas funcionales grabaremos todos los datos en un fichero que volveremos a usar como datos iniciales la pr\u00f3xima vez que arranquemos la configuraci\u00f3n de stage . Tambi\u00e9n veremos c\u00f3mo usar sbt para desplegar y lanzar la aplicaci\u00f3n Play en modo stage . Nuevo issue: Configuraci\u00f3n entorno de stage Creamos un nuevo issue llamado Configuraci\u00f3n entorno stage . Puedes ponerle la etiqueta tech . Crea una rama en la que desarrolles este nuevo issue . Crea el fichero de conf/stage.conf : 1 2 3 4 5 6 7 8 9 10 include application.conf play.crypto.secret= abcdefghijkl jpa.default = mySqlPersistenceUnitProduction db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} A\u00f1ade en el fichero conf/META-INF/persistence.xml el nuevo perfil mySqlPersistenceUnitProduction . La \u00fanica diferencia (importante) con el perfil de integraci\u00f3n es que el hbm2ddl.auto est\u00e1 definido con el valor validate . Debido a ello, cuando arranquemos la aplicaci\u00f3n Play y se conecte a la base de datos lo primero que va a hacer JPA es comprobar que el esquema de datos (las tablas definidas en la base de datos) se corresponde con lo codificado en las entidades. En el caso en que no exista el esquema de datos o no se corresponda con el esquema definido por las entidades JPA lanzar\u00e1 un error y no funcionar\u00e1 el acceso a los datos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /properties /persistence-unit + !-- MySQL Persistence Unit - Production -- + + persistence-unit name= mySqlPersistenceUnitProduction transaction-type= RESOURCE_LOCAL + provider org.hibernate.jpa.HibernatePersistenceProvider /provider + non-jta-data-source DBTest /non-jta-data-source + class models.Usuario /class + class models.Tarea /class + properties + property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / + property name= hibernate.hbm2ddl.auto value= validate / + /properties + /persistence-unit + /persistence ``` #### Ejecuci\u00f3n de pruebas funcionales en el entorno _stage_ #### La diferencia de esta configuraci\u00f3n con la anterior es que en lugar de dejar que JPA cree las tablas de la base de datos, vamos nosotros a inicializar la base de datos MySQL con los esquemas y datos predefinidos, tal y como suceder\u00eda en producci\u00f3n. ##### Lanzamiento de MySQL ##### Para inicializar los datos de la imagen docker MySQL podemos utilizar su directorio `/docker-entrypoint-initdb.d`. Lo primero que hace la imagen es consultar ese directorio y ejecutar todos los ficheros con la extensi\u00f3n `.sql` que encuentre ah\u00ed. Los ejecuta en el orden alfab\u00e9tico del nombre de fichero. Vamos entonces a lanzar la configuraci\u00f3n de _stage_ por primera vez. Creamos un directorio `stage` fuera del repositorio git y copiamos ah\u00ed el fichero `schema.sql` del repositorio (el que contiene el esquema de base de datos actual): $ cd $ mkdir stage $ cd stage $ cp /sql/schema.sql . 1 2 Nos movemos a ese directorio y lanzamos el comando `docker run` montando el directorio actual en el directorio `/docker-entrypoint-initdb.d`: $ docker run -d --rm --name play-mysql -v ${PWD}:/docker-entrypoint-initdb.d -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql 1 2 3 4 5 6 7 8 De esta forma se lanza MySQL cargando el esquema de datos inicial (vac\u00edo). ##### Parada de MySQL ##### Cuando hayamos terminado de ejecutar las pruebas funcionales volcamos la base de datos a un fichero y paramos MySQL. Para simplificar podemos volcarlo para que sobreescriba el anterior fichero `schema.sql`: $ docker exec play-mysql sh -c 'exec mysqldump mads -uroot -pmads' schema.sql $ docker container stop play-mysql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Dejamos este fichero `schema.sql` en el directorio actual (`/stage`) para que la pr\u00f3xima vez que lancemos MySQL desde \u00e9l cargue los datos anteriormente salvados. De esta forma podemos simular que tenemos un servidor de stage en el que se mantienen los datos que se introducen en las pruebas. ##### Ejecuci\u00f3n de la aplicaci\u00f3n ##### Para ejecutar la aplicaci\u00f3n Play en modo producci\u00f3n lanzamos el contenedor play de la misma forma que hac\u00edamos para ejecutar los tests de integraci\u00f3n (definiendo las variables de entorno para que la configuraci\u00f3n se conecte con la BD y lanzando el shell bash). Y despu\u00e9s usamos el comando `stage` de sbt que crea un fichero ejecutable en el directorio `target/universal/bin/ proyecto `. Por \u00faltimo lanzamos el ejecutable generado cargando la configuraci\u00f3n `stage.conf`. $ cd $ docker run --link play-mysql:mysql --rm -it -p 80:9000 -e \\ DB_URL=\"jdbc:mysql://play-mysql:3306/mads\" -e DB_USER_NAME=\"root\" -e \\ DB_USER_PASSWD=\"mads\" -v${PWD}:/code domingogallardo/playframework /bin/bash bash-4.3# sbt clean stage bash-4.3# target/universal/stage/bin/mads-todolist-2017 -Dconfig.file=${PWD}/conf/stage.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 El ejecutable que se construye es similar al de producci\u00f3n. Sbt tiene un comando `dist` que permite generar un generar un binario listo para su distribuci\u00f3n. Puedes consultar c\u00f3mo hacerlo en [Deploying your application](https://www.playframework.com/documentation/2.5.x/Deploying). La aplicaci\u00f3n se lanza en modo producci\u00f3n y podemos abrir el navegador y realizar los tests funcionales. Ver\u00e1s que aparecen unos errores debido que el funcionamiento de la aplicaci\u00f3n en producci\u00f3n es ligeramente distinto al funcionamiento en desarrollo. En el repositorio con la gu\u00eda de la pr\u00e1ctica puedes encontrar los cambios a realizar, en el [PR #26](https://github.com/domingogallardo/mads-todolist-guia/pull/26): - A\u00f1adir getters y setters. - A\u00f1adir la declaraci\u00f3n de las clases de entidad todos los perfiles en el fichero `persistence.xml`. Arregla los errores, realiza un \u00faltimo commit y **cierra el _issue_ con un pull request**. ## 4. Nueva historia de usuario: tableros (usando TDD) ## La \u00faltima parte de la pr\u00e1ctica consiste en desarrollar, utilizando TDD (_Test Driven Design_) una nueva historia de usuario: **Creaci\u00f3n y asociaci\u00f3n a tableros**. kbd img src= imagenes/historias-usuario.png width= 600px / /kbd Definimos la descripci\u00f3n de la historia que se muestra en la siguiente imagen: kbd img src= imagenes/historia-tableros.png width= 600px / /kbd Implementaremos cada _issue_ de la capa de modelo o la capa de servicios utilizando el ciclo de desarrollo de TDD (el c\u00f3digo de la capa de vista y controlador tambi\u00e9n se deber\u00eda probar de esta forma, pero no lo vamos a hacer por falta de tiempo): 1. Escribir un test que falla. 2. Escribir el c\u00f3digo que hace que el test deje de fallar. 3. Refactorizar el c\u00f3digo de los tests y el c\u00f3digo escrito (sin a\u00f1adir nuevos tests, ni nuevas funcionalidades). 4. Volver al paso 1 Un resumen de lo que deber\u00e1s hacer en esta \u00faltima parte de la pr\u00e1ctica: - Desarrollar\u00e1s uno a uno los nuevos _issues_ de la historia de usuario. - Al igual que hicimos en la pr\u00e1ctica 1, cada _issue_ debe desarrollarse en una rama independiente. Despu\u00e9s crearemos un pull request y, tras pasar los tests de integraci\u00f3n, lo integraremos con master (consultar en el apartado 3.1 c\u00f3mo realizar los tests de integraci\u00f3n antes de aprobar el pull request). - Todos los ficheros de tests deber\u00e1n crearse en un directorio con el nombre de la historia de usuario. Por ejemplo `sg3-creacion-asociacion-tableros`. - Definir\u00e1s un fichero de test por cada _issue_, que contendr\u00e1 todos los tests necesarios para implementar el _issue_ y se denominar\u00e1 con un nombre similar. - Cada test, junto con el c\u00f3digo desarrollado para pasarlo, ir\u00e1 en un commit. - Es posible hacer commits con refactorizaciones (recuerda el ciclo de TDD: Test, Codigo y Refactorizaci\u00f3n). - Utilizar\u00e1s DBUnit para poder hacer pruebas con datos iniciales, a\u00f1adiendo nuevos datos en el fichero `usuarios_dataset.xml`. Veamos a continuaci\u00f3n como ejemplo el desarrollo completo del primer _issue_. ### 4.1. Primer _issue_: Modelo de tablero y repositorio b\u00e1sico En este _issue_ completaremos una clase b\u00e1sica de entidad `Tablero` con los atributos: - Nombre - Administrador (relaci\u00f3n a-uno con la entidad `Usuario`) Tambi\u00e9n crearemos la clase `TableroRepository` con un primer m\u00e9todo para crear tableros. Para implementar esta caracter\u00edstica usando TDD crearemos el fichero de test `test/sg3-creacion-asociacion-tableros/ModeloRepositorioTableroTest.java` en el que iremos a\u00f1adiendo los distintos tests que ir\u00e1n construyendo el c\u00f3digo. Abrimos una rama en la que iremos a\u00f1adiendo los commits del _issue_ (uno por cada test). $ git checkout -b modelo-tablero 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Empezamos ahora a usar TDD para implementar el _issue_. El primer test nos servir\u00e1 para definir los elementos b\u00e1sicos de la entidad `Tablero`. #### Commit 1: Primer test #### Empezamos con el test m\u00e1s sencillo: crear un tablero. Para crear un tablero necesitaremos pasar un usuario y un nombre de tablero. **Fichero `test/sg3-creacion-asociacion-tableros/ModeloRepositorioTableroTest.java`**: ```java import org.junit.*; import static org.junit.Assert.*; import models.Usuario; import models.Tablero; public class ModeloRepositorioTableroTest { @Test public void testCrearTablero() { Usuario usuario = new Usuario( juangutierrez , juangutierrez@gmail.com ); Tablero tablero = new Tablero(usuario, Tablero 1 ); assertEquals( juangutierrez , tablero.getAdministrador().getLogin()); assertEquals( juangutierrez@gmail.com , tablero.getAdministrador().getEmail()); assertEquals( Tablero 1 , tablero.getNombre()); } } Lanzamos los tests y, evidentemente, obtendremos errores de compilaci\u00f3n porque no existen las clases: 1 2 3 4 5 6 7 [mads-todolist-2017] $ testOnly [info] Compiling 6 Java sources to /code/target/scala-2.11/test-classes... [error] /code/test/models/TableroTest.java:5: cannot find symbol [error] symbol: class Tablero [error] location: package models ... [error] Total time: 15 s, completed Sep 30, 2017 3:30:33 PM Creamos las clases con solo el c\u00f3digo necesario para que el test pase : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import org.junit.* ; import static org.junit.Assert.* ; import models.Usuario ; import models.Tablero ; public class ModeloRepositorioTableroTest { @Test public void testCrearTablero () { Usuario usuario = new Usuario ( juangutierrez , juangutierrez@gmail.com ); Tablero tablero = new Tablero ( usuario , Tablero 1 ); assertEquals ( juangutierrez , tablero . getAdministrador (). getLogin ()); assertEquals ( juangutierrez@gmail.com , tablero . getAdministrador (). getEmail ()); assertEquals ( Tablero 1 , tablero . getNombre ()); } } Hacemos un commit con el test y el c\u00f3digo que hemos creado 1 2 3 $ git add . $ git status $ git commit -m Creada clase Tablero","title":"3.2. Configuraci\u00f3n de stage"},{"location":"02-pruebas-tdd/pruebas-tdd/#commit-2-segundo-test","text":"Vamos con un segundo test en el que a\u00f1adimos otro peque\u00f1o incremento: creaci\u00f3n del JPATableroRepository y comprobaci\u00f3n de que se obtiene correctamente un objeto TableroRepository . Escribimos el test, a\u00f1adiendo el c\u00f3digo al fichero existente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import org.junit.*; import static org.junit.Assert.*; +import play.inject.guice.GuiceApplicationBuilder; +import play.inject.Injector; +import play.inject.guice.GuiceInjectorBuilder; +import play.Environment; + +import play.db.jpa.*; + import models.Usuario; import models.Tablero; +import models.TableroRepository; public class ModeloRepositorioTableroTest { + static private Injector injector; + + @BeforeClass + static public void initApplication() { + GuiceApplicationBuilder guiceApplicationBuilder = + new GuiceApplicationBuilder().in(Environment.simple()); + injector = guiceApplicationBuilder.injector(); + // Necesario para inicializar JPA + injector.instanceOf(JPAApi.class); + } @Test public void testCrearTablero() { ... assertEquals( juangutierrez@gmail.com , tablero.getAdministrador().getEmail()); assertEquals( Tablero 1 , tablero.getNombre()); } + + @Test + public void testObtenerTableroRepository() { + TableroRepository tableroRepository = injector.instanceOf(TableroRepository.class); + assertNotNull(tableroRepository); + } } Lanzamos el test y comprobamos que no funciona. Escribimos el c\u00f3digo m\u00ednimo para hacer que funcione: Fichero models/TableroRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package models ; import javax.inject.Inject ; import play.db.jpa.JPAApi ; import java.util.List ; import javax.persistence.EntityManager ; public class TableroRepository { JPAApi jpaApi ; @Inject public TableroRepository ( JPAApi api ) { this . jpaApi = api ; } } Comprobamos que el test funciona: 1 2 3 4 5 6 [mads-todolist-2017] $ testOnly ModeloRepositorio* [info] Test run started ... [info] Test ModeloRepositorioTableroTest.testObtenerTableroRepository started [info] Test run finished: 0 failed, 0 ignored, 2 total, 12.975s [info] Passed: Total 2, Failed 0, Errors 0, Passed 2 Una vez que el test pasa correctamente hacemos una refactorizaci\u00f3n , sin tocar el test, para convertir TableroRepository en una interfaz y definir una clase espec\u00edfica de la interfaz: JPATableroRepository : Fichero models/TableroRepository.java : 1 2 3 4 5 6 7 8 9 package models ; import com.google.inject.ImplementedBy ; import java.util.List ; @ImplementedBy ( JPATableroRepository . class ) public interface TableroRepository { } Fichero models/JPATableroRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package models ; import javax.inject.Inject ; import play.db.jpa.JPAApi ; import java.util.List ; import javax.persistence.EntityManager ; public class JPATableroRepository implements TableroRepository { JPAApi jpaApi ; @Inject public JPATableroRepository ( JPAApi api ) { this . jpaApi = api ; } } Terminamos haciendo el commit del segundo test: 1 2 3 $ git status $ git add . $ git commit -m Creado TableroRepository","title":"Commit 2: Segundo test"},{"location":"02-pruebas-tdd/pruebas-tdd/#commit-3-tercer-test","text":"En el tercer test vamos a comprobar si se crea la tabla TABLERO en la base de datos. Fallar\u00e1 y escribiremos el c\u00f3digo para que pase. El test consistir\u00e1 en buscar en los metadatos de la base de datos si existe esa tabla. Cambios en el fichero test/sg3-creacion-asociacion-tableros/ModeloRepositorioTableroTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import org.dbunit.dataset.xml.*; import org.dbunit.operation.*; import java.io.FileInputStream; +import play.db.Database; +import play.db.Databases; + +import java.sql.*; + import models.Usuario; ... + + @Test + public void testCrearTablaTableroEnBD() throws Exception { + Database db = injector.instanceOf(Database.class); + Connection connection = db.getConnection(); + DatabaseMetaData meta = connection.getMetaData(); + ResultSet res = meta.getTables(null, null, TABLERO , new String[] { TABLE }); + assertTrue(res.next()); + } } El test fallar\u00e1 porque la tabla TABLERO no se encuentra. Modificamos entonces el c\u00f3digo para solucionarlo, a\u00f1adiendo las anotaciones JPA a la clase Tablero : Cambios en el fichero models/Tablero.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 +import javax.persistence.*; + +@Entity public class Tablero { + @Id + @GeneratedValue(strategy=GenerationType.AUTO) + Long id; private String nombre; + @ManyToOne + @JoinColumn(name= administradorId ) private Usuario administrador; + public Tablero() {} + public Tablero(Usuario administrador, String nombre) { this.nombre = nombre; this.administrador = administrador; } + public Long getId() { + return id; + } + + public void setId(Long id) { + this.id = id; + } + public String getNombre() { return nombre; } + public void setNombre(String nombre) { + this.nombre = nombre; + } + public Usuario getAdministrador() { return administrador; } + + public void setAdministrador(Usuario usuario) { + this.administrador = administrador; + } } Y en el fichero persistence.xml debemos a\u00f1adir la nueva clase entidad: Cambios en el fichero conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 non-jta-data-source DBTest /non-jta-data-source class models.Usuario /class class models.Tarea /class + class models.Tablero /class properties property name= hibernate.dialect value= org.hibernate.dialect.H2Dialect / property name= hibernate.hbm2ddl.auto value= update / ... non-jta-data-source DBTest /non-jta-data-source class models.Usuario /class class models.Tarea /class + class models.Tablero /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= update / ... non-jta-data-source DBTest /non-jta-data-source class models.Usuario /class class models.Tarea /class + class models.Tablero /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= validate / Realiza los cambios, reflexionando sobre lo que hacen, y comprueba que el test pasa. Ya puedes cerrar el commit, llam\u00e1ndolo por ejemplo A\u00f1adida entidad Tablero : 1 2 $ git add . $ git commit -m A\u00f1adida entidad Tablero","title":"Commit 3: Tercer test"},{"location":"02-pruebas-tdd/pruebas-tdd/#commit-4-cuarto-test","text":"Este cuarto test va a servir para crear la funci\u00f3n add() en el TableroRepository . A\u00f1adimos el siguiente test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import models.TableroRepository; +import models.UsuarioRepository; public class ModeloRepositorioTableroTest { static private Injector injector; ... + @Test + public void testAddTableroInsertsDatabase() { + UsuarioRepository usuarioRepository = injector.instanceOf(UsuarioRepository.class); + TableroRepository tableroRepository = injector.instanceOf(TableroRepository.class); + Usuario administrador = new Usuario( juangutierrez , juangutierrez@gmail.com ); + administrador = usuarioRepository.add(administrador); + Tablero tablero = new Tablero(administrador, Tablero 1 ); + tablero = tableroRepository.add(tablero); + assertNotNull(tablero.getId()); + assertEquals( Tablero 1 , getNombreFromTableroDB(tablero.getId())); + } + private String getNombreFromTableroDB(Long tableroId) { + Database db = injector.instanceOf(Database.class); + String nombre = db.withConnection(connection - { + String selectStatement = SELECT Nombre FROM Tablero WHERE ID = ? ; + PreparedStatement prepStmt = connection.prepareStatement(selectStatement); + prepStmt.setLong(1, tableroId); + ResultSet rs = prepStmt.executeQuery(); + rs.next(); + return rs.getString( Nombre ); + }); + return nombre; + } } El test fallar\u00e1. Y escribimos el c\u00f3digo para que pase: Fichero models/JPATableroRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class JPATableroRepository implements TableroRepository { public JPATableroRepository(JPAApi api) { this.jpaApi = api; } + + public Tablero add(Tablero tablero) { + return jpaApi.withTransaction(entityManager - { + entityManager.persist(tablero); + entityManager.flush(); + entityManager.refresh(tablero); + return tablero; + }); + } } Fichero models/TableroRepository.java : 1 2 3 4 @ImplementedBy(JPATableroRepository.class) public interface TableroRepository { + public Tablero add(Tablero tablero); } Comprueba que el test pasa. Si lanzas todos los tests, ver\u00e1s que algunos fallan. Esto es debido a que el test anterior introduce en la base de datos un usuario nuevo y un tablero con una clave ajena que lo referencia. Cuando DbUnit intenta limpiar la tabla de usuarios en otros tests se provoca un error Referential integrity constraint violation porque existe un tablero que se quedar\u00eda sin usuario administrador. La forma m\u00e1s f\u00e1cil de solucionarlo es a\u00f1adir al data set de DbUnit un elemento Tablero/ para provocar que se borren todos los datos tambi\u00e9n de la tabla Tablero : Fichero test/resources/usuarios_dataset.xml : 1 2 3 4 5 6 7 dataset Usuario id= 1000 login= juangutierrez nombre= Juan apellidos= Gutierrez password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / Tarea id= 1000 titulo= Renovar DNI usuarioId= 1000 / Tarea id= 1001 titulo= Pr\u00e1ctica 1 MADS usuarioId= 1000 / + Tablero/ /dataset Por \u00faltimo, refactoriza el c\u00f3digo para eliminar duplicidad de la inicializaci\u00f3n de la variable db en dos tests. Mueve esa inicializaci\u00f3n al m\u00e9todo @BeforeClass . Realiza un nuevo commit: 1 2 $ git add . $ git commit -m A\u00f1adido m\u00e9todo add() en TableroRepository","title":"Commit 4: Cuarto test"},{"location":"02-pruebas-tdd/pruebas-tdd/#commit-5-refactorizacion","text":"Vamos ahora a hacer un commit en el que vamos a refactorizar el c\u00f3digo para arreglar un par de problemas. Los tests nos servir\u00e1n para comprobar que no se introduce ning\u00fan error.","title":"Commit 5: Refactorizaci\u00f3n"},{"location":"02-pruebas-tdd/pruebas-tdd/#transformacion-list-en-set","text":"En primer lugar vamos a arreglar un error que hemos cometido al definir las entidades. Realiza una refactorizaci\u00f3n en la que deber\u00e1s convertir el tipo del atributo tareas de Usuario de tipo List a tipo Set . Deber\u00e1 quedar como sigue: Fichero models/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 - import java.util.List; - import java.util.ArrayList; + import java.util.Set; + import java.util.HashSet; @Entity public class Usuario { ... private Date fechaNacimiento; // Relaci\u00f3n uno-a-muchos entre usuario y tarea @OneToMany(mappedBy= usuario , fetch=FetchType.EAGER) - public List Tarea tareas = new Tarea (); + public Set Tarea tareas = new HashSet Tarea (); ... La raz\u00f3n de la refactorizaci\u00f3n es que es m\u00e1s correcto definir las colecciones de los atributos de las entidades del tipo Set porque eso garantiza que no habr\u00e1 elementos repetidos en las colecciones. Realiza todos los cambios necesarios y aseg\u00farate de que se siguen pasando todos los tests.","title":"Transformaci\u00f3n List en Set"},{"location":"02-pruebas-tdd/pruebas-tdd/#conversion-de-long-a-long","text":"Para corregir otro error que no han detectado los tests debemos realizar la siguiente refactorizaci\u00f3n: en los m\u00e9todos equals de Tarea y Usuario hacer una conversi\u00f3n de Long a long , para que realmente detecte como iguales dos identificadores iguales (el m\u00e9todo == compara referencias). Para comprobar que el c\u00f3digo ten\u00eda el error modificamos el test testEqualsTareasConId del fichero TareaTest.java : Fichero test/models/TareaTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Test #14: testEqualsTareasConId @Test public void testEqualsTareasConId() { Usuario usuario = new Usuario( juangutierrez , juangutierrez@gmail.com ); Tarea tarea1 = new Tarea(usuario, Pr\u00e1ctica 1 de MADS ); Tarea tarea2 = new Tarea(usuario, Renovar DNI ); Tarea tarea3 = new Tarea(usuario, Pagar el alquiler ); - tarea1.setId(1L); - tarea2.setId(1L); + tarea1.setId(1000L); + tarea2.setId(1000L); tarea3.setId(2L); assertEquals(tarea1, tarea2); assertNotEquals(tarea1, tarea3); } Si lanzamos el test comprobaremos que dos tareas que deber\u00edan ser iguales porque tienen el mismo identificador, son detectadas como distintas. Para conseguir hacer pasar el test debemos cambiar en el modelo Tarea.java el siguiente c\u00f3digo del m\u00e9todo equals: 1 2 3 4 5 // Si tenemos los ID, comparamos por ID if (id != null other.id != null) - return (id == other.id); + return ((long) id == (long) other.id); // sino comparamos por campos obligatorios Comprobamos que el test ahora s\u00ed que pasa correctamente. Hacemos el mismo cambio en la clase Usuario.java , que contiene el mismo error (aunque no lo hay ning\u00fan test que lo compruebe) y a\u00f1adimos el commit: 1 2 $ git add . $ git commit -m Refactorizados List y equals","title":"Conversi\u00f3n de Long a long"},{"location":"02-pruebas-tdd/pruebas-tdd/#commit-6-quinto-test","text":"Vamos a por el siguiente test, en el que haremos posible que un usuario pueda administrar varios tableros. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 } }); return nombre; } + + @Test + public void testUsuarioAdministraVariosTableros() { + UsuarioRepository usuarioRepository = injector.instanceOf(UsuarioRepository.class); + TableroRepository tableroRepository = injector.instanceOf(TableroRepository.class); + Usuario administrador = new Usuario( juangutierrez , juangutierrez@gmail.com ); + administrador = usuarioRepository.add(administrador); + Tablero tablero1 = new Tablero(administrador, Tablero 1 ); + tableroRepository.add(tablero1); + Tablero tablero2 = new Tablero(administrador, Tablero 2 ); + tableroRepository.add(tablero2); + // Recuperamos el administrador del repository + administrador = usuarioRepository.findById(administrador.getId()); + // Y comprobamos si tiene los tableros + assertEquals(2, administrador.getAdministrados().size()); + } } Y a\u00f1adimos el c\u00f3digo para conseguir que pase: Fichero models/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Usuario { // Relaci\u00f3n uno-a-muchos entre usuario y tarea @OneToMany(mappedBy= usuario , fetch=FetchType.EAGER) private Set Tarea tareas = new HashSet Tarea (); + @OneToMany(mappedBy= administrador , fetch=FetchType.EAGER) + private Set Tablero administrados = new HashSet Tablero (); // Un constructor vac\u00edo necesario para JPA public Usuario() {} ... public class Usuario { this.tareas = tareas; } + public Set Tablero getAdministrados() { + return administrados; + } + + public void setAdministrados(Set Tablero administrados) { + this.administrados = administrados; + } + Una vez que compruebes que el test funciona correctamente, debes confirmar los cambios: 1 2 $ git add . $ git commit -m Un usuario puede administrar varios tableros","title":"Commit 6: Quinto test"},{"location":"02-pruebas-tdd/pruebas-tdd/#commit-7-sexto-y-ultimo-test","text":"Vamos por \u00faltimo a a\u00f1adir la funcionalidad de que los usuarios puedan participar en tableros y los tableros tienen varios participantes (adem\u00e1s del administrador). Empezamos con el siguiente test, en el que usamos DbUnit, para probar la posibilidad de que un usuario pueda tener varios tableros asociados: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.sql.*; +import java.util.Set; + +import play.db.jpa.*; + +import org.dbunit.*; +import org.dbunit.dataset.*; +import org.dbunit.dataset.xml.*; +import org.dbunit.operation.*; +import java.io.FileInputStream; ... + + private void initDataSet() throws Exception { + JndiDatabaseTester databaseTester = new JndiDatabaseTester( DBTest ); + IDataSet initialDataSet = new FlatXmlDataSetBuilder().build(new FileInputStream( test/resources/usuarios_dataset.xml )); + databaseTester.setDataSet(initialDataSet); + databaseTester.setSetUpOperation(DatabaseOperation.CLEAN_INSERT); + databaseTester.onSetup(); + } + + @Test + public void testUsuarioParticipaEnVariosTableros() throws Exception { + initDataSet(); + UsuarioRepository usuarioRepository = injector.instanceOf(UsuarioRepository.class); + TableroRepository tableroRepository = injector.instanceOf(TableroRepository.class); + Usuario admin = usuarioRepository.findById(1000L); + Usuario usuario = usuarioRepository.findById(1001L); + Set Tablero tableros = admin.getAdministrados(); + // Tras cargar los datos del dataset el usuario2 no tiene ning\u00fan + // tablero asociado y el usuario 1 tiene 2 tableros administrados + assertEquals(0, usuario.getTableros().size()); + assertEquals(2, tableros.size()); + for (Tablero tablero : tableros) { + // Actualizamos la relaci\u00f3n en memoria, a\u00f1adiendo el usuario + // al tablero + tablero.getParticipantes().add(usuario); + // Actualizamos la base de datos llamando al repository + tableroRepository.update(tablero); + } + // Comprobamos que se ha actualizado la relaci\u00f3n en la BD y + // el usuario pertenece a los dos tableros a los que le hemos a\u00f1adido + usuario = usuarioRepository.findById(1001L); + Set Tablero tablerosUsuario = usuario.getTableros(); + assertEquals(2, tablerosUsuario.size()); + for (Tablero tablero: tableros) { + assertTrue(tablerosUsuario.contains(tablero)); + } + } A\u00f1adimos en el data set de DbUnit lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 dataset Usuario id= 1000 login= juangutierrez nombre= Juan apellidos= Gutierrez password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / + Usuario id= 1001 login= juangutierrez2 nombre= Juan apellidos= Gutierrez Dos + password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / + Usuario id= 1002 login= juangutierrez3 nombre= Juan apellidos= Gutierrez Tres + password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / Tarea id= 1000 titulo= Renovar DNI usuarioId= 1000 / Tarea id= 1001 titulo= Pr\u00e1ctica 1 MADS usuarioId= 1000 / - Tablero/ + Tablero id= 1000 nombre= Tablero test 1 administradorId= 1000 / + Tablero id= 1001 nombre= Tablero test 2 administradorId= 1000 / /dataset Estamos a\u00f1adiendo dos usuarios nuevos y dos tableros, estos \u00faltimos administrados por el usuario 1000 ( juangutierrez ). Vamos a codificar lo necesario para que el test pase. El test anterior comprueba que un usuario pueda tener varios tableros y, aplicando TDD de forma estricta, s\u00f3lo deber\u00edamos codificar la relaci\u00f3n ONE_TO_MANY . Sin embargo, como es muy sencillo introducir directamente la relaci\u00f3n MANY_TO_MANY que necesitamos nos saltamos la regla de TDD de introducir un \u00fanico test y a\u00f1adimos el siguiente test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 + + @Test + public void testTableroTieneVariosUsuarios() throws Exception { + initDataSet(); + UsuarioRepository usuarioRepository = injector.instanceOf(UsuarioRepository.class); + TableroRepository tableroRepository = injector.instanceOf(TableroRepository.class); + // Obtenemos datos del dataset + Tablero tablero = tableroRepository.findById(1000L); + Usuario usuario1 = usuarioRepository.findById(1000L); + Usuario usuario2 = usuarioRepository.findById(1001L); + Usuario usuario3 = usuarioRepository.findById(1002L); + assertEquals(0, tablero.getParticipantes().size()); + assertEquals(0, usuario1.getTableros().size()); + // A\u00f1adimos los 3 usuarios al tablero + tablero.getParticipantes().add(usuario1); + tablero.getParticipantes().add(usuario2); + tablero.getParticipantes().add(usuario3); + tableroRepository.update(tablero); + // Comprobamos que los datos se han actualizado + tablero = tableroRepository.findById(1000L); + usuario1 = usuarioRepository.findById(1000L); + assertEquals(3, tablero.getParticipantes().size()); + assertEquals(1, usuario1.getTableros().size()); + assertTrue(tablero.getParticipantes().contains(usuario1)); + assertTrue(usuario1.getTableros().contains(tablero)); + } } En este test a\u00f1adimos tres usuarios a un tablero y despu\u00e9s comprobamos que los datos se han actualizado correctamente al recuperar el tablero del tableroRepository . Vamos entonces a escribir el c\u00f3digo que haga pasar estos dos tests. Empezamos por el modelo, a\u00f1adiendo la relaci\u00f3n MANY_TO_MANY en Usuario y Tablero : Fichero models/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private Date fechaNacimiento; // Relaci\u00f3n uno-a-muchos entre usuario y tarea @OneToMany(mappedBy= usuario , fetch=FetchType.EAGER) private Set Tarea tareas = new HashSet Tarea (); @OneToMany(mappedBy= administrador , fetch=FetchType.EAGER) private Set Tablero administrados = new HashSet Tablero (); + @ManyToMany(mappedBy= participantes , fetch=FetchType.EAGER) + private Set Tablero tableros = new HashSet Tablero (); // Un constructor vac\u00edo necesario para JPA public Usuario() {} ... this.administrados = administrados; } + public Set Tablero getTableros() { + return tableros; + } + + public void setTableros(Set Tablero tableros) { + this.tableros = tableros; + } + public String toString() { String fechaStr = null; if (fechaNacimiento != null) { En el modelo Tablero a\u00f1adimos la relaci\u00f3n y los m\u00e9todos hashCode y equals necesarios para comparar tableros y buscar tableros en colecciones (sin ese m\u00e9todo no funciona correctamente la llamada a contains del primer test): Fichero models/Tablero.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import javax.persistence.* ; + import java.util.Set ; + import java.util.HashSet ; + @Entity public class Tablero { @Id ... @ManyToOne @JoinColumn ( name = administradorId ) private Usuario administrador ; + @ManyToMany ( fetch = FetchType . EAGER ) + @JoinTable ( name = Persona_Tablero ) + private Set Usuario participantes = new HashSet Usuario (); public Tablero () {} ... public void setAdministrador ( Usuario usuario ) { this . administrador = administrador ; } + + public Set Usuario getParticipantes () { + return participantes ; + } + + public void setParticipantes ( Set Usuario participantes ) { + this . participantes = participantes ; + } + + @Override + public int hashCode () { + final int prime = 31 ; + int result = prime + (( nombre == null ) ? 0 : nombre . hashCode ()); + result = result + (( administrador == null ) ? 0 : administrador . hashCode ()); + return result ; + } + + @Override + public boolean equals ( Object obj ) { + if ( this == obj ) return true ; + if ( getClass () != obj . getClass ()) return false ; + Tablero other = ( Tablero ) obj ; + // Si tenemos los ID, comparamos por ID + if ( id != null other . id != null ) + return (( long ) id == ( long ) other . id ); + // sino comparamos por campos obligatorios + else { + if ( nombre == null ) { + if ( other . nombre != null ) return false ; + } else if (! nombre . equals ( other . nombre )) return false ; + if ( administrador == null ) { + if ( other . administrador != null ) return false ; + else if (! administrador . equals ( other . administrador )) return false ; + } + } + return true ; + } } Necesitamos tambi\u00e9n a\u00f1adir los m\u00e9todos update y findById en la interfaz TableroRepository : Fichero models/TableroRepository.java : 1 2 3 4 5 6 @ImplementedBy(JPATableroRepository.class) public interface TableroRepository { public Tablero add(Tablero tablero); + public Tablero update(Tablero tablero); + public Tablero findById(Long idTablero); } Y su implementaci\u00f3n en JPATableroRepository.java **: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 + + public Tablero update(Tablero tablero) { + return jpaApi.withTransaction(entityManager - { + Tablero actualizado = entityManager.merge(tablero); + return actualizado; + }); + } + + public Tablero findById(Long idTablero) { + return jpaApi.withTransaction(entityManager - { + return entityManager.find(Tablero.class, idTablero); + }); + } + } Lanzamos los tests y comprobamos que todo funciona correctamente. Antes de hacer el commit es necesario a\u00f1adir en el fichero usuarios_dataset.xml la l\u00ednea para limpiar la nueva tabla que genera la relaci\u00f3n MANY_TO_MANY . Si no se a\u00f1ade, fallar\u00e1n las siguientes ejecuciones de los tests. Fichero test/resources/usuarios_dataset.xml : 1 2 3 Tablero id= 1001 nombre= Tablero test 2 administradorId= 1000 / + Persona_Tablero/ /dataset Hacemos el commit y subimos la rama para crear el pull request: 1 2 3 $ git add . $ git commit -m Relaci\u00f3n muchos a muchos entre usuarios y tableros $ git push -u origin modelo-tablero En GitHub creamos el pull request con la rama.","title":"Commit 7: Sexto y \u00faltimo test"},{"location":"02-pruebas-tdd/pruebas-tdd/#42-tests-de-integracion-antes-de-cerrar-el-issue-y-confirmar-el-pull-request","text":"Con los commits anteriores hemos terminado de codificar el issue . Una vez que hemos creado el pull request en GitHub, antes de aceptarlo, debemos comprobar que funciona correctamente la integraci\u00f3n con master . GitHub nos informa si el PR tiene alg\u00fan conflicto con master . En ese caso deber\u00edamos tambi\u00e9n resolverlos. Para ello debemos hacer lo siguiente: Hacer un merge de master en la rama del issue . En este merge pueden producirse conflictos que deberemos arreglar. Una vez realizado el merge comprobar que pasan los tests de integraci\u00f3n y de stage . Si el esquema de datos ha cambiado, obtener el nuevo esquema y aplicar los cambios en la base de datos de stage . Aceptar el pull request: subir los nuevos commits al pull request, confirmarlo para realizar la integraci\u00f3n con master en remoto y actualizar la rama master local.","title":"4.2. Tests de integraci\u00f3n antes de cerrar el issue y confirmar el pull request"},{"location":"02-pruebas-tdd/pruebas-tdd/#merge-con-la-rama-master","text":"Mezclamos la rama master con la rama actual del issue . Pero antes de ello debemos actualizar master para descargar los cambios que se hayan podido subir a remoto. Aunque en este caso no habr\u00e1 ning\u00fan cambio, este paso es muy importante cuando estemos trabajando en equipo y haya m\u00faltiples issues integr\u00e1ndose simult\u00e1neamente. Una vez actualizado master volvemos a la rama modelo-tablero y realizamos el merge de master : 1 2 3 4 $ git checkout master $ git pull $ git checkout modelo-tablero $ git merge master Puede que no sea posible realizar el merge porque git detecta alg\u00fan conflicto. Aparecer\u00eda un mensaje como el siguiente: 1 2 3 4 5 $ git merge master Auto-merging app/services/TareaService.java CONFLICT (content): Merge conflict in app/services/TareaService.java Auto-merging app/models/Usuario.java CONFLICT (content): Merge conflict in app/models/Usuario.java Debes solucionarlo siguiendo las instrucciones que aparecen en el git status : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ git status On branch modelo-tablero Your branch is up-to-date with solucion/modelo-tablero . You have unmerged paths. (fix conflicts and run git commit ) (use git merge --abort to abort the merge) Changes to be committed: modified: test/models/TareaTest.java Unmerged paths: (use git add file ... to mark resolution) both modified: app/models/Usuario.java both modified: app/services/TareaService.java Debes editar los ficheros en los que haya conflicto. Ver\u00e1s que git ha modificado los ficheros incluyendo marcas que indican las l\u00edneas que est\u00e1n en conflicto. Edita las l\u00edneas para dejar el fichero como te interesa y s\u00e1lvalo. Una vez arreglados los conflictos hay que informar a git de esta resoluci\u00f3n. Como indica el git status debemos hacer un git add de los ficheros en los que hemos resuelto los conflictos: 1 2 $ git add app/models/Usuario.java $ git add app/services/TareaService.java Si hacemos ahora un git status git nos explica c\u00f3mo continuar: 1 2 3 4 5 6 7 8 9 10 $ git status On branch modelo-tablero Your branch is up-to-date with solucion/modelo-tablero2 . All conflicts fixed but you are still merging. (use git commit to conclude merge) Changes to be committed: modified: app/services/TareaService.java modified: test/models/TareaTest.java Nos dice que debemos hacer un commit para concluir el merge. Hacemos despu\u00e9s un push para subirlo a GitHub: 1 2 $ git commit -m Solucionados conflictos $ git push Veremos en GitHub que el pull request se actualiza con el nuevo commit y que ya no aparecen conflictos con master. En el caso en que no hayan aparecido conflictos no es necesario hacer un push a GitHub (no hay cambios a\u00f1adidos en la rama).","title":"Merge con la rama master"},{"location":"02-pruebas-tdd/pruebas-tdd/#tests-de-integracion","text":"Una vez realizada la integraci\u00f3n de master en la rama del issue debes lanzar los tests de integraci\u00f3n tal y como se explica en el apartado 3.1. Si aparece alg\u00fan error debes solucionarlo, crear un nuevo commit y subirlo a GitHub. En nuestro caso uno de los errores que aparecer\u00e1n est\u00e1 relacionado con c\u00f3mo se almacenan los nombres de las tablas en la base de datos H2 (memoria) y MySQL. Una de las bases de datos las guarda en may\u00fasculas y la otra no. Debes modificar el test testCrearTableTableroEnBD para contemplar las dos posibilidades: 1 2 3 4 5 6 7 8 9 10 11 12 13 @Test public void testCrearTablaTableroEnBD() throws Exception { Database db = injector.instanceOf(Database.class); Connection connection = db.getConnection(); DatabaseMetaData meta = connection.getMetaData(); - ResultSet resH2 = meta.getTables(null, null, TABLERO , new String[] { TABLE }); + // En la BD H2 el nombre de las tablas se define con may\u00fascula y en + // MySQL con min\u00fascula + ResultSet resH2 = meta.getTables(null, null, TABLERO , new String[] { TABLE }); + ResultSet resMySQL = meta.getTables(null, null, Tablero , new String[] { TABLE }); + boolean existeTabla = resH2.next() || resMySQL.next(); assertTrue(existeTabla); } Una vez que los tests de integraci\u00f3n funcionan, generamos la tabla con el esquema de datos ( schema.sql ) tal y como se explica en el apartado 3.1 y la copiamos en el directorio correspondiente del proyecto ( sql/schema.sql ). Si hay alg\u00fan cambio en el esquema git los detectar\u00e1. Podemos comprobar los cambios haciendo un git diff : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 -- +-- Table structure for table `Persona_Tablero` +-- + +DROP TABLE IF EXISTS `Persona_Tablero`; +/*!40101 SET @saved_cs_client = @@character_set_client */; +/*!40101 SET character_set_client = utf8 */; +CREATE TABLE `Persona_Tablero` ( + `tableros_id` bigint(20) NOT NULL, + `participantes_id` bigint(20) NOT NULL, + KEY `FKnghbrhyh7eal30o78h3293n72` (`participantes_id`), + KEY `FKbpw5yq3ofgud0ra8a916kddjm` (`tableros_id`), + CONSTRAINT `FKbpw5yq3ofgud0ra8a916kddjm` FOREIGN KEY (`tableros_id`) REFERENCES `Tablero` (`id`), + CONSTRAINT `FKnghbrhyh7eal30o78h3293n72` FOREIGN KEY (`participantes_id`) REFERENCES `Usuario` (`id`) +) ENGINE=InnoDB DEFAULT CHARSET=latin1; +/*!40101 SET character_set_client = @saved_cs_client */; + +-- +-- Table structure for table `Tablero` +-- + +DROP TABLE IF EXISTS `Tablero`; +/*!40101 SET @saved_cs_client = @@character_set_client */; +/*!40101 SET character_set_client = utf8 */; +CREATE TABLE `Tablero` ( + `id` bigint(20) NOT NULL, + `nombre` varchar(255) DEFAULT NULL, + `administradorId` bigint(20) DEFAULT NULL, + PRIMARY KEY (`id`), + KEY `FKq82919iay2b8h77msdj8289p0` (`administradorId`), + CONSTRAINT `FKq82919iay2b8h77msdj8289p0` FOREIGN KEY (`administradorId`) REFERENCES `Usuario` (`id`) +) ENGINE=InnoDB DEFAULT CHARSET=latin1; +/*!40101 SET character_set_client = @saved_cs_client */; + +-- En este caso los cambios consisten en las dos tablas nuevas a\u00f1adidas. Una para la entidad Tablero y otra para mantener la relaci\u00f3n MANY_TO_MANY con Usuario . A\u00f1adimos los cambios del esquema con un commit y los subimos a GitHub: 1 2 3 $ git add sql/schema.sql $ git commit -m Cambios en el esquema SQL $ git push","title":"Tests de integraci\u00f3n"},{"location":"02-pruebas-tdd/pruebas-tdd/#tests-de-stage","text":"Si lanzamos ahora el entorno stage tal y como explicamos en el apartado 3.2 comprobaremos que la aplicaci\u00f3n no funciona, porque el esquema guardado no se corresponde con el de la aplicaci\u00f3n. Debemos crear un script de actualizaci\u00f3n de la base de datos a partir de los cambios observados en el apartado anterior. En nuestro caso el script consistir\u00e1 en las mismas sentencias SQL para crear las nuevas tablas. En otros casos tendr\u00e1s que hacer un ALTER TABLE para actualizar tablas ya existentes con nuevas columnas. Llamamos al fichero Upgrade.sql : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */ ; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */ ; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */ ; /*!40101 SET NAMES utf8 */ ; /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */ ; /*!40103 SET TIME_ZONE= +00:00 */ ; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */ ; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */ ; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE= NO_AUTO_VALUE_ON_ZERO */ ; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */ ; CREATE TABLE ` Persona_Tablero ` ( ` tableros_id ` bigint ( 20 ) NOT NULL , ` participantes_id ` bigint ( 20 ) NOT NULL , KEY ` FKnghbrhyh7eal30o78h3293n72 ` ( ` participantes_id ` ), KEY ` FKbpw5yq3ofgud0ra8a916kddjm ` ( ` tableros_id ` ), CONSTRAINT ` FKbpw5yq3ofgud0ra8a916kddjm ` FOREIGN KEY ( ` tableros_id ` ) REFERENCES ` Tablero ` ( ` id ` ), CONSTRAINT ` FKnghbrhyh7eal30o78h3293n72 ` FOREIGN KEY ( ` participantes_id ` ) REFERENCES ` Usuario ` ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; CREATE TABLE ` Tablero ` ( ` id ` bigint ( 20 ) NOT NULL , ` nombre ` varchar ( 255 ) DEFAULT NULL , ` administradorId ` bigint ( 20 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ), KEY ` FKq82919iay2b8h77msdj8289p0 ` ( ` administradorId ` ), CONSTRAINT ` FKq82919iay2b8h77msdj8289p0 ` FOREIGN KEY ( ` administradorId ` ) REFERENCES ` Usuario ` ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; La l\u00ednea 1 /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */ ; es importante porque le indica a MySQL que no chequee la existencia de claves ajenas al crear las tablas. De esta forma podemos crearlas en el orden en el que aparecen. Guardamos el fichero upgrade.sql en el mismo directorio stage en el que est\u00e1 el fichero schema.sql con el backup de los datos de anteriores ejecuciones de pruebas funcionales en el directorio. Al arrancar el contenedor docker MySQL de stage (ver apartado 3.2) se cargar\u00e1n los ficheros SQL en orden alfab\u00e9tico, de forma que primero se cargar\u00e1n los datos anteriores (fichero schema.sql ) y despu\u00e9s se realizar\u00e1 la actualizaci\u00f3n (fichero upgrade.sql ). Arrancamos la aplicaci\u00f3n Play en modo stage (ver apartado 3.2) y comprobamos que todo funciona correctamente. Por \u00faltimo a\u00f1adimos el fichero upgrade.sql al proyecto en el directorio SQL, llam\u00e1ndolo upgrade1.sql . De esta forma guardamos tambi\u00e9n los scripts de actualizaci\u00f3n en el control de versiones. 1 2 3 $ cp upgrade.sql DIR_PROYECTO/sql/upgrade1.sql $ git commit -m A\u00f1adido fichero actualizaci\u00f3n BD $ git push","title":"Tests de stage"},{"location":"02-pruebas-tdd/pruebas-tdd/#confirmacion-del-pull-request","text":"Por \u00faltimo confirmamos el pull request en GitHub y se hace la integraci\u00f3n en master remoto. Borramos la rama remota modelo-tablero . Actualizamos la mezcla en local y borramos tambi\u00e9n la rama local: 1 2 3 4 $ git checkout master $ git pull $ git branch -d modelo-tablero $ git remote prune origin","title":"Confirmaci\u00f3n del pull request"},{"location":"02-pruebas-tdd/pruebas-tdd/#43-resto-de-issues-parte-obligatoria","text":"Termina los issues 2 y 3 de la historia de usuario, realizando el primero tambi\u00e9n con TDD: M\u00e9todos de servicio para crear un tablero y para obtener el listado de tableros administrados por un usuario. Controlador, acci\u00f3n y vista para un listado de tableros administrados y posibilidad de a\u00f1adir nuevos tableros administrados.","title":"4.3. Resto de issues (parte obligatoria)"},{"location":"02-pruebas-tdd/pruebas-tdd/#44-resto-de-issues-parte-opcional","text":"Termina los issues 4, 5, 6 y 7, haciendo con TDD todos los correspondientes a m\u00e9todos de servicio: M\u00e9todos de servicio para apuntarse a un tablero (como participante) y para obtener los siguientes listados: Listado de tableros en los que participa el usuario Listado de resto de tableros (en los que el usuario ni participa ni es administrador). Controlador, acci\u00f3n y modificaci\u00f3n de la vista con el listado de tableros para mostrar los listados anteriores y permitir apuntarse como participante a un tablero. M\u00e9todos de modelo y servicio para obtener descripci\u00f3n de un tablero (nombre, administrador y lista de participantes). Controlador y vista con descripci\u00f3n de un tablero y a\u00f1adir enlaces en el listado de tableros para que al pinchar se vaya a su descripci\u00f3n.","title":"4.4 Resto de issues (parte opcional)"},{"location":"02-pruebas-tdd/pruebas-tdd/#45-finalizacion-de-la-version-02","text":"Una vez terminada la pr\u00e1ctica, creamos un nuevo release . Cuando hayas integrado el \u00faltimo PR, haz un commit en master en el que modifiques la versi\u00f3n del proyecto en el fichero build.sbt: version := \"0.2\" Publica directamente el commit en master (sin hacer PR). A\u00f1ade en GitHub el tag con el n\u00famero de versi\u00f3n: Pincha enlace releases en la p\u00e1gina principal A\u00f1ade una nueva versi\u00f3n: v0.2 y pulsa el bot\u00f3n para publicar el release. Esto crear\u00e1 la etiqueta y la versi\u00f3n en GitHub. Por \u00faltimo, cambia la versi\u00f3n actual (en build.sbt en master ) a 0.3-SNAPSHOT haciendo y publicando un nuevo commit. De esta forma, indicamos que ahora en master se est\u00e1 desarrollando la versi\u00f3n 0.3.","title":"4.5. Finalizaci\u00f3n de la versi\u00f3n 0.2"},{"location":"02-pruebas-tdd/pruebas-tdd/#5-entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y debe estar terminada el martes 24 de octubre. La parte obligatoria punt\u00faa sobre 7 y la opcional sobre 3 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 8% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un clean . Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 3 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Correcci\u00f3n del c\u00f3digo.","title":"5. Entrega y evaluaci\u00f3n"},{"location":"03-integracion-continua/integracion-continua/","text":"Pr\u00e1ctica 3: Integraci\u00f3n continua y trabajo en equipo 1. Objetivos y resumen de la pr\u00e1ctica 2. Formaci\u00f3n de equipos 3. Configuraci\u00f3n m\u00e1quina Docker 4. Conectar el proyecto mads-todolist con Travis 4.1. C\u00f3mo darse de alta en Travis y conectar el repositorio 4.2. C\u00f3mo configurar el build en Travis 4.3. Modificaci\u00f3n del fichero .travys.yml y pull request 4.4. Modificaci\u00f3n del README del proyecto 5. Nuevo flujo de trabajo en GitHub 5.1. Comandos git para el trabajo en equipo 5.2. Desarrollo de una p\u00e1gina Acerca de 5.3. Configuraci\u00f3n de la rama production y publicaci\u00f3n de v1.0 5.4. Publicaci\u00f3n autom\u00e1tica de nuevas versiones 6. Desarrollo de caracter\u00edsticas adicionales en equipo 6.1. Funcionalidades adicionales 6.2. Publicaci\u00f3n de la versi\u00f3n 1.1 7. Entrega y evaluaci\u00f3n 1. Objetivos y resumen de la pr\u00e1ctica En esta pr\u00e1ctica se pretende conseguir: Formar equipos de trabajo y configurar GitHub para el trabajo conjunto. Crear una m\u00e1quina Docker con nuestra aplicaci\u00f3n que sea capaz tanto de ejecutar todo tipo de tests (unitarios y de integraci\u00f3n) como de poner en marcha la aplicaci\u00f3n para las pruebas funcionales. Conectar el repositorio GitHub con Travis, un servicio de integraci\u00f3n continua que cada vez que se suba un cambio a una rama (o se active un pull request) realice las siguientes tareas: Construir la m\u00e1quina Docker con la aplicaci\u00f3n Lanzar tests unitarios Lanzar tests de integraci\u00f3n Si todo funciona correctamente, publicar la nueva versi\u00f3n de la aplicaci\u00f3n a DockerHub Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo. Desarrollar caracter\u00edsticas adicionales en el proyecto siguiendo el nuevo flujo de trabajo. 2. Formaci\u00f3n de equipos Deb\u00e9is formar equipos de 3 personas . Utilizad el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear un equipo nuevo o escoger un equipo ya existente. El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre todolistgrupo-2017-NOMBRE-GRUPO . Tambi\u00e9n se crear\u00e1 un equipo en el grupo mads-ua . Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para gestionar las tarjetas con los issues y los pull requests. Creadlos con las mismas columnas que en las pr\u00e1cticas 1 y 2. Escoged el proyecto que vais a usar en estas dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente ampliable. Subidlo al nuevo repositorio, cambiando la URL del origin del repositorio local y haciendo un push: 1 2 $ git remote set-url origin https://github.com/mads-ua/todolistgrupo-2017-NOMBRE-EQUIPO.git $ git push -u origin master Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que los tres pod\u00e1is trabajar con \u00e9l en local. 3. Configuraci\u00f3n m\u00e1quina Docker El objetivo de este apartado es crear una m\u00e1quina Docker con vuestra aplicaci\u00f3n que sea capaz tanto de ejecutar todo tipo de tests (unitarios y de integraci\u00f3n) como de poner en marcha la aplicaci\u00f3n para las pruebas funcionales. Deb\u00e9is hacer lo siguiente: Crear un nuevo issue denominado Configuraci\u00f3n m\u00e1quina Docker , con el objetivo de construir un fichero Dockerfile con el que se pueda crear la m\u00e1quina Docker con nuestra aplicaci\u00f3n. Uno de los miembros del equipo deber\u00e1 ser el responsable de su implementaci\u00f3n. Consultar c\u00f3mo definir el Dockerfile en los apuntes de la sesi\u00f3n de teor\u00eda sobre integraci\u00f3n continua . Crear una rama para resolver el issue , como hac\u00edamos en las primeras pr\u00e1cticas. Cuando el Dockerfile est\u00e9 terminado, hacer un commit, un push de la rama y crear el pull request. A\u00f1adir como revisores a los otros dos miembros del equipo, que deber\u00e1n probar en su repositorio local que el Dockerfile funciona correctamente. Para actualizar el repositorio local con las nuevas ramas que se suban al repositorio remoto: ``` $ git fetch # Vemos las referencias a las ramas remotas con el nombre origin/RAMA-REMOTA $ git branch -vva # Creamos la rama local que hace tracking de la rama remota y nos # movemos a ella $ git checkout RAMA-REMOTA ``` Debe probarse que la m\u00e1quina docker es capaz de ejecutarse correctamente trabajando con las siguientes configuraciones: Ejecuci\u00f3n de tests trabajando con base de datos en memoria. Ejecuci\u00f3n de tests de integraci\u00f3n, lanzando los tests con una base de datos MySQL. Lanzamiento de una ejecuci\u00f3n de la aplicaci\u00f3n, trabajando con una configuraci\u00f3n de stage. Una vez comprobado que la m\u00e1quina Docker funciona, se aceptar\u00e1 el pull request y se integrar\u00e1 con master. Por \u00faltimo, deb\u00e9is crear una cuenta en Docker Hub y subir a ella la m\u00e1quina con el nombre DOCKER-ID/mads-todolist-2017 y el n\u00famero de versi\u00f3n 0.2. Poner en la Wiki del proyecto un enlace a la URL de la m\u00e1quina subida a Docker Hub, en una p\u00e1gina llamada Integraci\u00f3n continua . 4. Conectar el proyecto mads-todolist con Travis Travis es un servicio de integraci\u00f3n continua que se integra f\u00e1cilmente con GitHub. Tiene una versi\u00f3n gratuita para proyectos abiertos y una versi\u00f3n de pago para proyectos privados ( travis-ci.com ). La cuenta educativa de GitHub nos da permisos para trabajar en la versi\u00f3n de pago de forma gratuita. Travis se conecta con GitHub y lanza un proceso de build s\u00edncrono que descarga, compila y prueba la rama del repositorio en la que se ha subido un nuevo commit. Una vez hecha la integraci\u00f3n con Travis se podr\u00e1 comprobar en cada commit de GitHub si han pasado los tests correctamente: A su vez, en Travis, podr\u00e1s acceder y consultar los detalles de cada build: Comienza abriendo un nuevo issue llamado Integraci\u00f3n con Travis en el que desarrollar\u00e1s esta integraci\u00f3n. 4.1. C\u00f3mo darse de alta en Travis y conectar el repositorio Para darte de alta en Travis debes acceder a travis-ci.com autentific\u00e1ndote con tu cuenta de GitHub. Debes seguir las instrucciones que aparecer\u00e1n para conectar el repositorio de la pr\u00e1ctica 3 con Travis. Comprueba en los ajustes que el repositorio se ha conectado correctamente con Travis: 4.2. C\u00f3mo configurar el build en Travis El build en Travis se configura con el fichero .travis.yml que debe estar en la ra\u00edz del repositorio. En este fichero se incluye las instrucciones para compilar y ejecutar los tests del proyecto. Crea un nuevo issue llamado Integraci\u00f3n con Travis y una rama nueva en el repositorio local. A\u00f1ade el siguiente fichero de configuraci\u00f3n .travis.yml y sube la rama al repo remoto en GitHub. Fichero .travis.yml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sudo: required language: bash branches: only: - master - production services: - docker before_install: - docker build -t DOCKER-ID/mads-todolist-2017:0.2 . script: - docker run --rm DOCKER-ID/mads-todolist-2017:0.2 /bin/bash -c sbt test Pod\u00e9is ver que el fichero de configuraci\u00f3n de Travis construye la m\u00e1quina Docker y despu\u00e9s la ejecuta, lanzando los tests en memoria. Si pasan todos los tests Travis marcar\u00e1 como correcto el build. Una vez hecho el push, Travis detectar\u00e1 autom\u00e1ticamente el cambio en la rama y realizar\u00e1 el build. Podremos ver en tiempo real la ejecuci\u00f3n de los tests, en el frontal de Travis y en https://travis-ci.com/USUARIO/REPOSITORIO . Cuando pasen correctamente los tests podr\u00e9is ver el tick en el commit de GitHub. 4.3. Modificaci\u00f3n del fichero .travis.yml y pull request Modifica el fichero .travis.yml para incluir como \u00faltimo paso la ejecuci\u00f3n tambi\u00e9n de los tests de integraci\u00f3n ejecut\u00e1ndose contra una m\u00e1quina docker MySQL. Una vez comprobado que funciona correctamente, crea un pull request en GitHub para cerrar el issue. Travis lanzar\u00e1 una ejecuci\u00f3n del build del pull request, en el que mezclar\u00e1 la rama del PR con la rama master. GitHub nos informar\u00e1 tambi\u00e9n si los tests pasan correctamente y si podemos hacer la integraci\u00f3n del pull request sin problemas. Realizad el pull request y actualizad los repositorio locales. 4.4. Modificaci\u00f3n del README del proyecto Por \u00faltimo, subid un commit a master con un cambio en el README.md para incluir en \u00e9l una imagen que muestre el estado del \u00faltimo build realizado en Travis. Lo debe hacer un miembro distinto del que ha hecho el issue anterior. No hace falta crear un issue para esta modificaci\u00f3n. La imagen final del README.md deber\u00e1 ser similar a la siguiente: Puedes consultar c\u00f3mo embeber esta imagen en la p\u00e1gina de documentaci\u00f3n de Travis Embedding Status Images . Cuidado con indicar correctamente en la URL la rama de la que se va a obtener el estado (debe ser master ). Comprueba que funciona correctamente subiendo un commit a master con un fallo en alg\u00fan test. Y sube despu\u00e9s otro commit arregl\u00e1ndolo. 5. Nuevo flujo de trabajo en GitHub Como ya tenemos equipos de trabajo, debemos adaptar el flujo de trabajo tanto en GitHub a m\u00e1s de una persona. Cambiaremos lo siguiente: Selecci\u00f3n del issue : Al pasar un issue de \"Seleccionado\" a \"En marcha\" se debe asignar un responsable. Nueva rama con el issue : El responsable ser\u00e1 el que abra una rama nueva para el desarrollo del ticket y la subir\u00e1 a GitHub. Desarrollo : Se trabaja en la rama. Cualquier compa\u00f1ero puede unirse al ticket y trabajar junto con el responsable. Pull request : Cuando el ticket se ha terminado, el responsable abre un pull request en GitHub y pone la tarjeta en la columna En PR . Revisi\u00f3n de c\u00f3digo : Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing proposed changes in a pull request ). Al final, todos los miembros del equipo deben dar el OK, a\u00f1adiendo una reacci\u00f3n. Integraci\u00f3n del pull request : Cuando todos dan el OK, el responsable de la tarea integra el pull request en master . Actualizaci\u00f3n de los repositorios locales : Todos hacen un pull en master para actualizar los cambios del pull request. Y se borra la rama local ya integrada. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos del flujo de trabajo. 5.1. Comandos Git para el trabajo en equipo Veamos algunos comandos de Git relacionados con el trabajo compartido con repositorios remotos. Subir una rama al repositorio remoto: $ git checkout -b nueva-rama $ git push -u origin nueva-rama Descargar una rama del repositorio remoto: $ git fetch $ git checkout -b nueva-rama origin/nueva-rama El comando git fetch se descarga todos los cambios pero no los mezcla con las ramas locales. Los deja en ramas cacheadas a las que les da el nombre del servidor y la rama ( origin/nueva-rama ). En el caso del comando anterior, una vez cacheada la rama origin/nueva-rama se crea la nueva-rama local con todos sus commits. Actualizar una rama con cambios que otros compa\u00f1eros han subido al repositorio remoto: $ git checkout nueva-rama $ git pull El comando git pull es equivalente a un git fetch seguido de un git merge . Algunos recomiendan no usar git pull , sino hacer siempre el merge manual. Por ejemplo: $ git checkout nueva-rama $ git fetch $ git merge origin/nueva-rama Subir cambios de la rama actual: (estando en la rama que queremos subir) $ git push El comando git push funcionar\u00e1 correctamente sin m\u00e1s par\u00e1metros si previamente hemos subido la rama con un git push -u . Comprobar el estado de las ramas locales y remotas: $ git branch -vv Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un git fetch --all antes: $ git fetch --all $ git branch -vv Es importante recordar que git fetch (a diferencia de git pull ) no modifica los repositorios locales, sino que baja las ramas remotas cach\u00e9s locales. Informaci\u00f3n de los repositorios remotos: $ git remote show origin Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos. git remote -v update Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas). Borrado de ramas remotas desde el terminar: $ git push origin --delete nueva-rama $ git remote prune origin 5.2. Desarrollo de una p\u00e1gina \"Acerca de\" Probar todos los comandos anteriores en una rama en la que se implemente la p\u00e1gina \"Acerca de\" en la que se muestre una con los miembros del equipo y el n\u00famero de versi\u00f3n de la aplicaci\u00f3n (0.3-SNAPSHOT). Crear un issue en el que participen todos los miembros del equipo. Crear una rama en la que desarrollar los cambios. Cada miembro del equipo deber\u00e1 realizar un commit en el que se a\u00f1ade su nombre a la lista. Crear el pull request en GitHub, revisar el c\u00f3digo y aceptarlo. 5.3. Configuraci\u00f3n de la rama production y publicaci\u00f3n de v1.0 El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda ). Pero vamos a introducir alguna variante en la nomenclatura de las ramas. Ramas de largo recorrido En la versi\u00f3n original de GitFlow se publican las distintas versiones del proyecto en la rama long-lived master y se hace el desarrollo en la rama develop . Nosotros vamos a adoptar esta idea, pero cambiando el nombre de las ramas. La rama de desarrollo ser\u00e1 la rama master en la que hemos trabajado desde el principio, y la rama con las versiones lanzadas la llamaremos production . Ramas de feature Desde el comienzo de trabajo con Git en las pr\u00e1cticas 1 y 2 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo merge , mientras que nosotros las integramos haciendo un pull request. Configuraci\u00f3n paso a paso El equipo elegir\u00e1 un responsable de integraci\u00f3n que se encargue de crear la rama production y publicar en ella la primera versi\u00f3n v1.0 del proyecto. Cread un issue con la tarea Lanzar release v1.0 que tendr\u00e1 como responsable esta persona escogida. Una vez que se ha integrado en master el pull request con la p\u00e1gina \"Acerca de\" que contiene la lista de desarrolladores del proyecto y el n\u00famero de versi\u00f3n \"Versi\u00f3n 0.3-SNAPSHOT\", el responsable de integraci\u00f3n deber\u00e1 publicar la nueva versi\u00f3n siguiendo los pasos de GitFlow: Crear la rama production y publicarla en GitHub. Crear la rama local release-v1.0 a partir de master . Realizar en esta rama los cambios espec\u00edficos de la versi\u00f3n. En nuestro caso: Cambiar en la p\u00e1gina \"Acerca de\" \"Versi\u00f3n 0.3-SNAPSHOT\" por \"Versi\u00f3n 1.0\" A\u00f1adir en la p\u00e1gina la fecha de publicaci\u00f3n de la versi\u00f3n. Cambiar la versi\u00f3n en el build.sbt a 1.0 . Publicar la rama release-v1.0 en GitHub y hacer un pull request sobre production . Mezclar tambi\u00e9n la rama de release con master . Por \u00faltimo, hacer un commit en master cambiando el n\u00famero de versi\u00f3n a 1.1-SNAPSHOT (en el \"Acerca de\" y en el build.sbt ). Una vez hecho esto ya se puede borrar la rama release-v1.0 y las ramas production y master estar\u00e1n actualizadas a las nuevas versiones. La rama production tambi\u00e9n ser\u00e1 integrada por Travis. Debemos comprobar que pasan todos los tests. 5.4. Publicaci\u00f3n autom\u00e1tica de nuevas versiones Implementad en master un nuevo issue en el que hag\u00e1is lo siguiente: Modificar el fichero de configuraci\u00f3n de Travis para que la versi\u00f3n de la m\u00e1quina docker sea la definida por el n\u00famero de build de Travis (en la variable de entorno TRAVIS_BUILD_NUMBER ). A\u00f1adir en la configuraci\u00f3n de Travis la publicaci\u00f3n de la m\u00e1quina docker en Docker Hub cada vez que se realice un build en la rama master (consultar en la p\u00e1gina de informaci\u00f3n de Travis Using Docker in Builds ). Deber\u00e9is publicar dos versiones de la m\u00e1quina: la versi\u00f3n con el \u00faltimo n\u00famero de build y la versi\u00f3n latest . De esta forma, en Docker Hub estar\u00e1 siempre actualizada la versi\u00f3n latest a \u00faltima versi\u00f3n compilada en master y tambi\u00e9n se tendr\u00e1 un hist\u00f3rico de todas las versiones compilads. 6. Desarrollo de caracter\u00edsticas adicionales en equipo En esta parte desarrollar\u00e9is tres caracter\u00edsticas (historias de usuario) adicionales en el proyecto. Deb\u00e9is definir una p\u00e1gina en la wiki para cada una de ellas, y crear la p\u00e1gina principal de la wiki con el t\u00edtulo Versi\u00f3n 1.1 y con dos tablas ( pendientes y terminadas ) que contenga los t\u00edtulos, enlaces y una breve descripci\u00f3n de cada una de las caracter\u00edsticas (como hemos hecho en la wiki en las pr\u00e1cticas 1 y 2). Tambi\u00e9n igual que en las pr\u00e1cticas 1 y 2, se crear\u00e1 una etiqueta para cada una de las historias de usuario y se marcar\u00e1n con ella los issues que las conforman. Una de historia de usuario puede contener varios issues o s\u00f3lo uno. Tambi\u00e9n se marcar\u00e1n los issues/pull requests con el milestone 1.1 , que ser\u00e1 el n\u00famero de versi\u00f3n definitiva de la aplicaci\u00f3n cuando se termine esta pr\u00e1ctica 3. Cada historia de usuario deber\u00e1 tener un responsable distinto, que ser\u00e1 se encargar\u00e1 de realizar la formulaci\u00f3n de la historia en la p\u00e1gina wiki, descomponerla en issues y de probar que se cumplen las condiciones de satisfacci\u00f3n antes de darla por terminada. Escribid el responsable de la historia en su p\u00e1gina. Aunque lo normal es que los issues en los que se descompone una historia tengan el mismo responsable que la historia, tambi\u00e9n se pueden definir otros responsables (por ejemplo, si es un issue orientado a crear las vistas y en el equipo hay una persona que domina Bootstrap y el dise\u00f1o de interfaces de usuario). 6.1. Funcionalidades adicionales Proponemos tres historias de usuario peque\u00f1as, que se pueden desarrollar todas en una semana. Para las historias 2 y 3 se deben realizar tests, como hemos venido haciendo en las pr\u00e1cticas 1 y 2. Aunque no es obligatorio, puedes desarrollarlas usando TDD. Arreglo de la interfaz de usuario de tareas y tableros, definiendo una barra de navegaci\u00f3n de Bootstrap con las opciones: TodoList (t\u00edtulo de la aplicaci\u00f3n), Mis tareas (enlace a la p\u00e1gina de tareas), Mis tableros (enlace a la p\u00e1gina de tableros) y a la derecha un desplegable con el nombre del usuario y las opciones Perfil (enlace al perfil, si est\u00e1 implementado) y Salir (salir y enlace a login). A\u00f1adir los siguientes campos adicionales a la tarea : fechaCreacion . Poner como fecha de creaci\u00f3n la fecha y hora en la que se crea la tarea (hacerlo de forma autom\u00e1tica, sin ped\u00edrselo al usuario, ni que el usuario pueda modificarlo). Y dejar que el usuario introduzca opcionalmente la fecha l\u00edmite en la p\u00e1gina de creaci\u00f3n/edici\u00f3n de una tarea. En la tabla con el listado de tareas no mostrar la fecha de creaci\u00f3n (es un atributo interno, que por ahora no mostramos) pero s\u00ed la fecha l\u00edmite. A\u00f1adir un campo adicional de terminado a las tareas. A\u00f1adir una acci\u00f3n en el listado de tareas para terminar una tarea. En el listado de tareas aparecer\u00e1n solo las tareas que no se hayan terminado. Pon un enlace Terminadas para mostrar las tareas terminadas. Si quer\u00e9is incluir alguna funcionalidad opcional que hay\u00e1is implementado, pod\u00e9is hacerlo adem\u00e1s de lo anterior. Deb\u00e9is a\u00f1adir la p\u00e1gina correspondiente con la funcionalidad en la wiki. 6.2. Publicaci\u00f3n de la versi\u00f3n 1.1 Una vez terminadas y probadas todas las historias de usuario, se deber\u00e1 crear una rama para la versi\u00f3n 1.1 e integrarla en la rama production tal y como se ha hecho con la versi\u00f3n 1.0. Realizar en la rama de versi\u00f3n los commits necesarios para el cambio de versi\u00f3n (en el fichero build.sbt y en la p\u00e1gina Acerca de ) y para actualizar los ficheros relacionados con el esquema de datos (el fichero schema.sql y upgradeXX.sql ). Igual que se hizo con la versi\u00f3n 1.0, terminar integrando esta rama tambi\u00e9n en master y modificando el n\u00famero de versi\u00f3n a 1.2-SNAPSHOT . 7. Entrega y evaluaci\u00f3n La pr\u00e1ctica tiene una duraci\u00f3n de 2 semanas y debe estar terminada el martes 21 de noviembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 7% en la nota final de la asignatura. Para realizar la entrega uno de los miembros del equipo debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo la historia Git. Para ello comprime el directorio local del proyecto despu\u00e9s de haber hecho un clean . Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 2 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Correcci\u00f3n del c\u00f3digo.","title":"Pr\u00e1ctica 3: Integraci\u00f3n continua y trabajo en equipo"},{"location":"03-integracion-continua/integracion-continua/#practica-3-integracion-continua-y-trabajo-en-equipo","text":"1. Objetivos y resumen de la pr\u00e1ctica 2. Formaci\u00f3n de equipos 3. Configuraci\u00f3n m\u00e1quina Docker 4. Conectar el proyecto mads-todolist con Travis 4.1. C\u00f3mo darse de alta en Travis y conectar el repositorio 4.2. C\u00f3mo configurar el build en Travis 4.3. Modificaci\u00f3n del fichero .travys.yml y pull request 4.4. Modificaci\u00f3n del README del proyecto 5. Nuevo flujo de trabajo en GitHub 5.1. Comandos git para el trabajo en equipo 5.2. Desarrollo de una p\u00e1gina Acerca de 5.3. Configuraci\u00f3n de la rama production y publicaci\u00f3n de v1.0 5.4. Publicaci\u00f3n autom\u00e1tica de nuevas versiones 6. Desarrollo de caracter\u00edsticas adicionales en equipo 6.1. Funcionalidades adicionales 6.2. Publicaci\u00f3n de la versi\u00f3n 1.1 7. Entrega y evaluaci\u00f3n","title":"Pr\u00e1ctica 3: Integraci\u00f3n continua y trabajo en equipo"},{"location":"03-integracion-continua/integracion-continua/#1-objetivos-y-resumen-de-la-practica","text":"En esta pr\u00e1ctica se pretende conseguir: Formar equipos de trabajo y configurar GitHub para el trabajo conjunto. Crear una m\u00e1quina Docker con nuestra aplicaci\u00f3n que sea capaz tanto de ejecutar todo tipo de tests (unitarios y de integraci\u00f3n) como de poner en marcha la aplicaci\u00f3n para las pruebas funcionales. Conectar el repositorio GitHub con Travis, un servicio de integraci\u00f3n continua que cada vez que se suba un cambio a una rama (o se active un pull request) realice las siguientes tareas: Construir la m\u00e1quina Docker con la aplicaci\u00f3n Lanzar tests unitarios Lanzar tests de integraci\u00f3n Si todo funciona correctamente, publicar la nueva versi\u00f3n de la aplicaci\u00f3n a DockerHub Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo. Desarrollar caracter\u00edsticas adicionales en el proyecto siguiendo el nuevo flujo de trabajo.","title":"1. Objetivos y resumen de la pr\u00e1ctica"},{"location":"03-integracion-continua/integracion-continua/#2-formacion-de-equipos","text":"Deb\u00e9is formar equipos de 3 personas . Utilizad el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear un equipo nuevo o escoger un equipo ya existente. El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre todolistgrupo-2017-NOMBRE-GRUPO . Tambi\u00e9n se crear\u00e1 un equipo en el grupo mads-ua . Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para gestionar las tarjetas con los issues y los pull requests. Creadlos con las mismas columnas que en las pr\u00e1cticas 1 y 2. Escoged el proyecto que vais a usar en estas dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente ampliable. Subidlo al nuevo repositorio, cambiando la URL del origin del repositorio local y haciendo un push: 1 2 $ git remote set-url origin https://github.com/mads-ua/todolistgrupo-2017-NOMBRE-EQUIPO.git $ git push -u origin master Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que los tres pod\u00e1is trabajar con \u00e9l en local.","title":"2. Formaci\u00f3n de equipos"},{"location":"03-integracion-continua/integracion-continua/#3-configuracion-maquina-docker","text":"El objetivo de este apartado es crear una m\u00e1quina Docker con vuestra aplicaci\u00f3n que sea capaz tanto de ejecutar todo tipo de tests (unitarios y de integraci\u00f3n) como de poner en marcha la aplicaci\u00f3n para las pruebas funcionales. Deb\u00e9is hacer lo siguiente: Crear un nuevo issue denominado Configuraci\u00f3n m\u00e1quina Docker , con el objetivo de construir un fichero Dockerfile con el que se pueda crear la m\u00e1quina Docker con nuestra aplicaci\u00f3n. Uno de los miembros del equipo deber\u00e1 ser el responsable de su implementaci\u00f3n. Consultar c\u00f3mo definir el Dockerfile en los apuntes de la sesi\u00f3n de teor\u00eda sobre integraci\u00f3n continua . Crear una rama para resolver el issue , como hac\u00edamos en las primeras pr\u00e1cticas. Cuando el Dockerfile est\u00e9 terminado, hacer un commit, un push de la rama y crear el pull request. A\u00f1adir como revisores a los otros dos miembros del equipo, que deber\u00e1n probar en su repositorio local que el Dockerfile funciona correctamente. Para actualizar el repositorio local con las nuevas ramas que se suban al repositorio remoto: ``` $ git fetch # Vemos las referencias a las ramas remotas con el nombre origin/RAMA-REMOTA $ git branch -vva # Creamos la rama local que hace tracking de la rama remota y nos # movemos a ella $ git checkout RAMA-REMOTA ``` Debe probarse que la m\u00e1quina docker es capaz de ejecutarse correctamente trabajando con las siguientes configuraciones: Ejecuci\u00f3n de tests trabajando con base de datos en memoria. Ejecuci\u00f3n de tests de integraci\u00f3n, lanzando los tests con una base de datos MySQL. Lanzamiento de una ejecuci\u00f3n de la aplicaci\u00f3n, trabajando con una configuraci\u00f3n de stage. Una vez comprobado que la m\u00e1quina Docker funciona, se aceptar\u00e1 el pull request y se integrar\u00e1 con master. Por \u00faltimo, deb\u00e9is crear una cuenta en Docker Hub y subir a ella la m\u00e1quina con el nombre DOCKER-ID/mads-todolist-2017 y el n\u00famero de versi\u00f3n 0.2. Poner en la Wiki del proyecto un enlace a la URL de la m\u00e1quina subida a Docker Hub, en una p\u00e1gina llamada Integraci\u00f3n continua .","title":"3. Configuraci\u00f3n m\u00e1quina Docker"},{"location":"03-integracion-continua/integracion-continua/#4-conectar-el-proyecto-mads-todolist-con-travis","text":"Travis es un servicio de integraci\u00f3n continua que se integra f\u00e1cilmente con GitHub. Tiene una versi\u00f3n gratuita para proyectos abiertos y una versi\u00f3n de pago para proyectos privados ( travis-ci.com ). La cuenta educativa de GitHub nos da permisos para trabajar en la versi\u00f3n de pago de forma gratuita. Travis se conecta con GitHub y lanza un proceso de build s\u00edncrono que descarga, compila y prueba la rama del repositorio en la que se ha subido un nuevo commit. Una vez hecha la integraci\u00f3n con Travis se podr\u00e1 comprobar en cada commit de GitHub si han pasado los tests correctamente: A su vez, en Travis, podr\u00e1s acceder y consultar los detalles de cada build: Comienza abriendo un nuevo issue llamado Integraci\u00f3n con Travis en el que desarrollar\u00e1s esta integraci\u00f3n.","title":"4. Conectar el proyecto mads-todolist con Travis"},{"location":"03-integracion-continua/integracion-continua/#41-como-darse-de-alta-en-travis-y-conectar-el-repositorio","text":"Para darte de alta en Travis debes acceder a travis-ci.com autentific\u00e1ndote con tu cuenta de GitHub. Debes seguir las instrucciones que aparecer\u00e1n para conectar el repositorio de la pr\u00e1ctica 3 con Travis. Comprueba en los ajustes que el repositorio se ha conectado correctamente con Travis:","title":"4.1. C\u00f3mo darse de alta en Travis y conectar el repositorio"},{"location":"03-integracion-continua/integracion-continua/#42-como-configurar-el-build-en-travis","text":"El build en Travis se configura con el fichero .travis.yml que debe estar en la ra\u00edz del repositorio. En este fichero se incluye las instrucciones para compilar y ejecutar los tests del proyecto. Crea un nuevo issue llamado Integraci\u00f3n con Travis y una rama nueva en el repositorio local. A\u00f1ade el siguiente fichero de configuraci\u00f3n .travis.yml y sube la rama al repo remoto en GitHub. Fichero .travis.yml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sudo: required language: bash branches: only: - master - production services: - docker before_install: - docker build -t DOCKER-ID/mads-todolist-2017:0.2 . script: - docker run --rm DOCKER-ID/mads-todolist-2017:0.2 /bin/bash -c sbt test Pod\u00e9is ver que el fichero de configuraci\u00f3n de Travis construye la m\u00e1quina Docker y despu\u00e9s la ejecuta, lanzando los tests en memoria. Si pasan todos los tests Travis marcar\u00e1 como correcto el build. Una vez hecho el push, Travis detectar\u00e1 autom\u00e1ticamente el cambio en la rama y realizar\u00e1 el build. Podremos ver en tiempo real la ejecuci\u00f3n de los tests, en el frontal de Travis y en https://travis-ci.com/USUARIO/REPOSITORIO . Cuando pasen correctamente los tests podr\u00e9is ver el tick en el commit de GitHub.","title":"4.2. C\u00f3mo configurar el build en Travis"},{"location":"03-integracion-continua/integracion-continua/#43-modificacion-del-fichero-travisyml-y-pull-request","text":"Modifica el fichero .travis.yml para incluir como \u00faltimo paso la ejecuci\u00f3n tambi\u00e9n de los tests de integraci\u00f3n ejecut\u00e1ndose contra una m\u00e1quina docker MySQL. Una vez comprobado que funciona correctamente, crea un pull request en GitHub para cerrar el issue. Travis lanzar\u00e1 una ejecuci\u00f3n del build del pull request, en el que mezclar\u00e1 la rama del PR con la rama master. GitHub nos informar\u00e1 tambi\u00e9n si los tests pasan correctamente y si podemos hacer la integraci\u00f3n del pull request sin problemas. Realizad el pull request y actualizad los repositorio locales.","title":"4.3. Modificaci\u00f3n del fichero .travis.yml y pull request"},{"location":"03-integracion-continua/integracion-continua/#44-modificacion-del-readme-del-proyecto","text":"Por \u00faltimo, subid un commit a master con un cambio en el README.md para incluir en \u00e9l una imagen que muestre el estado del \u00faltimo build realizado en Travis. Lo debe hacer un miembro distinto del que ha hecho el issue anterior. No hace falta crear un issue para esta modificaci\u00f3n. La imagen final del README.md deber\u00e1 ser similar a la siguiente: Puedes consultar c\u00f3mo embeber esta imagen en la p\u00e1gina de documentaci\u00f3n de Travis Embedding Status Images . Cuidado con indicar correctamente en la URL la rama de la que se va a obtener el estado (debe ser master ). Comprueba que funciona correctamente subiendo un commit a master con un fallo en alg\u00fan test. Y sube despu\u00e9s otro commit arregl\u00e1ndolo.","title":"4.4. Modificaci\u00f3n del README del proyecto"},{"location":"03-integracion-continua/integracion-continua/#5-nuevo-flujo-de-trabajo-en-github","text":"Como ya tenemos equipos de trabajo, debemos adaptar el flujo de trabajo tanto en GitHub a m\u00e1s de una persona. Cambiaremos lo siguiente: Selecci\u00f3n del issue : Al pasar un issue de \"Seleccionado\" a \"En marcha\" se debe asignar un responsable. Nueva rama con el issue : El responsable ser\u00e1 el que abra una rama nueva para el desarrollo del ticket y la subir\u00e1 a GitHub. Desarrollo : Se trabaja en la rama. Cualquier compa\u00f1ero puede unirse al ticket y trabajar junto con el responsable. Pull request : Cuando el ticket se ha terminado, el responsable abre un pull request en GitHub y pone la tarjeta en la columna En PR . Revisi\u00f3n de c\u00f3digo : Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing proposed changes in a pull request ). Al final, todos los miembros del equipo deben dar el OK, a\u00f1adiendo una reacci\u00f3n. Integraci\u00f3n del pull request : Cuando todos dan el OK, el responsable de la tarea integra el pull request en master . Actualizaci\u00f3n de los repositorios locales : Todos hacen un pull en master para actualizar los cambios del pull request. Y se borra la rama local ya integrada. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos del flujo de trabajo.","title":"5. Nuevo flujo de trabajo en GitHub"},{"location":"03-integracion-continua/integracion-continua/#51-comandos-git-para-el-trabajo-en-equipo","text":"Veamos algunos comandos de Git relacionados con el trabajo compartido con repositorios remotos. Subir una rama al repositorio remoto: $ git checkout -b nueva-rama $ git push -u origin nueva-rama Descargar una rama del repositorio remoto: $ git fetch $ git checkout -b nueva-rama origin/nueva-rama El comando git fetch se descarga todos los cambios pero no los mezcla con las ramas locales. Los deja en ramas cacheadas a las que les da el nombre del servidor y la rama ( origin/nueva-rama ). En el caso del comando anterior, una vez cacheada la rama origin/nueva-rama se crea la nueva-rama local con todos sus commits. Actualizar una rama con cambios que otros compa\u00f1eros han subido al repositorio remoto: $ git checkout nueva-rama $ git pull El comando git pull es equivalente a un git fetch seguido de un git merge . Algunos recomiendan no usar git pull , sino hacer siempre el merge manual. Por ejemplo: $ git checkout nueva-rama $ git fetch $ git merge origin/nueva-rama Subir cambios de la rama actual: (estando en la rama que queremos subir) $ git push El comando git push funcionar\u00e1 correctamente sin m\u00e1s par\u00e1metros si previamente hemos subido la rama con un git push -u . Comprobar el estado de las ramas locales y remotas: $ git branch -vv Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un git fetch --all antes: $ git fetch --all $ git branch -vv Es importante recordar que git fetch (a diferencia de git pull ) no modifica los repositorios locales, sino que baja las ramas remotas cach\u00e9s locales. Informaci\u00f3n de los repositorios remotos: $ git remote show origin Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos. git remote -v update Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas). Borrado de ramas remotas desde el terminar: $ git push origin --delete nueva-rama $ git remote prune origin","title":"5.1. Comandos Git para el trabajo en equipo"},{"location":"03-integracion-continua/integracion-continua/#52-desarrollo-de-una-pagina-acerca-de","text":"Probar todos los comandos anteriores en una rama en la que se implemente la p\u00e1gina \"Acerca de\" en la que se muestre una con los miembros del equipo y el n\u00famero de versi\u00f3n de la aplicaci\u00f3n (0.3-SNAPSHOT). Crear un issue en el que participen todos los miembros del equipo. Crear una rama en la que desarrollar los cambios. Cada miembro del equipo deber\u00e1 realizar un commit en el que se a\u00f1ade su nombre a la lista. Crear el pull request en GitHub, revisar el c\u00f3digo y aceptarlo.","title":"5.2. Desarrollo de una p\u00e1gina \"Acerca de\""},{"location":"03-integracion-continua/integracion-continua/#53-configuracion-de-la-rama-production-y-publicacion-de-v10","text":"El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda ). Pero vamos a introducir alguna variante en la nomenclatura de las ramas.","title":"5.3. Configuraci\u00f3n de la rama production y publicaci\u00f3n de v1.0"},{"location":"03-integracion-continua/integracion-continua/#ramas-de-largo-recorrido","text":"En la versi\u00f3n original de GitFlow se publican las distintas versiones del proyecto en la rama long-lived master y se hace el desarrollo en la rama develop . Nosotros vamos a adoptar esta idea, pero cambiando el nombre de las ramas. La rama de desarrollo ser\u00e1 la rama master en la que hemos trabajado desde el principio, y la rama con las versiones lanzadas la llamaremos production .","title":"Ramas de largo recorrido"},{"location":"03-integracion-continua/integracion-continua/#ramas-de-feature","text":"Desde el comienzo de trabajo con Git en las pr\u00e1cticas 1 y 2 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo merge , mientras que nosotros las integramos haciendo un pull request.","title":"Ramas de feature"},{"location":"03-integracion-continua/integracion-continua/#configuracion-paso-a-paso","text":"El equipo elegir\u00e1 un responsable de integraci\u00f3n que se encargue de crear la rama production y publicar en ella la primera versi\u00f3n v1.0 del proyecto. Cread un issue con la tarea Lanzar release v1.0 que tendr\u00e1 como responsable esta persona escogida. Una vez que se ha integrado en master el pull request con la p\u00e1gina \"Acerca de\" que contiene la lista de desarrolladores del proyecto y el n\u00famero de versi\u00f3n \"Versi\u00f3n 0.3-SNAPSHOT\", el responsable de integraci\u00f3n deber\u00e1 publicar la nueva versi\u00f3n siguiendo los pasos de GitFlow: Crear la rama production y publicarla en GitHub. Crear la rama local release-v1.0 a partir de master . Realizar en esta rama los cambios espec\u00edficos de la versi\u00f3n. En nuestro caso: Cambiar en la p\u00e1gina \"Acerca de\" \"Versi\u00f3n 0.3-SNAPSHOT\" por \"Versi\u00f3n 1.0\" A\u00f1adir en la p\u00e1gina la fecha de publicaci\u00f3n de la versi\u00f3n. Cambiar la versi\u00f3n en el build.sbt a 1.0 . Publicar la rama release-v1.0 en GitHub y hacer un pull request sobre production . Mezclar tambi\u00e9n la rama de release con master . Por \u00faltimo, hacer un commit en master cambiando el n\u00famero de versi\u00f3n a 1.1-SNAPSHOT (en el \"Acerca de\" y en el build.sbt ). Una vez hecho esto ya se puede borrar la rama release-v1.0 y las ramas production y master estar\u00e1n actualizadas a las nuevas versiones. La rama production tambi\u00e9n ser\u00e1 integrada por Travis. Debemos comprobar que pasan todos los tests.","title":"Configuraci\u00f3n paso a paso"},{"location":"03-integracion-continua/integracion-continua/#54-publicacion-automatica-de-nuevas-versiones","text":"Implementad en master un nuevo issue en el que hag\u00e1is lo siguiente: Modificar el fichero de configuraci\u00f3n de Travis para que la versi\u00f3n de la m\u00e1quina docker sea la definida por el n\u00famero de build de Travis (en la variable de entorno TRAVIS_BUILD_NUMBER ). A\u00f1adir en la configuraci\u00f3n de Travis la publicaci\u00f3n de la m\u00e1quina docker en Docker Hub cada vez que se realice un build en la rama master (consultar en la p\u00e1gina de informaci\u00f3n de Travis Using Docker in Builds ). Deber\u00e9is publicar dos versiones de la m\u00e1quina: la versi\u00f3n con el \u00faltimo n\u00famero de build y la versi\u00f3n latest . De esta forma, en Docker Hub estar\u00e1 siempre actualizada la versi\u00f3n latest a \u00faltima versi\u00f3n compilada en master y tambi\u00e9n se tendr\u00e1 un hist\u00f3rico de todas las versiones compilads.","title":"5.4. Publicaci\u00f3n autom\u00e1tica de nuevas versiones"},{"location":"03-integracion-continua/integracion-continua/#6-desarrollo-de-caracteristicas-adicionales-en-equipo","text":"En esta parte desarrollar\u00e9is tres caracter\u00edsticas (historias de usuario) adicionales en el proyecto. Deb\u00e9is definir una p\u00e1gina en la wiki para cada una de ellas, y crear la p\u00e1gina principal de la wiki con el t\u00edtulo Versi\u00f3n 1.1 y con dos tablas ( pendientes y terminadas ) que contenga los t\u00edtulos, enlaces y una breve descripci\u00f3n de cada una de las caracter\u00edsticas (como hemos hecho en la wiki en las pr\u00e1cticas 1 y 2). Tambi\u00e9n igual que en las pr\u00e1cticas 1 y 2, se crear\u00e1 una etiqueta para cada una de las historias de usuario y se marcar\u00e1n con ella los issues que las conforman. Una de historia de usuario puede contener varios issues o s\u00f3lo uno. Tambi\u00e9n se marcar\u00e1n los issues/pull requests con el milestone 1.1 , que ser\u00e1 el n\u00famero de versi\u00f3n definitiva de la aplicaci\u00f3n cuando se termine esta pr\u00e1ctica 3. Cada historia de usuario deber\u00e1 tener un responsable distinto, que ser\u00e1 se encargar\u00e1 de realizar la formulaci\u00f3n de la historia en la p\u00e1gina wiki, descomponerla en issues y de probar que se cumplen las condiciones de satisfacci\u00f3n antes de darla por terminada. Escribid el responsable de la historia en su p\u00e1gina. Aunque lo normal es que los issues en los que se descompone una historia tengan el mismo responsable que la historia, tambi\u00e9n se pueden definir otros responsables (por ejemplo, si es un issue orientado a crear las vistas y en el equipo hay una persona que domina Bootstrap y el dise\u00f1o de interfaces de usuario).","title":"6. Desarrollo de caracter\u00edsticas adicionales en equipo"},{"location":"03-integracion-continua/integracion-continua/#61-funcionalidades-adicionales","text":"Proponemos tres historias de usuario peque\u00f1as, que se pueden desarrollar todas en una semana. Para las historias 2 y 3 se deben realizar tests, como hemos venido haciendo en las pr\u00e1cticas 1 y 2. Aunque no es obligatorio, puedes desarrollarlas usando TDD. Arreglo de la interfaz de usuario de tareas y tableros, definiendo una barra de navegaci\u00f3n de Bootstrap con las opciones: TodoList (t\u00edtulo de la aplicaci\u00f3n), Mis tareas (enlace a la p\u00e1gina de tareas), Mis tableros (enlace a la p\u00e1gina de tableros) y a la derecha un desplegable con el nombre del usuario y las opciones Perfil (enlace al perfil, si est\u00e1 implementado) y Salir (salir y enlace a login). A\u00f1adir los siguientes campos adicionales a la tarea : fechaCreacion . Poner como fecha de creaci\u00f3n la fecha y hora en la que se crea la tarea (hacerlo de forma autom\u00e1tica, sin ped\u00edrselo al usuario, ni que el usuario pueda modificarlo). Y dejar que el usuario introduzca opcionalmente la fecha l\u00edmite en la p\u00e1gina de creaci\u00f3n/edici\u00f3n de una tarea. En la tabla con el listado de tareas no mostrar la fecha de creaci\u00f3n (es un atributo interno, que por ahora no mostramos) pero s\u00ed la fecha l\u00edmite. A\u00f1adir un campo adicional de terminado a las tareas. A\u00f1adir una acci\u00f3n en el listado de tareas para terminar una tarea. En el listado de tareas aparecer\u00e1n solo las tareas que no se hayan terminado. Pon un enlace Terminadas para mostrar las tareas terminadas. Si quer\u00e9is incluir alguna funcionalidad opcional que hay\u00e1is implementado, pod\u00e9is hacerlo adem\u00e1s de lo anterior. Deb\u00e9is a\u00f1adir la p\u00e1gina correspondiente con la funcionalidad en la wiki.","title":"6.1. Funcionalidades adicionales"},{"location":"03-integracion-continua/integracion-continua/#62-publicacion-de-la-version-11","text":"Una vez terminadas y probadas todas las historias de usuario, se deber\u00e1 crear una rama para la versi\u00f3n 1.1 e integrarla en la rama production tal y como se ha hecho con la versi\u00f3n 1.0. Realizar en la rama de versi\u00f3n los commits necesarios para el cambio de versi\u00f3n (en el fichero build.sbt y en la p\u00e1gina Acerca de ) y para actualizar los ficheros relacionados con el esquema de datos (el fichero schema.sql y upgradeXX.sql ). Igual que se hizo con la versi\u00f3n 1.0, terminar integrando esta rama tambi\u00e9n en master y modificando el n\u00famero de versi\u00f3n a 1.2-SNAPSHOT .","title":"6.2. Publicaci\u00f3n de la versi\u00f3n 1.1"},{"location":"03-integracion-continua/integracion-continua/#7-entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 2 semanas y debe estar terminada el martes 21 de noviembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 7% en la nota final de la asignatura. Para realizar la entrega uno de los miembros del equipo debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo la historia Git. Para ello comprime el directorio local del proyecto despu\u00e9s de haber hecho un clean . Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 2 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Correcci\u00f3n del c\u00f3digo.","title":"7. Entrega y evaluaci\u00f3n"},{"location":"04-iteracion-scrum/iteracion-scrum/","text":"Pr\u00e1ctica 4: Sprint de Scrum 1. Objetivos y resumen de la pr\u00e1ctica 2. Planificaci\u00f3n del sprint 3. Desarrollo del sprint 4. Entrega y evaluaci\u00f3n 1. Objetivos y resumen de la pr\u00e1ctica En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que la pr\u00e1ctica 3. Durante las 4 semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un incremento de la aplicaci\u00f3n todolist . Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 3 para desarrollar sobre la rama master : Una p\u00e1gina en la Wiki de GitHub para cada historia de usuario, cuya implementaci\u00f3n se divide en issues Rama por issue y pull request a master para integrarla En el tablero en GitHub se representan el estado de los issues y pull requests El repositorio est\u00e1 conectado a Travis que comprueba de forma autom\u00e1tica los tests en las integraciones de los pull requests en master y sube una imagen docker a Docker Hub. En Docker Hub se tienen numerados todos los builds exitosos de master, y est\u00e1 etiquetada como latest la \u00faltima versi\u00f3n de la imagen. Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n ( 1.2 ), usando el mismo flujo de trabajo que la pr\u00e1ctica anterior. Adem\u00e1s, aplicaremos algunos elementos de Scrum: Planificaci\u00f3n del sprint Reuniones de scrum diario Revisi\u00f3n del sprint (se har\u00e1 en la \u00faltima clase de teor\u00eda de la asignatura) Retrospectiva del sprint 2. Planificaci\u00f3n del sprint Cada equipo crear\u00e1 un tablero en Trello al que se a\u00f1adir\u00e1n todos los miembros y el profesor. El tablero constar\u00e1 de las siguientes columnas, en las que se gestionar\u00e1n las historias de usuario: Backlog : Posibles historias de usuario a seleccionar en el sprint. Sprint : Historias de usuario a terminar en el sprint. En marcha : Historias de usuario que se est\u00e1n desarrollando. Para pasar la historia a esta columna, debe estar terminada su p\u00e1gina en la Wiki en GitHub (y enumeradas todas las COS). En la tarjeta pondremos un enlace a esa wiki. QA : Historias de usuario a las que se les est\u00e1 realizando pruebas funcionales y de rendimiento. Cuando todos los issues de una historia de usuario se han integrado, se anota el enlace al build en DockerHub y se prueba la imagen en un entorno de stage, realiz\u00e1ndose pruebas funcionales y de rendimiento relacionadas con la historia de usuario. Si se detectan bugs, se abren nuevos issues en GitHub para resolverlos, y la historia queda detenida en QA. Terminadas : Historias de usuario que se han probado satisfactoriamente. 2.1. Selecci\u00f3n del backlog El equipo, junto con el profesor, seleccionar\u00e1 las posibles historias de usuario a realizar en la iteraci\u00f3n y estimar\u00e1 su tama\u00f1o. Podr\u00e1n escogerse cualquiera de las definidas en el workshop de mapping de historias de usuario realizado en clase, o idear alguna nueva. El resultado del mapping de historias de usuario est\u00e1 recogido en los siguientes tableros: https://trello.com/b/UaatzbrN/mapa-1-todolist https://trello.com/b/LGRlvvAU/mapa-2-todolist https://trello.com/b/L6gTNPaF/mapa-3-todolist https://trello.com/b/WbQxj8lW/mapa-4-todolist Todos los miembros deber\u00e1n tomar el papel product owner y aportar ideas y sugerencias para definir las historias de usuario. Cada historia incluida en la columna de Backlog se analizar\u00e1, especificando claramente su descripci\u00f3n y su alcance. Para la descripci\u00f3n se recomienda usar el formato que vimos en clase: Como ROL quiero ACCI\u00d3N para RESULTADO u OBJETIVO . Tambi\u00e9n se enumerar\u00e1n una serie de condiciones de satisfacci\u00f3n (COS) que deben cumplirse para dar la historia como terminada. Estas condiciones de satisfacci\u00f3n son esenciales a la hora de determinar el alcance de la historia. Al incluir la historia en la columna de Backlog se realizar\u00e1 un planning pocker para volver a consensuar su tama\u00f1o (considerad el tama\u00f1o previo de la historia como una indicaci\u00f3n, pero pod\u00e9is modificarlo). El profesor no participar\u00e1 en el planning pocker , pero podr\u00e1 pedir aclaraciones sobre el tama\u00f1o de las historias. En la tarjeta de Trello se escribir\u00e1 el t\u00edtulo, el tama\u00f1o (etiqueta) y la descripci\u00f3n de la historia. 2.2. Planificaci\u00f3n del sprint Se deben incluir en el sprint historias por un tama\u00f1o total 4 puntos x n\u00famero de personas del equipo: Equipo de 2 personas: 8 puntos Equipo de 3 personas: 12 puntos Suponemos la siguiente asignaci\u00f3n de puntos al tama\u00f1o de las tareas: S: 1 punto M: 2 puntos (el doble que una S) L: 4 puntos (el doble que una M) Cuando se seleccione la historia para el sprint actual y se pase a la columna de Sprint se a\u00f1adir\u00e1 un enlace a la p\u00e1gina correspondiente en la wiki de GitHub, donde se copiar\u00e1 el t\u00edtulo, la descripci\u00f3n y se detallar\u00e1n las condiciones de satisfacci\u00f3n y los issues en los que se prev\u00e9 descomponer la historia. 2.3. Responsables de historia de usuario Una vez seleccionadas todas las historias los miembros del equipo elegir\u00e1n responsables para cada historia y se asignar\u00e1n en Trello. Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno. El responsable de cada historia de usuario En Trello: - Se asigna como responsable de la tarea - Mueve la tarea de un estado a otro En GitHub: - Escribe la p\u00e1gina en la Wiki y rellena las COS y los issues - Crea la etiqueta con la historia y los asigna a los issues 3. Desarrollo del sprint Se deber\u00e1n realizar los siguientes eventos definidos por Scrum, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo: Scrum diario (al menos simular 2 reuniones: la segunda y tercera semana). En nuestro \"tiempo simulado\" en las pr\u00e1cticas, una semana es como un d\u00eda de trabajo completo en una empresa. Retrospectiva del sprint 3.1. Resumen del desarrollo Cada miembro del equipo selecciona el issue a desarrollar. Lo normal es que cada miembro desarrolle un \u00fanico issue de forma concurrente, aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue no puede terminarse por estar bloqueado por otro). Ramas para los issues y pull requests con revisi\u00f3n de c\u00f3digo para integrar los pull requests en master. Cada issue debe contener tests autom\u00e1ticos que prueben los cambios. En el caso de no poder incluirse (por ejemplo en issues que desarrollan el controller y la vista) se debe especificar en la wiki de la historia de usuario del issue los tests manuales que habr\u00eda que hacer . Modificamos las columnas del tablero de issues de GitHub para adaptarlo mejor a Kanban: Pendientes - Se a\u00f1aden aqu\u00ed los issues de una historia de usuario cuando la historia de usuario se pasa a En marcha en Trello. En desarrollo - Issue en desarrollo. Cada issue debe corresponderse con una rama de Git. En desarrollo - Done - Se ha terminado el desarrollo y los tests unitarios. Si la columna de Integraci\u00f3n no ha alcanzado su WIP, crear el PR, eliminar el issue de la columna y a\u00f1adir en la columna Integraci\u00f3n el PR. Integraci\u00f3n - Se ha creado el pull request pidiendo la integraci\u00f3n del issue en la rama master . Se solicita la revisi\u00f3n del c\u00f3digo por al menos 1 compa\u00f1ero. Esperando tests funcionales - Se ha aprobado el pull request, se ha realizado la integraci\u00f3n master y Travis da el OK. El issue est\u00e1 a la espera de que se realicen los tests funcionales (cuando la historia de usuario pase a la columna de Trello QA . Terminados - La historia de usuario correspondiente al issue ha pasado las pruebas funcionales. L\u00edmite de Work In Progress (WIP): Estimar un n\u00famero de l\u00edmite de WIP para las columnas En desarrollo e Integraci\u00f3n . No se podr\u00e1 incluir en esas columnas m\u00e1s tarjetas que las definidas en el n\u00famero l\u00edmite de WIP. Las tarjetas en las columna En desarrollo - Done se suman a las que hay en la columna En desarrollo . El l\u00edmite WIP va a depender del n\u00famero de integrantes del equipo. Si se define un l\u00edmite WIP demasiado bajo habr\u00e1 personas ociosas, mientras que si se define un l\u00edmite WIP demasiado alto habr\u00e1 acumulaci\u00f3n de tareas sin terminar. - Seguimos usando Travis para la integraci\u00f3n continua. 3.2. Publicaci\u00f3n de nueva versi\u00f3n Al final del desarrollo se deber\u00e1 publicar la nueva versi\u00f3n (1.2) en la rama production , y subir a DockerHub la imagen resultante con la etiqueta 1.2 y latest (hacerlo manualmente). 3.3. Documentaci\u00f3n del desarrollo Documentar los dailys, para incluir un informe en el documento. Documentar la evoluci\u00f3n de los tableros (Trello y GitHub) y alguna m\u00e9trica del desarrollo (pull requests por semana, velocidad de la semana, gr\u00e1fica de burndown, etc.). 4. Entrega y evaluaci\u00f3n La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas: - Se realizar\u00e1 una revisi\u00f3n del sprint de 10 minutos en clase de teor\u00eda del 20 de diciembre (presentaci\u00f3n de las funcionalidades introducidas (PowerPoint) y demo). - La fecha l\u00edmite de entrega es el viernes 22 de diciembre . Se deber\u00e1 tener disponible en esa fecha: Versi\u00f3n 1.2 de la m\u00e1quina Docker en DockerHub Tablero Trello Repositorio GitHub Tablero de issues completados Wiki con las historias de usuario Directorio doc del proyecto en el que se incluir\u00e1 un documento markdown con el informe de la pr\u00e1ctica y un PDF con el PowerPoint realizado en la demo. En el informe de la pr\u00e1ctica se incluir\u00e1: Historias de usuario escogidas para el sprint (copiar la descripci\u00f3n y las condiciones de satisfacci\u00f3n tal y como se definieron al principio). Funcionalidades implementadas (breve descripci\u00f3n para el usuario y breve descripci\u00f3n t\u00e9cnica). Informe sobre la metodolog\u00eda seguida (ejemplos de evoluci\u00f3n del tablero, alguna m\u00e9trica del desarrollo realizado en el sprint) Informes sobre las reuniones de Scrum (planificaci\u00f3n del sprint, scrum diario, revisi\u00f3n). Resultado de la retrospectiva: qu\u00e9 ha ido bien y qu\u00e9 se podr\u00eda mejorar. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo de los issues Correcci\u00f3n del c\u00f3digo Correcto funcionamiento Informe de la pr\u00e1ctica Si el trabajo de alg\u00fan miembro del equipo es significativamente de menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su calificaci\u00f3n","title":"Pr\u00e1ctica 4: Sprint de Scrum"},{"location":"04-iteracion-scrum/iteracion-scrum/#practica-4-sprint-de-scrum","text":"1. Objetivos y resumen de la pr\u00e1ctica 2. Planificaci\u00f3n del sprint 3. Desarrollo del sprint 4. Entrega y evaluaci\u00f3n","title":"Pr\u00e1ctica 4: Sprint de Scrum"},{"location":"04-iteracion-scrum/iteracion-scrum/#1-objetivos-y-resumen-de-la-practica","text":"En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que la pr\u00e1ctica 3. Durante las 4 semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un incremento de la aplicaci\u00f3n todolist . Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 3 para desarrollar sobre la rama master : Una p\u00e1gina en la Wiki de GitHub para cada historia de usuario, cuya implementaci\u00f3n se divide en issues Rama por issue y pull request a master para integrarla En el tablero en GitHub se representan el estado de los issues y pull requests El repositorio est\u00e1 conectado a Travis que comprueba de forma autom\u00e1tica los tests en las integraciones de los pull requests en master y sube una imagen docker a Docker Hub. En Docker Hub se tienen numerados todos los builds exitosos de master, y est\u00e1 etiquetada como latest la \u00faltima versi\u00f3n de la imagen. Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n ( 1.2 ), usando el mismo flujo de trabajo que la pr\u00e1ctica anterior. Adem\u00e1s, aplicaremos algunos elementos de Scrum: Planificaci\u00f3n del sprint Reuniones de scrum diario Revisi\u00f3n del sprint (se har\u00e1 en la \u00faltima clase de teor\u00eda de la asignatura) Retrospectiva del sprint","title":"1. Objetivos y resumen de la pr\u00e1ctica"},{"location":"04-iteracion-scrum/iteracion-scrum/#2-planificacion-del-sprint","text":"Cada equipo crear\u00e1 un tablero en Trello al que se a\u00f1adir\u00e1n todos los miembros y el profesor. El tablero constar\u00e1 de las siguientes columnas, en las que se gestionar\u00e1n las historias de usuario: Backlog : Posibles historias de usuario a seleccionar en el sprint. Sprint : Historias de usuario a terminar en el sprint. En marcha : Historias de usuario que se est\u00e1n desarrollando. Para pasar la historia a esta columna, debe estar terminada su p\u00e1gina en la Wiki en GitHub (y enumeradas todas las COS). En la tarjeta pondremos un enlace a esa wiki. QA : Historias de usuario a las que se les est\u00e1 realizando pruebas funcionales y de rendimiento. Cuando todos los issues de una historia de usuario se han integrado, se anota el enlace al build en DockerHub y se prueba la imagen en un entorno de stage, realiz\u00e1ndose pruebas funcionales y de rendimiento relacionadas con la historia de usuario. Si se detectan bugs, se abren nuevos issues en GitHub para resolverlos, y la historia queda detenida en QA. Terminadas : Historias de usuario que se han probado satisfactoriamente.","title":"2. Planificaci\u00f3n del sprint"},{"location":"04-iteracion-scrum/iteracion-scrum/#21-seleccion-del-backlog","text":"El equipo, junto con el profesor, seleccionar\u00e1 las posibles historias de usuario a realizar en la iteraci\u00f3n y estimar\u00e1 su tama\u00f1o. Podr\u00e1n escogerse cualquiera de las definidas en el workshop de mapping de historias de usuario realizado en clase, o idear alguna nueva. El resultado del mapping de historias de usuario est\u00e1 recogido en los siguientes tableros: https://trello.com/b/UaatzbrN/mapa-1-todolist https://trello.com/b/LGRlvvAU/mapa-2-todolist https://trello.com/b/L6gTNPaF/mapa-3-todolist https://trello.com/b/WbQxj8lW/mapa-4-todolist Todos los miembros deber\u00e1n tomar el papel product owner y aportar ideas y sugerencias para definir las historias de usuario. Cada historia incluida en la columna de Backlog se analizar\u00e1, especificando claramente su descripci\u00f3n y su alcance. Para la descripci\u00f3n se recomienda usar el formato que vimos en clase: Como ROL quiero ACCI\u00d3N para RESULTADO u OBJETIVO . Tambi\u00e9n se enumerar\u00e1n una serie de condiciones de satisfacci\u00f3n (COS) que deben cumplirse para dar la historia como terminada. Estas condiciones de satisfacci\u00f3n son esenciales a la hora de determinar el alcance de la historia. Al incluir la historia en la columna de Backlog se realizar\u00e1 un planning pocker para volver a consensuar su tama\u00f1o (considerad el tama\u00f1o previo de la historia como una indicaci\u00f3n, pero pod\u00e9is modificarlo). El profesor no participar\u00e1 en el planning pocker , pero podr\u00e1 pedir aclaraciones sobre el tama\u00f1o de las historias. En la tarjeta de Trello se escribir\u00e1 el t\u00edtulo, el tama\u00f1o (etiqueta) y la descripci\u00f3n de la historia.","title":"2.1. Selecci\u00f3n del backlog"},{"location":"04-iteracion-scrum/iteracion-scrum/#22-planificacion-del-sprint","text":"Se deben incluir en el sprint historias por un tama\u00f1o total 4 puntos x n\u00famero de personas del equipo: Equipo de 2 personas: 8 puntos Equipo de 3 personas: 12 puntos Suponemos la siguiente asignaci\u00f3n de puntos al tama\u00f1o de las tareas: S: 1 punto M: 2 puntos (el doble que una S) L: 4 puntos (el doble que una M) Cuando se seleccione la historia para el sprint actual y se pase a la columna de Sprint se a\u00f1adir\u00e1 un enlace a la p\u00e1gina correspondiente en la wiki de GitHub, donde se copiar\u00e1 el t\u00edtulo, la descripci\u00f3n y se detallar\u00e1n las condiciones de satisfacci\u00f3n y los issues en los que se prev\u00e9 descomponer la historia.","title":"2.2. Planificaci\u00f3n del sprint"},{"location":"04-iteracion-scrum/iteracion-scrum/#23-responsables-de-historia-de-usuario","text":"Una vez seleccionadas todas las historias los miembros del equipo elegir\u00e1n responsables para cada historia y se asignar\u00e1n en Trello. Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno. El responsable de cada historia de usuario En Trello: - Se asigna como responsable de la tarea - Mueve la tarea de un estado a otro En GitHub: - Escribe la p\u00e1gina en la Wiki y rellena las COS y los issues - Crea la etiqueta con la historia y los asigna a los issues","title":"2.3. Responsables de historia de usuario"},{"location":"04-iteracion-scrum/iteracion-scrum/#3-desarrollo-del-sprint","text":"Se deber\u00e1n realizar los siguientes eventos definidos por Scrum, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo: Scrum diario (al menos simular 2 reuniones: la segunda y tercera semana). En nuestro \"tiempo simulado\" en las pr\u00e1cticas, una semana es como un d\u00eda de trabajo completo en una empresa. Retrospectiva del sprint","title":"3. Desarrollo del sprint"},{"location":"04-iteracion-scrum/iteracion-scrum/#31-resumen-del-desarrollo","text":"Cada miembro del equipo selecciona el issue a desarrollar. Lo normal es que cada miembro desarrolle un \u00fanico issue de forma concurrente, aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue no puede terminarse por estar bloqueado por otro). Ramas para los issues y pull requests con revisi\u00f3n de c\u00f3digo para integrar los pull requests en master. Cada issue debe contener tests autom\u00e1ticos que prueben los cambios. En el caso de no poder incluirse (por ejemplo en issues que desarrollan el controller y la vista) se debe especificar en la wiki de la historia de usuario del issue los tests manuales que habr\u00eda que hacer . Modificamos las columnas del tablero de issues de GitHub para adaptarlo mejor a Kanban: Pendientes - Se a\u00f1aden aqu\u00ed los issues de una historia de usuario cuando la historia de usuario se pasa a En marcha en Trello. En desarrollo - Issue en desarrollo. Cada issue debe corresponderse con una rama de Git. En desarrollo - Done - Se ha terminado el desarrollo y los tests unitarios. Si la columna de Integraci\u00f3n no ha alcanzado su WIP, crear el PR, eliminar el issue de la columna y a\u00f1adir en la columna Integraci\u00f3n el PR. Integraci\u00f3n - Se ha creado el pull request pidiendo la integraci\u00f3n del issue en la rama master . Se solicita la revisi\u00f3n del c\u00f3digo por al menos 1 compa\u00f1ero. Esperando tests funcionales - Se ha aprobado el pull request, se ha realizado la integraci\u00f3n master y Travis da el OK. El issue est\u00e1 a la espera de que se realicen los tests funcionales (cuando la historia de usuario pase a la columna de Trello QA . Terminados - La historia de usuario correspondiente al issue ha pasado las pruebas funcionales. L\u00edmite de Work In Progress (WIP): Estimar un n\u00famero de l\u00edmite de WIP para las columnas En desarrollo e Integraci\u00f3n . No se podr\u00e1 incluir en esas columnas m\u00e1s tarjetas que las definidas en el n\u00famero l\u00edmite de WIP. Las tarjetas en las columna En desarrollo - Done se suman a las que hay en la columna En desarrollo . El l\u00edmite WIP va a depender del n\u00famero de integrantes del equipo. Si se define un l\u00edmite WIP demasiado bajo habr\u00e1 personas ociosas, mientras que si se define un l\u00edmite WIP demasiado alto habr\u00e1 acumulaci\u00f3n de tareas sin terminar. - Seguimos usando Travis para la integraci\u00f3n continua.","title":"3.1. Resumen del desarrollo"},{"location":"04-iteracion-scrum/iteracion-scrum/#32-publicacion-de-nueva-version","text":"Al final del desarrollo se deber\u00e1 publicar la nueva versi\u00f3n (1.2) en la rama production , y subir a DockerHub la imagen resultante con la etiqueta 1.2 y latest (hacerlo manualmente).","title":"3.2. Publicaci\u00f3n de nueva versi\u00f3n"},{"location":"04-iteracion-scrum/iteracion-scrum/#33-documentacion-del-desarrollo","text":"Documentar los dailys, para incluir un informe en el documento. Documentar la evoluci\u00f3n de los tableros (Trello y GitHub) y alguna m\u00e9trica del desarrollo (pull requests por semana, velocidad de la semana, gr\u00e1fica de burndown, etc.).","title":"3.3. Documentaci\u00f3n del desarrollo"},{"location":"04-iteracion-scrum/iteracion-scrum/#4-entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas: - Se realizar\u00e1 una revisi\u00f3n del sprint de 10 minutos en clase de teor\u00eda del 20 de diciembre (presentaci\u00f3n de las funcionalidades introducidas (PowerPoint) y demo). - La fecha l\u00edmite de entrega es el viernes 22 de diciembre . Se deber\u00e1 tener disponible en esa fecha: Versi\u00f3n 1.2 de la m\u00e1quina Docker en DockerHub Tablero Trello Repositorio GitHub Tablero de issues completados Wiki con las historias de usuario Directorio doc del proyecto en el que se incluir\u00e1 un documento markdown con el informe de la pr\u00e1ctica y un PDF con el PowerPoint realizado en la demo. En el informe de la pr\u00e1ctica se incluir\u00e1: Historias de usuario escogidas para el sprint (copiar la descripci\u00f3n y las condiciones de satisfacci\u00f3n tal y como se definieron al principio). Funcionalidades implementadas (breve descripci\u00f3n para el usuario y breve descripci\u00f3n t\u00e9cnica). Informe sobre la metodolog\u00eda seguida (ejemplos de evoluci\u00f3n del tablero, alguna m\u00e9trica del desarrollo realizado en el sprint) Informes sobre las reuniones de Scrum (planificaci\u00f3n del sprint, scrum diario, revisi\u00f3n). Resultado de la retrospectiva: qu\u00e9 ha ido bien y qu\u00e9 se podr\u00eda mejorar. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo de los issues Correcci\u00f3n del c\u00f3digo Correcto funcionamiento Informe de la pr\u00e1ctica Si el trabajo de alg\u00fan miembro del equipo es significativamente de menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su calificaci\u00f3n","title":"4. Entrega y evaluaci\u00f3n"}]}